<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>WeChatTemplate-项目介绍01</title>
    <url>/2020/06/11/project/wechat-template/wechat-template01/</url>
    <content><![CDATA[<h1 id="WeChat-Template"><a href="#WeChat-Template" class="headerlink" title="WeChat Template"></a>WeChat Template</h1><blockquote>
<p>一套基于SpringBoot &amp; Shiro 以及 Uni-app构建的微信小程序脚手架</p>
</blockquote>
<p><strong>开源地址：</strong> <a href="https://github.com/TyCoding/wechat-template" target="_blank" rel="noopener">https://github.com/TyCoding/wechat-template</a> 欢迎Star、Fork支持作者。</p>
<a id="more"></a>

<h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>本 <a href="https://github.com/TyCoding/wechat-template" target="_blank" rel="noopener">仓库</a> 中包含了两个项目：</p>
<ul>
<li><code>wechat-api</code>: 基于SpringBoot、Shiro构建的仅提供Restful api的后端项目</li>
<li><code>wechat-app</code>: 基于Uni-app构建的微信小程序</li>
</ul>
<p><strong>你能学到什么</strong></p>
<ol>
<li>Uni-app与Java Web项目结合的最佳实践</li>
<li>SpringBoot与Shiro的集成，以及身份校验、Token交互的实现</li>
<li>如何优雅的封装一套Uni-app(微信小程序)脚手架，包括：request api封装、vuex存储、router页面路由、与Java后端数据交互</li>
<li>如何优雅的封装一套SpringBoot&amp;Shiro权限项目脚手架，如何处理前后端分离Token交互</li>
<li>如何处理小程序端Request请求，后续将从Login请求展开逐步分析前后端交互流程</li>
</ol>
<h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>开发环境：</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Version</th>
</tr>
</thead>
<tbody><tr>
<td>JDK</td>
<td>1.8</td>
</tr>
<tr>
<td>MySql</td>
<td>5.7</td>
</tr>
<tr>
<td>IDEA</td>
<td>2020.1</td>
</tr>
<tr>
<td>HBuilderX</td>
<td>2.7.9</td>
</tr>
<tr>
<td>微信开发者工具</td>
<td>1.03</td>
</tr>
</tbody></table>
<p><code>wechat-api</code>小程序后端：</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Version</th>
</tr>
</thead>
<tbody><tr>
<td>SpringBoot</td>
<td>2.1.3.RELEASE</td>
</tr>
<tr>
<td>Spring-Shiro</td>
<td>1.3.2</td>
</tr>
<tr>
<td>Mybatis</td>
<td>2.1.0</td>
</tr>
<tr>
<td>Mybatis-Plus</td>
<td>3.2.0</td>
</tr>
</tbody></table>
<p><code>wechat-app</code>小程序前端：</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Version</th>
</tr>
</thead>
<tbody><tr>
<td>uni-app</td>
<td>2.7.9</td>
</tr>
<tr>
<td>thorui</td>
<td>1.5.0</td>
</tr>
<tr>
<td>luch-request</td>
<td>3.0.2</td>
</tr>
<tr>
<td>uni-simple-route</td>
<td>1.8.4</td>
</tr>
</tbody></table>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><h3 id="wechat-api"><a href="#wechat-api" class="headerlink" title="wechat-api"></a>wechat-api</h3><p>源码：<a href="https://github.com/TyCoding/wechat-template/tree/master/wechat-api" target="_blank" rel="noopener">https://github.com/TyCoding/wechat-template/tree/master/wechat-api</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">└── src</span><br><span class="line">    ├── main</span><br><span class="line">    │   ├── java</span><br><span class="line">    │   │   └── cn</span><br><span class="line">    │   │       └── tycoding</span><br><span class="line">    │   │           ├── Application.java</span><br><span class="line">    │   │           ├── biz</span><br><span class="line">    │   │           │   ├── controller	-- 控制层</span><br><span class="line">    │   │           │   ├── entity		-- 实体类</span><br><span class="line">    │   │           │   ├── mapper		-- Mybatis映射接口</span><br><span class="line">    │   │           │   └── service		-- 业务层</span><br><span class="line">    │   │           └── common			-- 公共层</span><br><span class="line">    │   │               ├── auth		-- Shiro鉴权相关</span><br><span class="line">    │   │               ├── config		-- 项目配置相关</span><br><span class="line">    │   │               ├── constants	-- 项目公共常量</span><br><span class="line">    │   │               ├── controller	-- 控制层公共方法提取</span><br><span class="line">    │   │               ├── exception	-- 异常类</span><br><span class="line">    │   │               ├── handler		-- 处理器类</span><br><span class="line">    │   │               ├── properties	-- 框架配置参数</span><br><span class="line">    │   │               └── utils		-- 工具类</span><br><span class="line">    │   └── resources</span><br><span class="line">    │       ├── application-dev.yml		-- 开发环境配置</span><br><span class="line">    │       ├── application-prod.yml	-- 生产环境配置</span><br><span class="line">    │       ├── application.yml			-- 项目基础配置</span><br><span class="line">    │       ├── mapper					-- Mybatis接口映射XML文件</span><br><span class="line">    │       └── tycoding.properties		-- 项目自定义参数配置</span><br></pre></td></tr></table></figure>

<h3 id="wechat-app"><a href="#wechat-app" class="headerlink" title="wechat-app"></a>wechat-app</h3><p>源码：<a href="https://github.com/TyCoding/wechat-template/tree/master/wechat-app" target="_blank" rel="noopener">https://github.com/TyCoding/wechat-template/tree/master/wechat-app</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── App.vue			-- 小程序入口（Vue）</span><br><span class="line">├── api				-- 项目接口方法（对URL、Params的统一封装，仅需调用其下的方法便可发送请求）</span><br><span class="line">│   └── user.js		-- 用户层接口（建议命名和后端Controller对应）</span><br><span class="line">├── common			-- 通用文件</span><br><span class="line">├── components		-- 组件，HBuilderX新版支持easycom模式：无需手动引入组件仅需按照目录格式</span><br><span class="line">├── config.js		-- 项目配置（包含了项目生产环境和开发环境BaseURL配置）</span><br><span class="line">├── main.js			-- 项目入口</span><br><span class="line">├── manifest.json	-- 应用配置</span><br><span class="line">├── pages			-- 页面（vue组件）</span><br><span class="line">│   ├── common		-- 通用层页面</span><br><span class="line">│   └── tabbar		-- 小程序底部tarbar对应页面</span><br><span class="line">├── pages.json		-- 页面属性配置、编译配置</span><br><span class="line">├── permission.js	-- 路由守卫，页面Router将被路由守卫拦截处理（判断token是否失效等）</span><br><span class="line">├── router			-- 页面路由相关配置，页面的路由path需要和pages.json相对应</span><br><span class="line">│   └── index.js</span><br><span class="line">├── static			-- 静态文件</span><br><span class="line">├── store			-- vuex相关store缓存配置</span><br><span class="line">│   ├── getters.js	-- 定义getters，用于获取store中的参数属性</span><br><span class="line">│   ├── index.js	-- Vuex声明、定义</span><br><span class="line">│   └── modules		-- 具体需要缓存的数据对象</span><br><span class="line">└── utils			-- 工具类</span><br><span class="line">    ├── auth.js		-- 管理Token</span><br><span class="line">    ├── request.js	-- 全局请求封装</span><br><span class="line">    └── util.js		-- 一些方法的封装</span><br></pre></td></tr></table></figure>

<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>项目文档将在公众号：<strong>程序员涂陌</strong> 中陆续发布。首先作为后端程序员我们要先阅读微信小程序相关文档：</p>
<ul>
<li>微信小程序官方文档：<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/" target="_blank" rel="noopener">https://developers.weixin.qq.com/miniprogram/dev/framework/</a></li>
<li>uni-app官方文档：<a href="https://uniapp.dcloud.io/README" target="_blank" rel="noopener">https://uniapp.dcloud.io/README</a></li>
<li>Vue.js官方文档：<a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/</a></li>
<li>ThorUI官方文档：<a href="https://www.thorui.cn/doc/guide.html" target="_blank" rel="noopener">https://www.thorui.cn/doc/guide.html</a></li>
<li>lunc-request官方文档：<a href="https://quanzhan.co/luch-request/guide/3.x/" target="_blank" rel="noopener">https://quanzhan.co/luch-request/guide/3.x/</a></li>
<li>uni-simple-router官方文档：<a href="http://hhyang.cn/src/router/start/quickstart.html" target="_blank" rel="noopener">http://hhyang.cn/src/router/start/quickstart.html</a></li>
</ul>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>由于本人是做后端的，所以本小程序中服务端接口全部由<code>wechat-api</code>项目提供，请各位开发者把重点放在学习该项目是如何封装的、以及数据是如何交互的，这是核心。Uni-app最大的优势就是基于Vue实现，熟悉了Vue则对用Uni-app开发小程序也会很快熟悉；需要提各位，Uni-app框架与HBuilder软件是捆绑的，HBuilder的版本号即是Uni-app框架的版本号，而只能通过HBuilder编译uni-app项目，最后微信开发者工具上预览小程序界面。</p>
<p>以上是对  <a href="https://github.com/TyCoding/wechat-template" target="_blank" rel="noopener">https://github.com/TyCoding/wechat-template</a> 项目的介绍，后续公众号会陆续发布该项目各个功能模块的实现逻辑，请大家持续关注~~</p>
<br>




<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Markdown写作</title>
    <url>/2020/06/10/other/markdown/</url>
    <content><![CDATA[<h1 id="Markdown-写作"><a href="#Markdown-写作" class="headerlink" title="Markdown  写作"></a>Markdown  写作</h1><p><strong>工欲善其事必先利其器</strong></p>
<p>习惯了写文章来记录自己的日常，<strong>Markdown</strong> 必是首选。而如何优雅的写作呢？今天带大家配置一个优雅的Markdown写作环境。</p>
<a id="more"></a>

<h2 id="软件选择"><a href="#软件选择" class="headerlink" title="软件选择"></a>软件选择</h2><ul>
<li><strong><a href="https://www.typora.io/" target="_blank" rel="noopener">Typora</a></strong>: 一款免费跨平台的Markdown写作软件</li>
<li><strong><a href="https://github.com/Molunerfinn/PicGo/releases/" target="_blank" rel="noopener">PicGo</a></strong>: 一款免费开源跨平台的图床工具</li>
</ul>
<p>Markdown写作软件有很多种，当然每个软件都有各自的优缺点，但我个人更喜欢<strong>Typora</strong>的风格：所写即所见。而Typora新版本本身就支持PicGo图床工具，配置好图床工具，写作时粘贴的图片将自动上传到云端。</p>
<h2 id="图床选择"><a href="#图床选择" class="headerlink" title="图床选择"></a>图床选择</h2><p>PicGo仅是一个图床工具，而我们需要给这个图床工具配置云端服务器。</p>
<p>网上有很多免费的图床网站，直接将图片上传到网站便能得到云端链接。而图片并未上传到我们自己的服务器，既没法方便的管理也不能保证图片会不会有丢失，因此我们需要选择一款自己的图床服务器。</p>
<p>除了自己购买云端服务器，我们亦可以选择网上免费的图床服务器，例如：七牛云、Gitee、GitHub等等。Github苦于网速限制就直接放弃吧；Gitee是个不错的选择但应用内访问图片的链接可能会出现403 Forbidden的情况，所以我还是推荐使用七牛云。下面介绍Gitee和七牛云的图床环境搭建。</p>
<h3 id="Gitee"><a href="#Gitee" class="headerlink" title="Gitee"></a>Gitee</h3><p>在 <strong><a href="https://gitee.com/" target="_blank" rel="noopener">https://gitee.com/</a></strong> 官网申请注册账号，注册完毕后新建一个空仓库：</p>
<p><img src="http://cdn.tycoding.cn/20200609214948.png" alt="image-20200609214948247"></p>
<p>注意仓库必须是公开不能是私有的，仓库的分支就选择默认的master分支即可。最后我们的图片将通过图床工具自动上传到这个仓库，图片访问的外链就是Gitee仓库内图片的URL地址，后续我们将介绍如何在PicGo中配置这个图床。</p>
<p><strong>说明：</strong> Gitee的图片配置是很简单的，如果是用来作为文章图片的存储是适合的。但作为开发者，如果我们想要在APP项目内访问Gitee仓库中存储的图片就会出现403Forbidden的情况，原因是请求URL时需要携带Token参数信息，显然这并不适合在项目中作为外链使用。</p>
<p>例如：<a href="https://gitee.com/tytumo/pictures/raw/master/img/20200609105634.png" target="_blank" rel="noopener">https://gitee.com/tytumo/pictures/raw/master/img/20200609105634.png</a> 在浏览器上是可直接访问的，而在应用内请求（比如在<code>&lt;image src=&#39;&#39;&gt;</code>中使用）：</p>
<p><img src="http://cdn.tycoding.cn/20200609221624.png" alt="image-20200609221624887"></p>
<h3 id="七牛云"><a href="#七牛云" class="headerlink" title="七牛云"></a>七牛云</h3><p><strong>注意：</strong> 七牛云是一款可以免费使用的云端服务器，但这仅仅是一个服务器，七牛云并不提供域名（新创建的对象储存会提供一个免费的域名，但有期限），因此我们首先需要自己购买一个域名。</p>
<p>在 <strong><a href="https://www.qiniu.com/" target="_blank" rel="noopener">https://www.qiniu.com/</a></strong> 七牛云官方网站注册一个账号，创建完成后进入 <a href="https://portal.qiniu.com/create" target="_blank" rel="noopener">管理控制台</a> ：</p>
<p><img src="http://cdn.tycoding.cn/20200609220131.png" alt="image-20200609220131710"></p>
<p>在云产品那一栏找到对象储存，并点击立即添加：</p>
<p><img src="http://cdn.tycoding.cn/20200609220625.png" alt="image-20200609220625251">、</p>
<p>同样，储存空间必须是公开的而不是私有的。这样就完成了储存空间的创建，实际上也就类似于一个服务器，最后图片将上传到这个存储空间内，通过外链即可访问。</p>
<h2 id="PicGo"><a href="#PicGo" class="headerlink" title="PicGo"></a>PicGo</h2><p>上面准备好了图床，接下来需要在PicGo中配置使用图床。开始配置之前，先修改PicGo的默认配置：</p>
<p><img src="http://cdn.tycoding.cn/20200609222336.png" alt="image-20200609222336679"></p>
<p>开启时间戳命名后上传的图片名称自动修改为当前的时间戳；开启上床后自动复制URL后上传了图片将自动复制图片的外链地址。下面分别介绍GItee图床和七牛云图床的配置：</p>
<h3 id="Gitee-1"><a href="#Gitee-1" class="headerlink" title="Gitee"></a>Gitee</h3><p><img src="http://cdn.tycoding.cn/20200609222943.png" alt="image-20200609222943390"></p>
<ol>
<li><strong>owner</strong>: 空间地址，从个人Gitee的URL地址中可以看到</li>
<li><strong>repo</strong>: 仓库名称，就是我们刚创建的图床仓库</li>
<li><strong>path</strong>: 存储路径，相对于本仓库。比如设置为img，那么将上传到<code>img/</code>文件夹下</li>
<li><strong>token</strong>: 私人令牌，在gitee个人中心 <strong>私人令牌</strong> 页面中可以创建一个新的令牌，将Token指复制到这里</li>
<li><strong>message</strong>: 类似于<code>git commit -m &#39;&#39;</code> </li>
</ol>
<h3 id="七牛云-1"><a href="#七牛云-1" class="headerlink" title="七牛云"></a>七牛云</h3><p><img src="http://cdn.tycoding.cn/20200609222736.png" alt="image-20200609222736448"></p>
<ol>
<li>AccessKey和SecretKet 在Gitee设置中心页面可以找到</li>
<li>存储空间名也就是刚才新创建存储空间的名称</li>
<li>访问网址也就是该储存空间的外链访问地址，如果是自定义的外链就填写自定义的域名地址</li>
</ol>
<h2 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h2><p>在Typora设置中找到图像配置：</p>
<p><img src="http://cdn.tycoding.cn/20200609223944.png" alt="image-20200609223944860"></p>
<p><strong>上传服务设定</strong> 选择本地的PicGo工具，然后可以点击<strong>验证图片上传选项</strong> 按钮，如果连接正常将出现以下页面：</p>
<p><img src="http://cdn.tycoding.cn/20200609224243.png" alt="image-20200609224243115"></p>
<p>到此为止，整个配置就算完成了，接下来我们可以尝试在Typora内新创建Markdown文档，截取一张图片直接复制到这个文档中，会发现图片URL从本地的localhost自动转变为远程域名地址，并且PicGo会提示图片上传成功：</p>
<p><img src="http://cdn.tycoding.cn/20200609224659.png" alt="image-20200609224659354"></p>
<p><strong>附：</strong></p>
<ol>
<li>微信公众号Markdown文章排版工具：<a href="https://mdnice.com/" target="_blank" rel="noopener">https://mdnice.com/</a></li>
<li><a href="https://tycoding.cn/" target="_blank" rel="noopener">https://tycoding.cn/</a> 博客建站使用技术：<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">https://hexo.io/zh-cn/</a></li>
<li><a href="https://tycoding.cn/" target="_blank" rel="noopener">https://tycoding.cn/</a> 博客使用的Hexo主题：<a href="https://github.com/TyCoding/tumo-next" target="_blank" rel="noopener">https://github.com/TyCoding/tumo-next</a></li>
</ol>
<br>




<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <categories>
        <category>other</category>
      </categories>
  </entry>
  <entry>
    <title>Java基础知识点回顾</title>
    <url>/2019/06/24/ready/javase/</url>
    <content><![CDATA[<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="JDK和JRE区别？"><a href="#JDK和JRE区别？" class="headerlink" title="JDK和JRE区别？"></a>JDK和JRE区别？</h2><ol>
<li><code>jre</code>即Java Runtime Environment，Java运行环境。包括Java虚拟机和Java类库</li>
<li><code>jdk</code>是Java开发<strong>工具包</strong>，例如：<code>tools.jar</code></li>
</ol>
<h2 id="和-equals-区别"><a href="#和-equals-区别" class="headerlink" title="== 和 equals 区别"></a>== 和 equals 区别</h2><ol>
<li><p><code>==</code>是一个比较运算符，对于基本类型，比较的是具体的数值(int、double..)；对于引用类型，比较的是对象的内存地址</p>
</li>
<li><p><code>equals</code>是超类<code>Object</code>就具有的方法，因此所有的引用类型都具有这个方法，只用用来比较引用数据类型。<code>equals</code>方法默认比较的对象内存地址，如果重写该方法，一般比较的是对象的属性值。</p>
<a id="more"></a>

<p><code>Object</code>类<code>equals</code>方法源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>new</code>对象是在堆内存中开辟一份空间，所以其引用变量就是指向了堆内存的地址，栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EqualsTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User a = <span class="keyword">new</span> User();</span><br><span class="line">        User b = <span class="keyword">new</span> User();</span><br><span class="line">        System.out.println(a == b); <span class="comment">//false</span></span><br><span class="line">        System.out.println(a.equals(b)); <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> User)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        User user = (User) o;</span><br><span class="line">        <span class="keyword">return</span> age == user.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="两个对象的hashCode-相同，则equals-一定为true？"><a href="#两个对象的hashCode-相同，则equals-一定为true？" class="headerlink" title="两个对象的hashCode()相同，则equals()一定为true？"></a>两个对象的hashCode()相同，则equals()一定为true？</h2><ul>
<li>如果两个对象相等(<code>equals()</code>为true)，那么他们的<code>hashCode()</code>一定相同</li>
<li>如果两个对象的<code>hashCode()</code>相同，他们的<code>equals()</code>方法不一定相同</li>
</ul>
<p>JVM虚拟机通过<code>hashCode()</code>方法为Object对象分配一个int类型数值，以此来提高Java中集合对象(Map、HashMap…)中对象存储的效率。当集合中需要添加新元素，首先通过<code>hashCode()</code>获取该对象对应的地址位置，如果该位置上没有值就直接储存到该位置，如果有值就再调用<code>equals()</code>与新元素的值比较，相同就不再储存否则就散列到其他位置，大大减少了调用<code>equals()</code>方法比较的次数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EqualsTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User a = <span class="keyword">new</span> User();</span><br><span class="line">        User b = <span class="keyword">new</span> User();</span><br><span class="line">        System.out.println(a == b); <span class="comment">//false</span></span><br><span class="line">        System.out.println(a.equals(b)); <span class="comment">//false</span></span><br><span class="line">        System.out.println(a.hashCode() == b.hashCode()); <span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="final-的作用"><a href="#final-的作用" class="headerlink" title="final 的作用"></a>final 的作用</h2><p>可修饰类、类属性、类方法。</p>
<ol>
<li><p>被<code>final</code>修饰的类不能被继承</p>
</li>
<li><p><code>final</code>修饰的类属性可以是基本类型也可以是引用类型，如果是基本类型就不能再被赋值；如果是引用类型，就不能再指向其他引用地址，但对象本身是可以改变的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> User USER = <span class="keyword">new</span> User();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User u2 = <span class="keyword">new</span> User();</span><br><span class="line"><span class="comment">//        user = u2; // ERROR</span></span><br><span class="line">        USER.age = <span class="number">23</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">12</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>类中所有<code>private</code>方法都是隐式的定义为final，为private方法添加final就毫无意义。</p>
</li>
</ol>
<h2 id="String属于基本数据类型吗？"><a href="#String属于基本数据类型吗？" class="headerlink" title="String属于基本数据类型吗？"></a>String属于基本数据类型吗？</h2><p><strong>不，String属于特殊的引用类型</strong></p>
<p>Java中基本数据类型有：int、short、long、char、boolean、float、double、byte</p>
<ol>
<li><code>String</code>是特殊的引用类型并且是<code>final</code>的，JVM使用字符串常量池储存字符串数据。创建新的字符串，JVM首先会去字符串常量池中寻找有没有该字符串，如果没有就添加到该常量池，如果有就返回该字符串在常量池中的引用。</li>
<li><code>String s = &quot;a&quot;; s += &quot;b&quot;;</code>，这段代码执行前后，字符串常量池中将出现<code>a</code>和<code>ab</code>两个字符串常量，而原本<code>s</code>变量的引用指向了常量池中<code>ab</code>。</li>
<li><code>String s = new String(&quot;ab&quot;)</code>，这段代码一共创建了几个对象？<strong>一个或两个</strong>。如果字符串常量池中有了<code>ab</code>这个字符串(比如在此之前已经使用了<code>String str = &quot;ab&quot;</code>)，那么新的<code>s</code>对象引用其实仅仅是指向了字符串常量中的<code>ab</code>，并没有创建新的字符串对象。<strong>但是</strong>，每次调用<code>new</code>都会在堆内存开辟空间，创建一个String对象，这是肯定的。</li>
</ol>
<p>栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="string">"abc"</span>;</span><br><span class="line">        String b = <span class="string">"abc"</span>;</span><br><span class="line">        String c = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">        System.out.println(a == b); <span class="comment">//true</span></span><br><span class="line">        System.out.println(a.equals(b)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(a.equals(c)); <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="String和StringBuffer和StringBuilder的区别"><a href="#String和StringBuffer和StringBuilder的区别" class="headerlink" title="String和StringBuffer和StringBuilder的区别"></a>String和StringBuffer和StringBuilder的区别</h3><ol>
<li><code>String</code>是不可变字符串，<code>StringBuffer</code>和<code>StringBuilder</code>是可变字符串。如果经常改变字符串的原始数据，最好使用<code>StringBuffer</code>代替。</li>
<li><code>String</code>默认重写了<code>equals</code>方法和<code>hashCode()</code>方法；而<code>StringBuffer</code>没有重写<code>equals</code>方法，使用<code>new StringBuffer(&quot;&quot;)</code>会直接在堆内存中开辟空间储存对象。因此将<code>StringBuffer</code>对象储存仅Java集合中可能会出现问题。</li>
<li><code>StringBuffer</code>是线程安全的，效率低；<code>StringBuilder</code>是线程不安全的，效率高。</li>
</ol>
<h2 id="static关键字？是否可覆盖？"><a href="#static关键字？是否可覆盖？" class="headerlink" title="static关键字？是否可覆盖？"></a>static关键字？是否可覆盖？</h2><p><code>static</code>关键字表明一个成员变量或者是成员方法可以在没有所属的类实例变量的情况下被访问。被<code>static</code>标记的方法不能被覆盖，因为方法的覆盖是基于运行时动态绑定的，而<code>static</code>方法在编译时就已经和该类绑定了，也就是<code>static</code>标记的变量、方法都是随着类的加载而加载的，所以可以通过不创建对象实例就能访问该变量、方法；而不创建对象实例就访问非<code>static</code>变量、方法是不行的，因为此变量、方法还没有被创建。</p>
<ul>
<li><code>static</code>标记的方法只能访问<code>static</code>变量或方法</li>
<li>非<code>static</code>标记的方法可以访问<code>static</code>或非<code>static</code>标记的变量或方法</li>
</ul>
<h2 id="自动拆、装箱"><a href="#自动拆、装箱" class="headerlink" title="自动拆、装箱"></a>自动拆、装箱</h2><p>因为Java自身面向对象OOP的特性，而一切基本数据类型都不具有面向对象的特性，所以Java为基本的数据类型提供了对应的引用类型。</p>
<p>具体表现在程序在编译期间自动将基本数据类型转换为引用类型(装箱)、将引用数据类型转换为基本数据类型(拆箱)</p>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>引用数据类型</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>char</td>
<td>Char</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody></table>
<p>栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer i1 = <span class="number">100</span>;</span><br><span class="line">    Integer i2 = <span class="number">100</span>;</span><br><span class="line">    Integer i3 = <span class="number">200</span>;</span><br><span class="line">    Integer i4 = <span class="number">200</span>;</span><br><span class="line">    System.out.println(i1 == i2);</span><br><span class="line">    System.out.println(i3 == i4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure>

<p>Java中实现基本数据类型和引用类型之间的拆装箱一般都是用过<code>valueOf()</code>方法实现的。例如我们看下<code>Integer</code>类的<code>valueOf()</code>方法源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到：当声明一个新的整数型变量，编译时通过<code>Integer</code>类的<code>valueOf()</code>进行拆装箱计算，这个方法会首先比较这个整数值是否在<code>IntegerCache</code>的范围内，如果在就返回<code>IntegerCache</code>类中的数值；如果不在就直接<code>new Integer</code>。那么我们看下<code>IntegerCache</code>类源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，当声明一个新的整型变量时（int、Integer），如果这个变量值的大小在<code>[-128, 127]</code>之间，就直接返回<code>IntegerCache</code>中储存的常量值，否则就直接<code>new</code>一个新的<code>Integer</code>来保存这个常量值。所以上面才会出现<code>false</code>的结果。</p>
<p><strong>同理</strong>：其他的数据类型例如：<code>long</code>、<code>short</code>等都具有对应的<code>LongCache</code>、<code>ShortCache</code>等类。</p>
<h2 id="Overriding和Overloaded"><a href="#Overriding和Overloaded" class="headerlink" title="Overriding和Overloaded"></a>Overriding和Overloaded</h2><p>方法的重写Overriding和方法的重载Overloaded都是Java多态性的一种表现。</p>
<ul>
<li><code>Overriding</code>: 子类中定义了和父类中名称、参数列表相同的方法</li>
<li><code>Overloaded</code>: 方法名相同，参数列表不同</li>
</ul>
<h2 id="Java支持多继承吗？"><a href="#Java支持多继承吗？" class="headerlink" title="Java支持多继承吗？"></a>Java支持多继承吗？</h2><p>不支持。Java中每个类都只能继承一个类，可以实现多个接口。但是可以通过<strong>多层</strong>继承实现。</p>
<p>类定义属性和方法，描述某一类事物的抽象。而接口定义了行为，并不限于任何具体意向。</p>
<p>从逻辑上说，单继承更加明确指出一个子类就应该是其父类代表的事物中某个更具体的类别。而接口则不同，接口定义了一些公共行为。因此类对接口的implements称为实现而不能称为继承。</p>
<h2 id="接口和抽象类的区别？"><a href="#接口和抽象类的区别？" class="headerlink" title="接口和抽象类的区别？"></a>接口和抽象类的区别？</h2><ul>
<li>接口中所有的方法隐含都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。</li>
<li>接口中定义的方法必须是不包含具体实现的（即隐式的抽象方法）；但抽象类中既可以定义抽象方法（不包含具体实现）又可以定义非抽象方法 ( 包含具体实现 )</li>
<li>类实现接口就必须实现接口中定义的所有方法；但继承一个抽象类，可以不实现抽象类中的抽象方法 ( 但前提是这个类也是抽象的 )</li>
<li>抽象类可以是不提供接口方法实现的情况下实现接口</li>
<li>接口中声明的变量默认都是final的；但抽象类可以包含非final的变量</li>
<li>接口中的成员方法默认都是public的；但抽象类中的成员函数可以是private、protected、public</li>
<li>接口是绝对抽象的，不可以被实例化；</li>
</ul>
<h2 id="引用传递和值传递"><a href="#引用传递和值传递" class="headerlink" title="引用传递和值传递"></a>引用传递和值传递</h2><p><strong>Java中采用值传递的方式</strong></p>
<p>栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        Integer b = <span class="number">2</span>;</span><br><span class="line">        swap(a, b);</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        System.out.println(b);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        swap(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, Integer b)</span> </span>&#123;</span><br><span class="line">        a = <span class="number">10</span>;</span><br><span class="line">        b = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法传递时传递的参数其实仅值原参数的一个拷贝，对于基本类型传递的就是具体的值的拷贝，对于引用类型传递的是对象地址。</p>
<p>所以上面的例子中，基本数据类型a,b经过swap方法并没有改变原始值，而引用类型arr数组经过swap方法就改变了原始值（因为直接对对象堆内存地址数据操作）。</p>
<h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><p><img src="http://cdn.tycoding.cn/20180127210359151.png" alt></p>
<h3 id="Java中有几种类型的流？"><a href="#Java中有几种类型的流？" class="headerlink" title="Java中有几种类型的流？"></a>Java中有几种类型的流？</h3><p>字符流和字节流。字节流继承<code>InputStream</code>和<code>OutputStream</code>；字符流继承自<code>InputStreamReader</code>和<code>OutputStreamWriter</code>。</p>
<h3 id="谈谈Java-IO中的方法阻塞"><a href="#谈谈Java-IO中的方法阻塞" class="headerlink" title="谈谈Java IO中的方法阻塞"></a>谈谈Java IO中的方法阻塞</h3><p>Java中的阻塞式方法是指在程序调用该方法时，必须等待输入数据可用或检测到输入结果时结束或抛出异常，否则程序会一直停留在该语句上，不会执行下面的语句。比如<code>read()</code>和<code>readLine()</code>方法。</p>
<h3 id="字符流和字节流的区别？"><a href="#字符流和字节流的区别？" class="headerlink" title="字符流和字节流的区别？"></a>字符流和字节流的区别？</h3><p>数据的输入和输出在计算机中最终都是通过字节的形式传递的，对应通过<code>InputStream</code>和<code>OutputStream</code>实现，他们都是针对字节操作的。</p>
<p>而有时候通常需要读取一些完全是字符的文本数据，通常使用基于字节流的包装类字符流完成操作，他们通过<code>InputStreamReader</code>和<code>OutputStreamWriter</code>实现。</p>
<p>字符流是字节流的包装，即使有时候读取的是字符流，但也可能需要转换为字节写入。</p>
<h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p>传统的IO是阻塞式的，会一直监听一个ServerSocket，在调用read等方法时，会一直等到数据到来或缓冲区已满时才返回；调用accept时也会一直阻塞到有客户端连接时才继续执行；每个客户端连接成功后，服务端都会踢动一个县城去处理该客户端的请求；在多线程处理多个连接时，每个线程都拥有自己的栈空间并且占用了一些CPU时间，每个线程遇到外部未准备好时，都会发生阻塞。阻塞的结果就是会打来大量的进程上下文切换。</p>
<p>而对于NIO，它是非阻塞式，核心类：</p>
<ul>
<li>Buffer： 为所有的原始类型提供Buffer缓冲支持</li>
<li>Charset： 字符集编码解码解决方案</li>
<li>Channel： 一个新的原始IO抽象，用于读取Buffer类型，通道可以认为是一种链接，可以是到特定设备、程序或是网络链接、</li>
</ul>
<h2 id="说说List、Set、Map三者的区别"><a href="#说说List、Set、Map三者的区别" class="headerlink" title="说说List、Set、Map三者的区别"></a>说说List、Set、Map三者的区别</h2><ul>
<li>List:  List接口储存一组不唯一 (可以有多个元素引用引用相同的对象)，有序的对象，可插入多条null元素</li>
<li>Set:  不允许重复的集合，不允许有多个元素引用相同的对象，只允许有一个null元素</li>
<li>Map:  使用键值对储存，Map会维护与Key有关联的值，两个Key可以引用相同的对象，但Key不能重复。 </li>
</ul>
<h2 id="Array和ArrayList有什么区别？"><a href="#Array和ArrayList有什么区别？" class="headerlink" title="Array和ArrayList有什么区别？"></a>Array和ArrayList有什么区别？</h2><ul>
<li><code>Array</code>可以包含基本类型和对象类型；<code>ArrayList</code>只能包含对象类型</li>
<li><code>Array</code>大小是固定的；<code>ArrayList</code>大小是动态变化的</li>
<li><code>ArrayList</code>提供了诸如<code>addAll()</code>、<code>removeAll()</code>、<code>iterator()</code>方法等</li>
<li>对于基本数据类型，集合使用自动装箱来减少代码量；但当处理固定大小的基本类型数据时，这种方式相对较慢。</li>
</ul>
<h2 id="ArrayList和LinkedList的区别？"><a href="#ArrayList和LinkedList的区别？" class="headerlink" title="ArrayList和LinkedList的区别？"></a>ArrayList和LinkedList的区别？</h2><ol>
<li><strong>是否保证线程安全</strong>：  <code>ArrayList</code>和<code>LinkedList</code>都是不同步的，也就是不保证线程安全</li>
<li><strong>底层数据结构</strong>： <code>ArrayList</code>底层使用的是<code>Object</code>数组；<code>LinkedList</code>底层使用的是 <strong>双向链表</strong> 结构</li>
<li><strong>插入和删除是否受元素位置影响？</strong>  <code>ArrayList</code>采用数组储存，所以插入和删除元素都受元素位置的影响；<code>LinkedList</code> 采用链表储存，所以插入、删除元素都不受元素位置影响。</li>
<li><strong>是否支持快速随机访问？</strong>  <code>LinkedList</code>因为使用链表储存，无法通过元素索引快速访问；而<code>ArrayList</code>因为底层采用Object数组储存，可以通过索引快速随机访问。</li>
<li><strong>内存空间占用</strong>：  <code>ArrayList</code>的空间浪费主要体现在在List列表的结尾都会预留一定的空间容量，而<code>LinkedList</code>的空间花费体现在他的每一个元素都需要消耗比<code>ArrayList</code>更多的空间（因为要储存直接后继和直接前驱以及数据）。</li>
</ol>
<h3 id="什么是迭代器"><a href="#什么是迭代器" class="headerlink" title="什么是迭代器"></a>什么是迭代器</h3><p><code>Iterator</code>接口中提供了很多对集合元素迭代的方法。每个集合中都有可以返回迭代器对象的方法<code>iterator()</code>。迭代器在迭代的过程中可以删除底层集合的元素。</p>
<h3 id="Iterator和ListIterator的区别？"><a href="#Iterator和ListIterator的区别？" class="headerlink" title="Iterator和ListIterator的区别？"></a>Iterator和ListIterator的区别？</h3><ul>
<li><code>Iterator</code>可以用来遍历Set和List集合，但是<code>ListIterator</code>只能遍历List</li>
<li><code>Iterator</code>对集合只能向前遍历（<code>next()</code>）；而<code>ListIterator</code>可以向前遍历（<code>next()</code>），也可以向后遍历（<code>previous()</code>）</li>
<li><code>ListIterator</code>实现了<code>Iterator</code>接口</li>
</ul>
<h3 id="RandomAccess接口"><a href="#RandomAccess接口" class="headerlink" title="RandomAccess接口"></a>RandomAccess接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ArrayList</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RandomAccess</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RandomAccess</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//LinkedList</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>源码中<code>ArrayList</code>类实现了<code>RandomAccess</code>接口，<code>LinkedList</code>类中却没有实现这个接口，但是<code>RandomAccess</code>接口中却什么也没有定义。可以看<code>RandomAccess</code>接口上的注释：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Marker interface used by &lt;tt&gt;List&lt;/tt&gt; implementations to indicate that</span></span><br><span class="line"><span class="comment"> * they support fast (generally constant time) random access.  The primary</span></span><br><span class="line"><span class="comment"> * purpose of this interface is to allow generic algorithms to alter their</span></span><br><span class="line"><span class="comment"> * behavior to provide good performance when applied to either random or</span></span><br><span class="line"><span class="comment"> * sequential access lists.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>大概就是说这个接口仅是一个标识Marker，实现了这个接口的List将支持快速随机访问（random access）。接下来，我们查看<code>Collections</code>类中的<code>binarySearch</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List&lt;? extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; list, T key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)</span><br><span class="line">        <span class="keyword">return</span> Collections.indexedBinarySearch(list, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> Collections.iteratorBinarySearch(list, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexedBinarySearch</span><span class="params">(List&lt;? extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; list, T key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = list.size()-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        Comparable&lt;? <span class="keyword">super</span> T&gt; midVal = list.get(mid);</span><br><span class="line">        <span class="keyword">int</span> cmp = midVal.compareTo(key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mid; <span class="comment">// key found</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -(low + <span class="number">1</span>);  <span class="comment">// key not found</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">iteratorBinarySearch</span><span class="params">(List&lt;? extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; list, T key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = list.size()-<span class="number">1</span>;</span><br><span class="line">    ListIterator&lt;? extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; i = list.listIterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        Comparable&lt;? <span class="keyword">super</span> T&gt; midVal = get(i, mid);</span><br><span class="line">        <span class="keyword">int</span> cmp = midVal.compareTo(key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mid; <span class="comment">// key found</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -(low + <span class="number">1</span>);  <span class="comment">// key not found</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>binarySearch()</code>方法是从List中查找指定元素，其中首先判断传入的List时候实现了<code>RandomAccess</code>接口，如果实现了就调用<code>indexedBinarySearch()</code>方法，否则就调用<code>iteratorBinarySearch()</code>方法。再看这两个方法的源码：</p>
<ul>
<li>如果传入的List实现了<code>RandomAccess</code>接口，采用普通for循环遍历</li>
<li>若传入的List未实现<code>RandomAccess</code>接口，采用<code>iterator</code>遍历</li>
</ul>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p><strong>链表（Linked List）</strong>由一串节点组成，每个节点包含任意的实例数据和一或两个用来指向上一个/下一个节点位置的指针</p>
<blockquote>
<p>   单向链表</p>
</blockquote>
<p>单向链表包含每个节点Node包含两个部分：第一部分data储存当前节点数据、第二部分next存储下一节点的地址。</p>
<ul>
<li>单向链表只可向一个方向遍历，查找一个节点需要从第一个节点开始向下依次寻找</li>
</ul>
<p><img src="http://cdn.tycoding.cn/1120165-20171207161602113-1451349858.png" alt></p>
<ul>
<li>单向链表插入节点从链表头部插入，将新插入节点的next指向原头部节点位置即可</li>
</ul>
<p><img src="http://cdn.tycoding.cn/1120165-20171207162758425-142549066.png" alt></p>
<ul>
<li>删除节点，只需要将该节点上一个节点的next指向该节点下一个节点即可</li>
</ul>
<p><img src="http://cdn.tycoding.cn/1120165-20171207162815925-341262498.png" alt></p>
<blockquote>
<p>  双向链表</p>
</blockquote>
<p><strong>双向链表</strong> 包含两个指针，<code>prev</code>指向前一个节点，<code>next</code>指向后一个节点。</p>
<p><img src="http://cdn.tycoding.cn/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png" alt></p>
<blockquote>
<p>  双向循环链表</p>
</blockquote>
<p><strong>双向循环链表</strong> 最后一个节点的<code>next</code>指向<code>head</code>，而<code>head</code>的<code>prev</code>指向最后一个节点，形成一个环。</p>
<p><img src="http://cdn.tycoding.cn/%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.png" alt></p>
<h2 id="ArrayList和Vector和LinkedList的区别？"><a href="#ArrayList和Vector和LinkedList的区别？" class="headerlink" title="ArrayList和Vector和LinkedList的区别？"></a>ArrayList和Vector和LinkedList的区别？</h2><ul>
<li><strong>ArrayList</strong>:  底层数据结构是数组，查询快，增删慢。线程不安全，效率高</li>
<li><strong>Vector</strong>:  底层数据结构是数组，查询快，增删慢。线程安全，效率低</li>
<li><strong>LinkedList</strong>:  底层数据结构是链表，查询慢，增删快。线程不安全，效率高</li>
</ul>
<h2 id="谈谈ArrayList的扩容机制"><a href="#谈谈ArrayList的扩容机制" class="headerlink" title="谈谈ArrayList的扩容机制"></a>谈谈ArrayList的扩容机制</h2><p>Java中基本数组都是定长的，一旦被实例化后就不能改变其长度，意味着创建数组时必须确定数组的容量大小。而很多情况下，数组的长度不是确定的，需要动态增减，<code>ArrayList</code>的出现就解决了这一问题。</p>
<p><code>ArrayList</code>的扩容机制表现在<code>add()</code>方法上，先看<code>add()</code>方法的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取最小容量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否需要扩容</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当向<code>ArrayList</code>对象中添加新元素时，首先会调用<code>ensureCapacityInternal(size)</code>方法，<code>size</code>为最小扩容量；<code>ensureCapacityInternal()</code>方法会首先调用<code>calculateCapacity</code>来确定需要的最小容量；最后调用<code>ensureExplicitCapacity()</code>方法判断时候需要扩容。最后判断所需最小容量如果大于当前数组的空间大小，则需要扩容，调用<code>grow()</code>方法扩容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取ArrayList中elementDaata数组的长度</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// 扩容至原来的1.5倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 判断新的数组容量够不够</span></span><br><span class="line">    <span class="comment">// 够了就直接使用这个长度创建新数组</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 不够就将数组的长度设置为需要的长度</span></span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">// 检查此时的最大值是否溢出</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// 调用Arrays.copyOf()将elementData数组数据拷贝到新数组</span></span><br><span class="line">    <span class="comment">// 并将elementData指向新数组newCapacity的内存地址</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong>：  <code>ArrayList</code>扩容的本质就是计算所需扩容size得到新的数组，将原数组中的数据复制到新数组中，最后将原数组指向新数组在堆内存的引用地址即可。</p>
<h2 id="HashMap和HashTable的区别？"><a href="#HashMap和HashTable的区别？" class="headerlink" title="HashMap和HashTable的区别？"></a>HashMap和HashTable的区别？</h2><ol>
<li><code>HashMap</code>和<code>HashTable</code>都实现了<code>Map</code>接口，主要区别在线程安全性、同步、速度</li>
<li><strong>线程是否安全</strong>： <code>HashMap</code>非同步线程不安全，<code>HashTable</code>同步线程安全。<code>HashTable</code>内部的方法都经过<code>synchronized</code>修饰。</li>
<li><strong>效率</strong>:  <code>HashMap</code>线程不安全效率高，<code>HashTable</code>线程安全效率低。</li>
<li><strong>对null key和null value的支持</strong>： <code>HashMap</code>中，<code>null</code>可以作为key，这样的key只有一个，但可以有多个key对应的值为null；在<code>HashTable</code>中的key不能为null</li>
<li><strong>底层数据结构</strong>： JDK1.8后的<code>HashMap</code>在解决哈希冲突时有了较大的变化，当链表长度大于阀值时（默认是8），将链表转换为红黑树，以减少搜索时间。<code>HashTable</code>没有这样的机制。</li>
</ol>
<h2 id="HashMap和HashSet区别"><a href="#HashMap和HashSet区别" class="headerlink" title="HashMap和HashSet区别?"></a>HashMap和HashSet区别?</h2><p><code>HashSet</code>底层采用<code>HashMap</code>实现</p>
<table>
<thead>
<tr>
<th>HashMap</th>
<th>HashSet</th>
</tr>
</thead>
<tbody><tr>
<td>实现了Map接口</td>
<td>实现了Set接口</td>
</tr>
<tr>
<td>储存键值堆</td>
<td>仅储存对象</td>
</tr>
<tr>
<td>调用<code>put()</code>向Map中添加元素</td>
<td>调用<code>add()</code>向Set中添加元素</td>
</tr>
<tr>
<td><code>HashMap</code>使用<code>Key</code>计算<code>HashCode</code></td>
<td><code>HashSet</code>使用成员对象来计算<code>hashCode</code>值，对于两个对象来说，<code>hashCode</code>可能相同，所以用<code>equals</code>判断对象的相等性</td>
</tr>
</tbody></table>
<h2 id="HashSet如何检查重复？"><a href="#HashSet如何检查重复？" class="headerlink" title="HashSet如何检查重复？"></a>HashSet如何检查重复？</h2><p>在前面讲<code>hashCode</code>和<code>equals</code>时就提到了，<code>HashSet</code>集合同样适用。向<code>HashSet</code>中存入一个元素，<code>HashSet</code>首先会根据对象的<code>hashCode</code>值判断当期集合中此<code>hashCode</code>对应的位置有没有值，如果没有就直接添加，如果有就再调用<code>equals</code>方法比较两个对象是否相同，相同就不再储存（保证了<code>Set</code>集合不重复的特性），否则就散列到其他位置储存。</p>
<h2 id="HashMap底层实现？"><a href="#HashMap底层实现？" class="headerlink" title="HashMap底层实现？"></a>HashMap底层实现？</h2><p><code>Map</code>在Java中的实现由很多，<code>HashMap</code>便是其中之一，随着JDK版本的更新，<code>HashMap</code>的实现也在不断更新：</p>
<ul>
<li><strong>&lt;=JDK1.7</strong>:  Table数组 + Entry链表</li>
<li><strong>&gt;=JDK1.8</strong>:  Table数组 + Entry链表/红黑树</li>
</ul>
<p>参考：</p>
<ul>
<li><a href="http://study.ikuvn.com/#/docs/zh-cn/java/data-structure/hashmap" target="_blank" rel="noopener">HashMap</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/21673805" target="_blank" rel="noopener">Java 8系列之重新认识HashMap</a></li>
</ul>
<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p><strong>Hash（哈希、散列）</strong>，就是把任意长度的输入通过散列算法变换成固定长度的输出，该输出就是散列值。</p>
<p>Hash函数的一种实现：</p>
<ul>
<li><p><strong>直接取余法</strong>： <code>f(x) = x mod max</code></p>
</li>
<li><p><strong>位运算法</strong>： <code>f(x) = x &amp; max</code></p>
</li>
</ul>
<p><code>HashMap</code>采用 <strong>位运算法</strong>，相比直接取余，位运算直接对内存中的二进制数据操作，不需要再转阿欢为十进制，因此处理速度很快：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span> &amp; <span class="number">33</span> = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="number">000111</span></span><br><span class="line">  &amp; <span class="number">100001</span></span><br><span class="line">  --------</span><br><span class="line">    <span class="number">000001</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="Hash冲突"><a href="#Hash冲突" class="headerlink" title="Hash冲突"></a>Hash冲突</h3><p>假设将100个数据通过Hash散列后存储到10个不同的容器中，必定会出现多个元素分布到同一个容器中。具体到<code>HashMap</code>集合中，若将多个<code>K-V</code>数据存入<code>put</code>，<code>HashMap</code>根据元素<code>key</code>计算到对应的<code>hashCode</code>值，如果计算得到多个不同的<code>key</code>对应的<code>hashCode</code>值相同（即要储存到同一位置），此时这种现象就称为 <strong>Hash冲突</strong>。</p>
<p><code>HashMap</code>默认采用了 <strong>链地址法</strong> 解决Hash冲突问题，即通过类似单链表的方式将 <strong>冲突的元素</strong> 串起来，搜索时遍历这个链表即可。<strong>注意</strong>： 如果冲突的Hash越来越多，这个链就会越来越长。</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p><img src="http://cdn.tycoding.cn/8db4a3bdfb238da1a1c4431d2b6e075c_hd.png" alt></p>
<p>这里我们需要了解两个名词：</p>
<ul>
<li><strong>Table</strong>: 哈希桶数组（哈希表），存放Node元素，底层是一个<code>Node[] table</code></li>
<li><strong>Node</strong>: 节点元素，Node是HashMap的一个内部类，实现了<code>Map.Entry</code>接口，本质是一个映射（K-V）</li>
</ul>
<p><code>HashMap</code>内部的一些关键属性需要了解：</p>
<ul>
<li><code>DEFAULT_INITIAL_CAPACITY</code>: Tabale数组的初始化长度，默认是<code>1 &lt;&lt; 4</code>，<code>2^4 = 16</code></li>
<li><code>MAXIMUM_CAPACITY</code>: Table数组最高长度，默认为<code>1 &lt;&lt; 30</code>，<code>2^30 = 1073741824</code></li>
<li><code>DEFAULT_LOAD_FACTOR</code>: 负载因子，当总元素数 &gt; 数组长度 * 负载因子时，Table数组将扩容，默认是0.75</li>
<li><code>TREEIFY_THRESHOLD</code>: 树化阀值，当单个Table内Node数量超过该值，则将链表转换为红黑树，默认是8</li>
<li><code>UNTREEIFY_THRESHOLD</code>: 链化阀值，当扩容期间单个Table的Entry数量小于该值，则将红黑数转换为链表，默认为6</li>
<li><code>MIN_TREEIFY_CAPACITY</code>: 最小树化阀值，当Table中所有元素超过该值，才会进行树化</li>
<li><code>size</code>: 当前HashMap实际存在的键值对数量</li>
<li><code>threshold</code>: HashMap所能容纳的最大数据量的Node（键值对）个数。<code>Node[] table</code>初始化长度length是16，<code>loadFactor</code>负载因子默认是0.75，<code>threshold = length * loadFactor</code></li>
<li><code>loadFactor</code>: 负载因子，默认是0.17</li>
<li><code>modCount</code>: 记录HashMap内部结构发生变化的次数</li>
</ul>
<p><code>HashMap</code>内部存在一个<code>Node</code>Table数组，这个数组的初始化长度是<code>DEFAULT_INITIAL_CAPACITY</code>，他是一个单向链表：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash; <span class="comment">//key的Hash值</span></span><br><span class="line">    <span class="keyword">final</span> K key; <span class="comment">//key</span></span><br><span class="line">    V value; <span class="comment">//value</span></span><br><span class="line">    Node&lt;K,V&gt; next; <span class="comment">//下一个节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考单链表的结构，Table中每个<code>Node</code>节点包含两个部分，Node元素作为节点的<code>header</code>，<code>next</code>指向下一个节点。<strong>这种链式结构的存在正是为了解决Hash冲突</strong></p>
<blockquote>
<p>  <strong>Hash冲突</strong>： 两个元素经过Hash散列后被分到同一个组内（两个元素<code>hashCode</code>相同，<code>key</code>却不同），我们将其解释为Hash冲突。</p>
</blockquote>
<p>栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.put(<span class="string">"tycoding"</span>, <span class="string">"18"</span>);</span><br></pre></td></tr></table></figure>

<p><code>HashMap</code>将根据<code>&quot;tycoding&quot;</code>这个Key得到其<code>hashCode</code>值，然后经过Hash算法定位到其在<code>HashMap</code>储存的位置，如果两个不同的<code>key</code>定位到了同一个位置，此时就发生了Hash冲突。</p>
<p>在JDK1.7之前，解决Hash冲突的方式是将冲突的Node节点放在一个链表中。在JDK1.8中，当Table中链长超过<code>TREEIFY_THRESHOLD</code>阀值后，会将链表转换为红黑树的实现<code>TreeNode</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当发生<strong>Hash冲突</strong>时，根据HashMap默认采用的 <strong>链地址法</strong>，即将冲突的Hash串成一个链式结构储存到HashMap对应的位置。<strong>但是</strong> 随着Hash冲突越来越多，这个<strong>链将越来越长</strong>，这就将导致遍历碰撞key时的消耗不断增加，也就直接导致了性能的不足。在JDK1.8后，HashMap对单个Table中的Node超出某个阀值后，将开始树化操作（链表转换为红黑树），这对搜索的性能将会有很大的提升。</p>
<p><img src="http://cdn.tycoding.cn/JDK1.8%E4%B9%8B%E5%90%8E%E7%9A%84HashMap%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" alt></p>
<p><strong>总结</strong></p>
<p>到此，我们总结一下HashMap的实现原理：</p>
<ul>
<li><code>HashMap</code>根据key的<code>hashCode</code>值存储元素。<code>put</code>新元素会遍历链表，根据新元素的<code>key</code>计算<code>hashCode</code>得到散列位置，如果该位置有值再调用<code>equals</code>判断<code>value</code>是否相同，相同就散列到其他位置储存。</li>
<li><code>HashMap</code>在<code>put</code>新元素时如果遇到<code>key</code>对应的<code>hashCode</code>相同，可能会产生Hash冲突问题。<code>HashMap</code>的做法是采用链式结构（链表）储存存在Hash冲突的元素，查询时再遍历这个链接结构元素集合即可。</li>
<li>如果发生Hash冲突的元素很多，这个 <strong>链</strong> 将很长，影响到遍历key消耗性能的增加，于是判断当Table中Node节点大于默认值8时，将链表转换为红黑树（<code>TreeNode</code>）存储元素。</li>
</ul>
<h2 id="Collection和Collections的区别？"><a href="#Collection和Collections的区别？" class="headerlink" title="Collection和Collections的区别？"></a>Collection和Collections的区别？</h2><ul>
<li><code>Collection</code>是集合类的上级接口，继承他的接口主要有<code>Set</code>和<code>List</code></li>
<li><code>Collections</code>仅是针对集合类封装的一个工具类，在<code>java.util</code>包下</li>
</ul>
<h2 id="Comparable和Comparator的区别？"><a href="#Comparable和Comparator的区别？" class="headerlink" title="Comparable和Comparator的区别？"></a>Comparable和Comparator的区别？</h2><ul>
<li><code>Comparable</code>接口来自<code>java.lang</code>包，提供<code>compareTo(Object obj)</code> 方法排序</li>
<li><code>Comparator</code>接口来自<code>java.util</code>包，提供<code>compare(Object obj1, Object obj2)</code>方法排序</li>
</ul>
<p>当需要对一个集合采用一种方式排序，使用<code>Comparable</code>接口；如果需要对一个集合采用两种排序方式就使用<code>Comparator</code>接口。</p>
<h2 id="Java集合框架总结"><a href="#Java集合框架总结" class="headerlink" title="Java集合框架总结"></a>Java集合框架总结</h2><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><p><img src="http://cdn.tycoding.cn/QQ20190623-181246.png" alt></p>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><ul>
<li><strong>ArrayList</strong>:  Object数组，线程不安全，查询快，增删慢，效率高</li>
<li><strong>Vector</strong>:  Object数组，线程安全，查询快，增删慢，效率低</li>
<li><strong>LinkedList</strong>:  双向链表，线程不安全，查询慢，增删快，效率高</li>
</ul>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><ul>
<li><strong>HashSet</strong>: 无序、唯一，基于HashMap实现，底层采用HashMap存储元素</li>
<li><strong>LinkedHashSet</strong>: LinkedHashSet继承自HashSet，并且其内部通过LinkedHashMap实现</li>
<li><strong>TreeSet</strong> 有序、唯一，红黑树</li>
</ul>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p><img src="http://cdn.tycoding.cn/QQ20190623-181259.png" alt></p>
<ul>
<li><strong>HashMap</strong>: JDK1.8之前HashMap由数组和链表组成，数组时HashMap的主体，链表是为了解决Hash冲突问题。JDK1.8之后当Table中Node数量大于8时，就将链表转换为红黑树，以减少搜索时间提高效率。</li>
<li><strong>LinkedHashMap</strong>: LinkedHashMap继承自HashMap，所有他的底层仍然由数组和链表/红黑树实现。另外，LinkedHashMap在上面的结构基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。</li>
<li><strong>HashTable</strong>:  数组+链表组成。数组时HashTable的主体，链表是为了解决Hash冲突问题</li>
<li><strong>TreeMap</strong>:  红黑树</li>
</ul>
<h1 id="Java并发"><a href="#Java并发" class="headerlink" title="Java并发"></a>Java并发</h1><h2 id="线程和进程的区别？"><a href="#线程和进程的区别？" class="headerlink" title="线程和进程的区别？"></a>线程和进程的区别？</h2><ul>
<li>进程是程序的一次执行过程，是系统运行程序的基本单位</li>
<li>线程与进程类似，但线程是一个比进程更小的执行单位。一个进程执行过程中可以产生多个线程，</li>
</ul>
<p>在Java中，启用一个<code>main</code>方法就是启动了一个JVM进程，而<code>main</code>函数所在的线程就是这个进程中的一个线程，也称为主线程。</p>
<h2 id="从JVM角度分析进程和线程的关系？"><a href="#从JVM角度分析进程和线程的关系？" class="headerlink" title="从JVM角度分析进程和线程的关系？"></a>从JVM角度分析进程和线程的关系？</h2><p>根据JVM的内存划分，对于线程而言：多个线程<strong>共享进程的堆、方法区资源</strong>，但每个线程又有自己的程序计数器、虚拟机栈、本地方法栈。</p>
<p><img src="https://www.tycoding.cn/2019/05/09/jvm/jvm-start/QQ20190503-095731.png" alt></p>
<p>也就是说，在一个JVM进程中，可以存在多个线程，每个线程都共享了这个JVM进程的方法区、堆；并且每个线程又都具有自己的虚拟机栈、本地方法栈、程序计数器等。</p>
<h3 id="为什么方法区和堆是线程共享区？"><a href="#为什么方法区和堆是线程共享区？" class="headerlink" title="为什么方法区和堆是线程共享区？"></a>为什么方法区和堆是线程共享区？</h3><ul>
<li><strong>方法区（Method Area）</strong> 存储已被虚拟机加载的类信息、常量、静态变量等数据。方法区中又包含 <strong>运行时常量池</strong> ，这部分区域储存Class文件信息和编译期生成的各种字面量和符号引用。</li>
<li><strong>堆（Heap）</strong>  堆内存储存了对象实例（比如<code>new</code>关键字创建的实例对象），它是JVM中内存区最大的一块区域。</li>
</ul>
<p>所以，一个进程的启动可能包含了多个线程，而这个进程中的静态变量等都是随着类加载而加载的，他应该不属于某个线程独有，所以将其存储于方法区中。对象实例都储存在Java堆内存中，作为Java最大的一块内存区域，肯定不能是某个线程独占的。</p>
<h3 id="为什么虚拟机栈和本地方法栈是线程独占区？"><a href="#为什么虚拟机栈和本地方法栈是线程独占区？" class="headerlink" title="为什么虚拟机栈和本地方法栈是线程独占区？"></a>为什么虚拟机栈和本地方法栈是线程独占区？</h3><ul>
<li><strong>虚拟机栈</strong>： 每个Java方法执行的同时都会创建一个栈帧储存局部变量表、操作数栈、方法出口等。从方法的执行到结束，对应将栈帧压入Java虚拟机栈和从虚拟机栈中弹出的过程。</li>
<li><strong>本地方法栈</strong>： 本地方法栈类似Java虚拟机栈，只不过Java虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用到的<code>native</code>方法服务。</li>
</ul>
<h3 id="程序计数器是什么？"><a href="#程序计数器是什么？" class="headerlink" title="程序计数器是什么？"></a>程序计数器是什么？</h3><p><strong>程序计数器（Program Counter Register）</strong>：当前线程执行的字节码的行号指示器。每个线程都有独立的程序计数器。此内存区域是Java虚拟机中唯一一个没有任何OutOfMemoryError情况的区域。</p>
<h2 id="说说并行和并发的区别？"><a href="#说说并行和并发的区别？" class="headerlink" title="说说并行和并发的区别？"></a>说说并行和并发的区别？</h2><ul>
<li><strong>并行</strong>： 同一时间段，多个任务都在执行（单位时间内不一定同时执行）</li>
<li><strong>并发</strong>： 单位时间内，多个任务同时执行。</li>
</ul>
<h2 id="使用多线程可能带来什么问题？"><a href="#使用多线程可能带来什么问题？" class="headerlink" title="使用多线程可能带来什么问题？"></a>使用多线程可能带来什么问题？</h2><p>并发编程的目的就是提高程序的执行效率，但并发编程可能造成：内存泄漏、上下文切换、死锁等问题</p>
<h2 id="说说线程的生命周期和状态？"><a href="#说说线程的生命周期和状态？" class="headerlink" title="说说线程的生命周期和状态？"></a>说说线程的生命周期和状态？</h2><table>
<thead>
<tr>
<th>状态名称</th>
<th>状态说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>new</strong></td>
<td>初始状态，线程被创建，但还没有调用<code>start()</code>方法</td>
</tr>
<tr>
<td><strong>runnable</strong></td>
<td>运行状态，Java线程将操作系统中就绪和运行两种状态统称为“运行中”</td>
</tr>
<tr>
<td><strong>blocked</strong></td>
<td>阻塞状态，表示线程阻塞于锁</td>
</tr>
<tr>
<td><strong>waiting</strong></td>
<td>等待状态，线程需要等待当前线程或其他线程执行完成</td>
</tr>
<tr>
<td><strong>time_waiting</strong></td>
<td>超时等待状态，他可以实现在指定时间后自动返回</td>
</tr>
<tr>
<td><strong>terminated</strong></td>
<td>终止状态，表示当前线程已经执行完毕</td>
</tr>
</tbody></table>
<p>对应，程序会因为不同代码的执行产生不同的状态，如下图：</p>
<p><img src="http://cdn.tycoding.cn/Java+%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%98%E8%BF%81.png" alt></p>
<p>如上，线程创建后将进入<strong>NEW（初始）</strong>状态，调用<code>start()</code>开始运行，当线程执行<code>wait()</code>方法后，线程将进入<strong>WAITING（等待）</strong>状态，可以通过<code>wait(long)</code>或<code>join(long)</code>等方法终止等待状态；当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到<strong>BLOCKED（阻塞）</strong>状态。</p>
<h2 id="什么是上下文切换？"><a href="#什么是上下文切换？" class="headerlink" title="什么是上下文切换？"></a>什么是上下文切换？</h2><p>简单来说，并发编程中实际线程的数量都可能大于CPU核心的个数，而COU一个核心在任意时刻只能被一个线程使用，CPU为了保证并发的线程都有被执行，采用<strong>随机分配时间片并轮转</strong>的方式；而一个线程的时间片用户将保存并进入就绪状态直到下次分配时间片再执行，这个 <strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p>
<h2 id="什么是死锁？如何避免"><a href="#什么是死锁？如何避免" class="headerlink" title="什么是死锁？如何避免?"></a>什么是死锁？如何避免?</h2><p>举例：线程A持有资源2，线程B持有资源1，在线程A、B都没有释放自己所持有资源的情况下（锁未释放），他们都想同时获取对方的资源，因为资源1、2都被锁定，两个线程都会进入相互等待的情况，这种情况称为死锁。</p>
<p><img src="http://cdn.tycoding.cn/2019-4%E6%AD%BB%E9%94%811.png" alt></p>
<p>栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object resource1 = <span class="keyword">new</span> Object();<span class="comment">//资源 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object resource2 = <span class="keyword">new</span> Object();<span class="comment">//资源 2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"get resource1"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"waiting get resource2"</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">"get resource2"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"线程 1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"get resource2"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"waiting get resource1"</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">"get resource1"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"线程 2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread[线程 1,5,main]get resource1</span><br><span class="line">Thread[线程 2,5,main]get resource2</span><br><span class="line">Thread[线程 1,5,main]waiting get resource2</span><br><span class="line">Thread[线程 2,5,main]waiting get resource1</span><br></pre></td></tr></table></figure>

<p>线程1以<code>resource1</code>作为同步监视器，即可以轻松获取<code>resource1</code>同时也锁定了<code>resource1</code>，此时调用<code>sleep</code>让线程1等待1秒钟；此时线程2开始执行，他以<code>resource2</code>作为同步监视器同时也锁定了<code>resource2</code>，此时调用<code>sleep</code>让线程2等待1秒钟；而此时线程1等待1秒已经结束了，当他想要获取<code>resource2</code>时发现<code>resource2</code>已经被线程2锁定了，同理线程2结束等待后想要获取<code>resource1</code>时发现<code>resource1</code>已经被线程1锁定了。那么两者都无法同时获取对方的线程，便进入死锁状态。</p>
<p>因此产生死锁需要具备以下四个条件：</p>
<ol>
<li>互斥条件：该资源任意一个时刻只能由一个线程占用</li>
<li>请求和保持条件：一个线程因请求资源而阻塞时，对已获取的资源保持不放</li>
<li>不剥夺条件：线程已获取的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才使用资源</li>
<li>循环等待条件：若干进程之前形成一种头尾相接的循环等待资源关系。</li>
</ol>
<p>避免死锁就要破坏这四个条件中任意一个：</p>
<ol>
<li>破坏互斥条件：这个条件我们无法破坏，因为我们用锁的目的就是想让他们互斥</li>
<li>破坏请求与保持条件：一次性申请所有资源</li>
<li>破坏循环等待条件：按照一定顺序申请资源，避免资源的循环使用</li>
</ol>
<p>解决方案: 修改线程2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">"get resource1"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">"waiting get resource2"</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">"get resource2"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">"线程 2"</span>).start();</span><br></pre></td></tr></table></figure>

<p>Outout:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread[线程 1,5,main]get resource1</span><br><span class="line">Thread[线程 1,5,main]waiting get resource2</span><br><span class="line">Thread[线程 1,5,main]get resource2</span><br><span class="line">Thread[线程 2,5,main]get resource1</span><br><span class="line">Thread[线程 2,5,main]waiting get resource2</span><br><span class="line">Thread[线程 2,5,main]get resource2</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<h2 id="说说sleep-方法和wait-方法的区别？"><a href="#说说sleep-方法和wait-方法的区别？" class="headerlink" title="说说sleep()方法和wait()方法的区别？"></a>说说sleep()方法和wait()方法的区别？</h2><p>两者最主要的区别在于：<strong>sleep 方法没有释放锁，而 wait 方法释放了锁</strong></p>
<ul>
<li>两者都可以暂停线程的执行</li>
<li><code>wait()</code>通常用于线程间交互/通信，<code>sleep()</code>通常用户暂停执行</li>
<li><code>wait()</code>方法被调用后，线程不会自动苏醒，需要别的线程调用同一对象上的<code>notify()</code>或者<code>notifyAll()</code>方法。<code>sleep()</code>方法执行完成后，线程会自动苏醒。</li>
</ul>
<h2 id="调用start-方法会执行run-方法，为什么不能直接调用run-方法？"><a href="#调用start-方法会执行run-方法，为什么不能直接调用run-方法？" class="headerlink" title="调用start()方法会执行run()方法，为什么不能直接调用run()方法？"></a>调用start()方法会执行run()方法，为什么不能直接调用run()方法？</h2><p><code>new</code>一个<code>Thread</code>，线程进入了新建状态；调用<code>start()</code>方法，会启用一个线程并使线程进入就绪状态，当分配到时间片后就可以开始执行。<code>start()</code>会执行线程的相应准备工作，然后自动执行<code>run()</code>方法的内容，这才是真正的多线程工作。而直接执行<code>run()</code>方法，会吧<code>run()</code>方法当做一个<code>main</code>线程下的一个普通方法去执行，并不会在某个线程中执行他。</p>
<p><strong>总结：调用<code>start</code>方法可以启动线程并使线程进入就绪状态，而<code>run()</code>方法只是<code>Thread</code>的一个普通方法调用，还是在main主线程里执行，并不会在一个新线程中执行</strong></p>
<h2 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h2><p><code>synchronized</code>关键字解决多个线程之间访问资源的同步性，<code>synchronized</code>关键字可以保证它修饰的方法或代码块在任意时刻只能有一个线程执行。</p>
<p><strong>synchronized关键字最主要的三种使用方式</strong>：</p>
<ul>
<li><strong>修饰实例方法</strong>： 给当前对象加锁，进入同步代码块前要获取当前对象实例的锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此处的`synchronized`就相当于`synchronized(this)`，锁定的是当前对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>修饰静态方法</strong>： 给当前类加锁（因为静态方法没有<code>this</code>），会作用于当前类的所有对象实例，因为静态成员不属于任何一个实例对象，是一个类成员。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此处的`synchronized`就相当于`synzhronized(T.class)`，(T的当前类)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>修饰代码块</strong>： 指定加锁对象，对给定对象加锁，进入同步代码块之前要获取给定对象的锁</li>
</ul>
<hr>
<p><strong>待续…</strong></p>
<br>

<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>基于WebSocket的在线聊天系统</title>
    <url>/2019/06/16/project/boot-chat/</url>
    <content><![CDATA[<h1 id="基于WebSocket的在线聊天系统"><a href="#基于WebSocket的在线聊天系统" class="headerlink" title="基于WebSocket的在线聊天系统"></a>基于WebSocket的在线聊天系统</h1><p><strong>线上地址</strong></p>
<p><a href="http://39.105.46.235:8087/" target="_blank" rel="noopener">Chat</a></p>
<a id="more"></a>

<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>本仓库中包含了两个子项目：</p>
<ul>
<li><p><a href="https://github.com/TyCoding/boot-chat/tree/master/session-chat" target="_blank" rel="noopener">session-chat</a>  基于HTTPSession实现会话消息储存，受限于不同浏览器Session不能共享导致的数据丢失（如果使用同一浏览器测试则不会出现问题）</p>
</li>
<li><p><a href="https://github.com/TyCoding/boot-chat/tree/master/redis-chat" target="_blank" rel="noopener">redis-chat</a>  基于Redis实现会话消息储存，会话数据不会丢失，并使用定时任务，定时清除Redis中注册时间过长的用户数据以及其会话消息</p>
</li>
</ul>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本仓库中包含的是两个项目:</p>
<ul>
<li>如果使用 <a href="https://github.com/TyCoding/boot-chat/tree/master/session-chat" target="_blank" rel="noopener">session-chat</a> 项目，则开箱即用</li>
<li>如果使用 <a href="https://github.com/TyCoding/boot-chat/tree/master/redis-chat" target="_blank" rel="noopener">redis-chat</a> 项目，启动前需要配置好本地Redis环境才可。</li>
</ul>
<p><strong>注意</strong> 由于WebSocket限制，HTML与服务端通信，需要保证WebSocket链接的IP和浏览器访问的IP项目，如果是localhost就都是localhost，如果是127.0.0.1就都改为127.0.0.1，否则可能消息推送失败。</p>
<h2 id="核心依赖"><a href="#核心依赖" class="headerlink" title="核心依赖"></a>核心依赖</h2><table>
<thead>
<tr>
<th>依赖</th>
<th>版本</th>
</tr>
</thead>
<tbody><tr>
<td>Spring Boot</td>
<td>2.1.5.RELEASE</td>
</tr>
<tr>
<td>spring-boot-starter-websocket</td>
<td>2.1.5.RELEASE</td>
</tr>
<tr>
<td>lombok</td>
<td>1.18.8</td>
</tr>
<tr>
<td>spring-boot-starter-thymeleaf</td>
<td>2.1.5.RELEASE</td>
</tr>
<tr>
<td>FastJSON</td>
<td>1.2.58</td>
</tr>
<tr>
<td>Vue.js</td>
<td>2.6.10</td>
</tr>
<tr>
<td>Element-UI</td>
<td>2.7.0</td>
</tr>
</tbody></table>
<h2 id="请喝果汁"><a href="#请喝果汁" class="headerlink" title="请喝果汁"></a>请喝果汁</h2><p>如果此项目对你的学习有些帮助，你或许可以请作者喝一杯果汁以表示鼓励</p>
<p><img src="/2019/06/16/project/boot-chat/wechat.png" alt></p>
<h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p><a href="https://www.tycoding.cn/about/">传送门</a></p>
<h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><p><img src="/2019/06/16/project/boot-chat/2019061610856.png" alt></p>
<p><img src="/2019/06/16/project/boot-chat/2019061610852.png" alt></p>
<br>

<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <categories>
        <category>websocket</category>
      </categories>
      <tags>
        <tag>websocket</tag>
      </tags>
  </entry>
  <entry>
    <title>（十七）Spring Boot 整合 Websocket</title>
    <url>/2019/06/12/boot/spring-boot-websocket/</url>
    <content><![CDATA[<h1 id="Spring-Boot-整合-Websocket"><a href="#Spring-Boot-整合-Websocket" class="headerlink" title="Spring Boot 整合 Websocket"></a>Spring Boot 整合 Websocket</h1><h2 id="概念引入"><a href="#概念引入" class="headerlink" title="概念引入"></a>概念引入</h2><p><code>Websocket</code> 是一种网络通信协议。</p>
<p>和HTTP协议不同，HTTP协议通信只能由客户端发起。比如我们常见的CRUD都仅仅是服务端请求客户端的接口，最终消息由客户端推送给服务端，服务端再实现数据回显等。</p>
<p><code>Websocket</code> 最大的特点就是实现了服务器可以主动向客户端推送消息，客户端也可以主动向服务器发送消息，实现了真正的双向平等会话。</p>
<a id="more"></a>

<p>如果在服务端实现<code>Websocket</code>主动向客户端推送消息，需要使用JavaScript的<code>WebSocket</code>对象，它是JavaScript内置的对象，比如我们创建一个<code>Websocket</code>连接对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> websocket = <span class="keyword">new</span> WebSocket(<span class="string">'ws://...'</span>)</span><br></pre></td></tr></table></figure>

<p>注意和HTTP通信不同在于，协议的标识符不再是<code>http</code>或<code>https</code>，而是<code>ws</code>或<code>wss</code></p>
<p>也就是说，服务服务端想主动向客户端推送消息，需要使用JavaScript内置的<code>WebSocket</code>对象实现请求。那么对应客户端需要一个WebSocket提供一个接口用于接收<code>websocket</code>请求，这个请求接口并不等同于HTTP的Rest接口，请注意区分</p>
<p><strong>仓库地址：<a href="https://github.com/TyCoding/spring-learn" target="_blank" rel="noopener">spring-learn</a></strong><br><strong>欢迎star、fork，给作者一些鼓励</strong><a href="https://github.com/TyCoding/spring-learn" target="_blank" rel="noopener">https://github.com/TyCoding/spring-learn</a>)</p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ol>
<li>引入依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Spring Websocket --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-websocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Web --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--Lombok--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Thymeleaf --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置WebSocket需要自动注入的Servlet</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebsocketAutoConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServerEndpointExporter <span class="title">endpointExporter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServerEndpointExporter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>前端使用Websocket主动推送消息：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> websocket = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链接WebSocket</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">connectChat</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"&gt;&gt; 链接WebSocket"</span>)</span><br><span class="line">    websocket = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:8080/chat/'</span> + (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime())</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Websocket链接错误时调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    websocket.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        writeHTML(<span class="string">'Websocket链接发生错误'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Websocket链接成功时调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    websocket.onopen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        writeHTML(<span class="string">'Websocket链接成功'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收到消息的回调方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    websocket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(event)</span><br><span class="line">        writeHTML(event.data)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链接关闭时的回调方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    websocket.onclose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        writeHTML(<span class="string">'Websocket链接关闭'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 关闭WebSock链接</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">closeChat</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    websocket.close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 将消息写到HTML标签上</span></span><br><span class="line"><span class="comment">  * @param message</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">writeHTML</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"message"</span>).innerHTML += message + <span class="string">'&lt;br/&gt;'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 发送消息</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">send</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> message = <span class="built_in">document</span>.getElementById(<span class="string">'text'</span>).value</span><br><span class="line">    websocket.send(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务端接收推送消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ServerEndpoint</span>(<span class="string">"/chat/&#123;id&#125;"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebsocketServerEndpoint</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在线连接数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> onlineCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于存放当前Websocket对象的Set集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CopyOnWriteArraySet&lt;WebsocketServerEndpoint&gt; websocketServerEndpoints = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//与客户端的会话Session</span></span><br><span class="line">    <span class="keyword">private</span> Session session;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//会话窗口的ID标识</span></span><br><span class="line">    <span class="keyword">private</span> String id = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链接成功调用的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpen</span><span class="params">(Session session, @PathParam(<span class="string">"id"</span>)</span> String id) </span>&#123;</span><br><span class="line">        log.info(<span class="string">"onOpen &gt;&gt; 链接成功"</span>);</span><br><span class="line">        <span class="keyword">this</span>.session = session;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将当前websocket对象存入到Set集合中</span></span><br><span class="line">        websocketServerEndpoints.add(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在线人数+1</span></span><br><span class="line">        addOnlineCount();</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"有新窗口开始监听："</span> + id + <span class="string">", 当前在线人数为："</span> + getOnlineCount());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sendMessage(<span class="string">"有新窗口开始监听："</span> + id + <span class="string">", 当前在线人数为："</span> + getOnlineCount());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链接关闭调用的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"onClose &gt;&gt; 链接关闭"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//移除当前Websocket对象</span></span><br><span class="line">        websocketServerEndpoints.remove(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在内线人数-1</span></span><br><span class="line">        subOnLineCount();</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"链接关闭，当前在线人数："</span> + getOnlineCount());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 收到客户端消息后调用的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String message, Session session)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"接收到窗口："</span> + id + <span class="string">" 的信息："</span> + message);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送信息</span></span><br><span class="line">        <span class="keyword">for</span> (WebsocketServerEndpoint websocketServerEndpoint : websocketServerEndpoints) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                websocketServerEndpoint.sendMessage(<span class="string">"接收到窗口："</span> + id + <span class="string">" 的信息："</span> + message);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnError</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Session session, Throwable e)</span> </span>&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 推送消息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.session.getBasicRemote().sendText(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义推送消息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendInfo</span><span class="params">(String id, String message)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"推送消息到窗口："</span> + id + <span class="string">" ，推送内容："</span> + message);</span><br><span class="line">        <span class="keyword">for</span> (WebsocketServerEndpoint endpoint : websocketServerEndpoints) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (id == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    endpoint.sendMessage(message);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (endpoint.id.equals(id)) &#123;</span><br><span class="line">                    endpoint.sendMessage(message);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">subOnLineCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        WebsocketServerEndpoint.onlineCount--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getOnlineCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> onlineCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addOnlineCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        WebsocketServerEndpoint.onlineCount++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h2><p><img src="/2019/06/12/boot/spring-boot-websocket/20190612113448.png" alt></p>
<p><img src="/2019/06/12/boot/spring-boot-websocket/13AF3253225850776AE4276753778333.jpg" alt></p>
<br>

<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <categories>
        <category>websocket</category>
      </categories>
      <tags>
        <tag>websocket</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud分布式微服务项目</title>
    <url>/2019/05/30/cloud/cloud-template/</url>
    <content><![CDATA[<h1 id="SpringCloud分布式微服务项目"><a href="#SpringCloud分布式微服务项目" class="headerlink" title="SpringCloud分布式微服务项目"></a>SpringCloud分布式微服务项目</h1><p>项目地址：<a href="https://github.com/TyCoding/cloud-template" target="_blank" rel="noopener">Spring-Cloud-Template</a> 欢迎star, fork支持作者</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>旨在提供一个最基础的CRUD模板，并没与太复杂的业务流程，想让初学微服务或者想要找个Vue+Node前后端分离项目的同学有一个案例参考。大家可以基于此项目继续扩展，或者看此项目和源码和文档自己尝试开发前后端分离的项目。</p>
<a id="more"></a>

<p><strong>如果此项目对大家有帮助，欢迎右上角star支持作者</strong></p>
<p><strong>注意：请以批判的角度看此项目，本人也是技术有限，如果你有更好的解决方案请尽快联系我。大牛勿喷</strong></p>
<p><code>cloud-template</code>: 一套极简的SpringCloud微服务项目模板，没有具体的业务，提供最详细的SpringCloud搭建流程</p>
<p><code>sct-api</code>: 分布式微服务项目后端接口</p>
<p><code>sct-app</code>: Vue + Node.js 前端项目</p>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在开始此项目前，请先学习这个基础项目模板 <a href="https://github.com/TyCoding/cloud-template/tree/master/cloud-template" target="_blank" rel="noopener">cloud-template</a> ，并仔细阅读以下开发文档：</p>
<p><a href="https://github.com/TyCoding/cloud-template/blob/master/cloud-template/doc/env-1.md" target="_blank" rel="noopener">从零开始搭建Spring Cloud脚手架</a></p>
<p><a href="https://github.com/TyCoding/cloud-template/tree/master/sct-app" target="_blank" rel="noopener">如何食用vue-admin-template前端项目</a></p>
<h2 id="Spring-Cloud-Template"><a href="#Spring-Cloud-Template" class="headerlink" title="Spring Cloud Template"></a>Spring Cloud Template</h2><ul>
<li><p>一套极简的Spring Cloud微服务项目模板，开箱即用，方便扩展</p>
</li>
<li><p>基于 Spring Cloud Greenwich、Spring Boot 的微服务项目</p>
</li>
<li><p>基于 vue-admin-template。使用Vue框架，快速入门前后端分离式开发模式</p>
</li>
<li><p>详细的开发文档</p>
</li>
</ul>
<h2 id="核心依赖"><a href="#核心依赖" class="headerlink" title="核心依赖"></a>核心依赖</h2><table>
<thead>
<tr>
<th>依赖</th>
<th>版本</th>
</tr>
</thead>
<tbody><tr>
<td>Spring Boot</td>
<td>2.1.5.RELEASE</td>
</tr>
<tr>
<td>Spring Cloud</td>
<td>Greenwich.SR1</td>
</tr>
<tr>
<td>Spring Security OAuth2</td>
<td>2.3.4.RELEASE</td>
</tr>
<tr>
<td>tk.mybatis</td>
<td>4.1.5</td>
</tr>
<tr>
<td>vue-admin-template</td>
<td>4.1.0</td>
</tr>
<tr>
<td>Swagger2</td>
<td>2.9.2</td>
</tr>
</tbody></table>
<h2 id="模块说明"><a href="#模块说明" class="headerlink" title="模块说明"></a>模块说明</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sct-app -- 前端工程[8100]</span><br><span class="line">sct-api </span><br><span class="line">├── sct-admin -- 系统管理模块</span><br><span class="line">    ├── sct-admin-api -- 系统管理的公共api模块</span><br><span class="line">    ├── sct-admin-biz -- 系统管理的业务实现模块 [4100]</span><br><span class="line">├── sct-auth -- 授权模块 [4000]</span><br><span class="line">├── sct-common -- 系统公共类模块</span><br><span class="line">├── sct-config -- 配置中心 [8888]</span><br><span class="line">├── sct-eureka -- Eureka服务注册与发现 [8761]</span><br><span class="line">├── sct-gateway -- Zuul网关 [9999]</span><br><span class="line">├── sct-monitor -- Spring Boot Admin监控 [3000]</span><br><span class="line">├── sct-zipkin -- Zipkin链路监控 [3001]</span><br></pre></td></tr></table></figure>

<h2 id="启动说明"><a href="#启动说明" class="headerlink" title="启动说明"></a>启动说明</h2><ol>
<li>修改本地<code>hosts</code>文件，添加如下内容（可以通过 <a href="http://oldj.github.io/SwitchHosts/" target="_blank" rel="noopener">SwitchHosts</a> 快速修改）。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1 sct-eureka</span><br><span class="line">127.0.0.1 sct-mysql</span><br><span class="line">127.0.0.1 sct-auth</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>修改<code>sct-config/src/main/resources/</code>下配置文件中的数据库连接信息，主要涉及<code>sct-admin-biz-dev.yml</code>和<code>sct-auth-dev.yml</code>两个文件</p>
</li>
<li><p>导入项目根目录下的<code>base.sql</code>，建立数据库</p>
</li>
</ol>
<p>默认密码请参看<code>sct-admin-biz/src/test/PasswordEncoderTest.java</code>测试类</p>
<table>
<thead>
<tr>
<th>Username</th>
<th>Password</th>
</tr>
</thead>
<tbody><tr>
<td>tycoding</td>
<td>tycoding</td>
</tr>
<tr>
<td>admin</td>
<td>admin</td>
</tr>
<tr>
<td>test</td>
<td>test</td>
</tr>
</tbody></table>
<ol start="4">
<li>严格按照如下顺序依次启动服务模块</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. EurekaApplication.java -- 服务注册中心</span><br><span class="line">2. ConfigApplication.java -- 服务配置中心</span><br><span class="line">3. MonitorApplication.java -- Spring Boot Admin监控</span><br><span class="line">4. ZipkinApplication.java -- Zipkin链路监控</span><br><span class="line">5. AdminBizApplication.java -- 系统管理模块</span><br><span class="line">6. AuthApplication.java -- 授权模块</span><br><span class="line">7. GatewayApplication.java -- Zuul网关</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>启动前端项目</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> cd sct-app</span><br><span class="line"><span class="meta">$</span> npm install</span><br><span class="line"><span class="meta">$</span> npm run dev</span><br></pre></td></tr></table></figure>

<h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><p><img src="/2019/05/30/cloud/cloud-template/2019052814147.png" alt></p>
<p><img src="/2019/05/30/cloud/cloud-template/2019052972549.png" alt></p>
<p><img src="/2019/05/30/cloud/cloud-template/2019052821354.png" alt></p>
<p><img src="/2019/05/30/cloud/cloud-template/2019052982515.png" alt></p>
<p><img src="/2019/05/30/cloud/cloud-template/2019052983430.png" alt></p>
<p><img src="/2019/05/30/cloud/cloud-template/2019052983452.png" alt></p>
<p><img src="/2019/05/30/cloud/cloud-template/2019052983458.png" alt></p>
<br>

<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <categories>
        <category>spring-cloud</category>
      </categories>
      <tags>
        <tag>spring-cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud Template微服务后端</title>
    <url>/2019/05/30/cloud/cloud-template-api/</url>
    <content><![CDATA[<h1 id="从零开始搭建SpringCloud脚手架"><a href="#从零开始搭建SpringCloud脚手架" class="headerlink" title="从零开始搭建SpringCloud脚手架"></a>从零开始搭建SpringCloud脚手架</h1><p>项目地址：<a href="https://github.com/TyCoding/cloud-template" target="_blank" rel="noopener">Spring-Cloud-Template</a> 欢迎star, fork支持作者</p>
<h1 id="概念引入"><a href="#概念引入" class="headerlink" title="概念引入"></a>概念引入</h1><h2 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h2><p><strong>Eureka:</strong> 服务注册中心。通过Eureka可以监控各个服务的运行状态。它具有如下几个角色：</p>
<ul>
<li>Eureka Server： 提供服务注册与发现</li>
<li>Service Provider: 服务提供方。将自身注册到Eureka，供消费者使用</li>
<li>Service Consumer:  服务消费方。从Eureka中获取服务器提供方列表，从而消费服务</li>
</ul>
<a id="more"></a>

<p>举个栗子：</p>
<p><img src="/2019/05/30/cloud/cloud-template-api/QQ20190518-195930.png" alt></p>
<blockquote>
<p>  问题引入：</p>
</blockquote>
<p>​        前端APP发送一个请求，此请求需要调用某个服务的接口，比如此时有两个订单服务、一个派送服务 ( 因为要考虑并发，所以通常服务不止一个，而是一个集群 )。上图中前端APP直接请求某个具体服务的接口，如果后端服务集群非常庞大，前端就要记录很多服务的IP地址。并且对于同一服务的集群配置情况，前端APP还需要自行判断到底调用哪个服务。</p>
<blockquote>
<p>  解决办法：</p>
</blockquote>
<p>​        显然上述的方式是不可取的。按照之前开发SSM框架前后端不分离时，通常页面直接请求的内部服务接口，从不考虑服务的具体IP地址，因为默认使用的此服务的IP地址。那么在微服务架构中也应该这样设计。所以我们加一个<strong>GateWay网关服务 ( 后面讲 )</strong>，前端APP直接请求请求网关，仅需要记录网关的IP地址即可，这样就将后端服务接口寻址调用的工作交给了服务端完成。举个栗子：</p>
<p><img src="/2019/05/30/cloud/cloud-template-api/QQ20190518-202223.png" alt></p>
<blockquote>
<p>  问题引入：</p>
</blockquote>
<p>​        虽然使用了网关让前端APP直接调用网关地址，由网关负责具体的接口寻址调用，从而减轻了前端的负担。但是，同样，网关也仍然需要知道所有服务的IP地址和对应的接口，并且对于同一服务集群配置的情况仍然要考虑到底调用哪个服务才能分摊请求压力。</p>
<blockquote>
<p>  解决办法：</p>
</blockquote>
<p>​        所以，需要一个服务，他能记录系统中所有的微服务IP地址；并且有类似负载均衡的算法，对于服务集群配置，该服务能知道调用哪些服务才能平均分配请求的压力；并且，如果哪个服务崩溃，该服务还能快速知道并不再向崩溃的服务发送请求。于是，<strong>Eureka</strong>诞生了。</p>
<p><img src="/2019/05/30/cloud/cloud-template-api/QQ20190518-203908.png" alt></p>
<p>Eureka是服务注册中心，其他具体服务可以向这个Eureka注册中心注册自己。当前端发送请求时，首先前端APP会直接请求网关，当然网关服务也注册在Eureka注册中心上，然后网关把接收到的请求交由Eureka处理，Eureka接收到这些请求，会从自己的服务注册列表中寻找对应的服务地址，然后实现调用具体的服务。</p>
<h2 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h2><blockquote>
<p>  问题引入：</p>
</blockquote>
<p>​        在上面的介绍中，我们基本解决了前端APP调用后端服务集群的问题。但又必须考虑一个问题，分布式微服务项目，即各个服务相互独立，但是各个服务又存在相互调用的关系。如何解决服务于服务之间的通信呢？</p>
<blockquote>
<p>  解决办法：</p>
</blockquote>
<p>​        在微服务架构中，服务于服务的通讯都是基于Http Restful的。SpringCloud有两种调用方式：</p>
<ul>
<li>使用 <strong>Ribbon + RestTemplate</strong>。<strong>Ribbon</strong>是一个负载均衡客户端，可以很好的控制Http和Tcp的一些行为。而<strong>RestTemplate</strong>是Spring本身提供的用于远程调用Rest接口的HTTP客户端。</li>
<li>使用 <strong>Feign</strong>。<strong>Feign</strong>是一个声明式的HTTP客户端，仅需要一个<strong>@FeignClient</strong>注解就能实现远程调用。<strong>Feign</strong>默认集成了<strong>Ribbon</strong>，并和Eureka结合，默认实现了负载均衡的效果。</li>
</ul>
<h2 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h2><blockquote>
<p>  问题引入：</p>
</blockquote>
<p>​        在集群项目中，如果突然某个服务因为访问压力过大崩溃了，Eureka再调用该服务就会调用失败，并且如果该服务向下还存在与其他服务的关联，那么就会造成其他服务也不可用，从而使错误传递下去，这也就是<strong>雪崩效应</strong>。如何解决呢？</p>
<blockquote>
<p>  解决办法：</p>
</blockquote>
<p>​        <strong>Hystrix</strong>的出现就是解决这一现象。<strong>Hystrix</strong>熔断器就像家用电闸中的保险丝，如果整个电路中某处发生了漏电、或者用电过高保险丝就会直接熔断，直接停电阻止事态恶化。如果集群中某个服务不可用、或者响应时间过长，Hystrix会直接阻断Eureka再调用此服务，从而避免了系统中所有服务都不可用。</p>
<h2 id="Hystrix-Dashboard"><a href="#Hystrix-Dashboard" class="headerlink" title="Hystrix-Dashboard"></a>Hystrix-Dashboard</h2><blockquote>
<p>  问题引入：</p>
</blockquote>
<p>​        上面介绍了使用<strong>Hystrix</strong>实现熔断服务，但作为开发者，我们并不能确定服务什么时候被熔断。</p>
<blockquote>
<p>  解决办法：</p>
</blockquote>
<p>​        提供了<code>hystrix-dashboard</code>工具实现实时监控Hystrix熔断器的状态。</p>
<h2 id="Zuul"><a href="#Zuul" class="headerlink" title="Zuul"></a>Zuul</h2><p><strong>Zuul</strong>路由网关。举个栗子：</p>
<p><img src="/2019/05/30/cloud/cloud-template-api/Lusifer201805292246011.png" alt></p>
<p>如上是一个基本的微服务架构图，先抛开左侧的配置服务，如果前端APP请求后台接口，显然前端无法记录后端那么多服务的API地址，按照SSM框架的开发思路，前端APP仅需要记录一个IP地址即可，所有的请求都应该是请求这个IP中的某个接口。</p>
<p>那么<strong>Zuul</strong>路由网关的作用就是如此，他实现将客户端<strong>按照一定约束</strong>的不同请求转发到对应的服务，这样就实现客户端仅记录一个IP地址就能实现请求不同服务的接口。</p>
<h2 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h2><p>如果系统服务模块非常多时，每次修改服务配置都要修改服务<code>src/main/resources</code>下的<code>application.yml</code>可能会很麻烦，<code>spring-cloud-config</code>就解决了这个问题，Config Server端实现将配置文件内容以接口的形式暴露，Client端通过该接口得到配置文件内容，并以此初始化自己的应用。</p>
<h2 id="ZipKin"><a href="#ZipKin" class="headerlink" title="ZipKin"></a>ZipKin</h2><p><strong>ZipKin</strong> 服务链路追踪。可以追踪系统中服务间的依赖调用关系，查看调用的详细数据，收集服务的详细数据。提供 <strong>Zipkin UI</strong> 可以轻松的在Web端收集和分析数据。</p>
<h2 id="Spring-Boot-Admin"><a href="#Spring-Boot-Admin" class="headerlink" title="Spring-Boot-Admin"></a>Spring-Boot-Admin</h2><p><strong>Spring Boot Admin</strong> 实现堆各个微服务的健康状态、会话数量、并发数、服务资源、延迟等信息的收集，是一套强大的监控管理系统</p>
<h1 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a>项目实战</h1><p>本地创建一个空文件夹，使用IDEA打开这个文件夹，并在其中创建<code>pom.xml</code>文件</p>
<p><img src="/2019/05/30/cloud/cloud-template-api/QQ20190518-151358.png" alt></p>
<p><code>pom.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.tycoding<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>template<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>template<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Greenwich.SR1<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="搭建Eureka服务"><a href="#搭建Eureka服务" class="headerlink" title="搭建Eureka服务"></a>搭建Eureka服务</h2><p>Eureka是服务注册中心，但它自己同样也是一个服务。</p>
<ol>
<li><p>和上面一样，在<code>cloud-template</code>文件夹下创建<code>template-eureka</code>文件夹</p>
</li>
<li><p>创建该服务的启动器类：<code>EurekaApplication</code> </p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仅需要添加<code>@EnableEurekaServer</code>就告诉了Spring这个服务的Eureka服务注册中心。</p>
<ol start="3">
<li>在<code>cloud-template</code>父工程<code>pom.xml</code>中新增一个节点</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>template-eureka<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>创建<code>application.yml</code>配置文件</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line">    <span class="comment"># 应用名称</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">template-eureka</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line">    <span class="comment"># Eureka注册中心HOST主机地址，可以采用：1.直接配置IP；2.配置本地域名并修改本地hosts文件</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">localhost</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line">    <span class="comment"># 是否将自己注册到注册中心。因为项目中只有一个注册中心就是自己，所以无需再注册</span></span><br><span class="line"><span class="attr">    register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 是否从远程拉取其他注册中心，因为注册中心只有自己所以不需要。如果注册中心有多个，可以相互暴露，相互拉取</span></span><br><span class="line"><span class="attr">    fetch-registry:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line">      <span class="comment"># 该注册中心连接地址</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br></pre></td></tr></table></figure>

<p><img src="/2019/05/30/cloud/cloud-template-api/QQ20190518-154256.png" alt></p>
<ol start="5">
<li>启动<code>EurekaApplication.java</code>中的main方法，浏览器访问：<code>localhost:8080</code></li>
</ol>
<p><img src="/2019/05/30/cloud/cloud-template-api/2019051834319.png" alt></p>
<p>可以看到此时没有任何服务注册到Eureka注册中心。</p>
<h2 id="搭建生产者服务"><a href="#搭建生产者服务" class="headerlink" title="搭建生产者服务"></a>搭建生产者服务</h2><ol>
<li>在<code>cloud-template</code>下创建<code>template-admin</code>文件夹</li>
<li>创建<code>pom.xml</code>，主要添加一个依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在父工程<code>cloud-template</code>的<code>pom.xml</code>中再添加一个节点</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>template-eureka<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>template-admin<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>创建该服务的启动器类：<code>AdminApplication.java</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdminApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(AdminApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只需要添加注解<code>@EnableEurekaClient</code>就表明该服务Eureka的一个服务提供方。</p>
<ol start="5">
<li>创建配置文件<code>application.yml</code></li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">9001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">template-admin</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line">      <span class="comment"># Eureka注册中心连接地址</span></span><br><span class="line">      <span class="comment"># 如果注册中心地址配置的域名，这里使用 http://域名/eureka/ 格式</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8080/eureka/</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>运行<code>AdminApplication.java</code>中的main方法，继续访问<code>localhost:8080</code>地址：</li>
</ol>
<p><img src="/2019/05/30/cloud/cloud-template-api/2019051840157.png" alt></p>
<p>可看到，<code>template-admin</code>服务已经注册到了Eureka注册中心</p>
<ol start="7">
<li>在<code>template-admin</code>服务中创建一个Controller类：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdminController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello/&#123;name&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@PathVariable String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello "</span> + name + <span class="string">", this is template-admin"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>重启<code>template-admin</code>服务，访问：<code>localhost:9001/hello/tycoding</code>:</li>
</ol>
<p><img src="/2019/05/30/cloud/cloud-template-api/QQ20190519-145345.png" alt></p>
<h2 id="搭建消费者服务"><a href="#搭建消费者服务" class="headerlink" title="搭建消费者服务"></a>搭建消费者服务</h2><p>上面搭建了 <code>template-admin</code> 生产者服务，它暴露了Rest接口，那么其他服务想要调用生产者服务的接口，就必须实现与生产者服务的通信。最开始<strong>概念引入</strong>部分我们提到了SpringCloud实现服务间通信的两种方式，这里我们直接使用<strong>Feign</strong>实现。</p>
<ol>
<li>在<code>cloud-template</code>下创建<code>template-auth</code>文件夹</li>
<li>创建<code>pom.xml</code>，主要添加两个依赖：</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在父工程<code>cloud-template</code>下再添加一个节点</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>template-eureka<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>template-admin<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>template-auth<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>创建该服务的启动器类：<code>AuthApplication.java</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(AuthApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要注意添加<code>@EnableDiscoveryClient</code>注解声明该服务为Eureka中服务消费方；添加<code>@EnableFeignClients</code>开启Feign声明式服务间通信（配合<code>@FeignClient</code>注解使用）。</p>
<ol start="5">
<li>创建配置文件<code>application.yml</code></li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">9002</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">template-auth</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line">      <span class="comment"># Eureka注册中心连接地址</span></span><br><span class="line">      <span class="comment"># 如果注册中心地址配置的域名，这里使用 http://域名/eureka/ 格式</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8080/eureka/</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>模拟创建一个Controller：<code>AuthController.java</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello/&#123;name&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@PathVariable String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello "</span> + name + <span class="string">", this is template-auth"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2019/05/30/cloud/cloud-template-api/QQ20190518-161308.png" alt> </p>
<ol start="7">
<li>启动项目，访问<code>localhost:8080</code></li>
</ol>
<p><img src="/2019/05/30/cloud/cloud-template-api/2019051841621.png" alt></p>
<p>可以看到该服务已经注册到了Eureka注册中心了。继续访问<code>localhost:9002/hello/tycoding</code>：</p>
<p><img src="/2019/05/30/cloud/cloud-template-api/QQ20190519-145358.png" alt></p>
<ol start="8">
<li>在<code>template-auth</code>服务下创建<code>feign/service</code>文件夹，并在其中创建<code>AuthFeignService.java</code>接口：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"template-admin"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AuthFeignService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里暴露一个Feign接口地址，其中`<span class="doctag">@GetMapping</span>`中的地址一定对应了`template-admin`服务中某个Controller中的请求地址（如果`template-admin`服务中没有这个接口地址就会404）</span></span><br><span class="line"><span class="comment">     * 如果其他地方调用了AuthFeignService接口的hello方法，FeignClient将类似通过转发的方式去请求调用`template-admin`服务中符合的接口地址的方法</span></span><br><span class="line"><span class="comment">     * 如果请求传递了参数，需要加<span class="doctag">@RequestParam</span>注解标识。如果URL中有动态参数，要添加<span class="doctag">@PathVariable</span>注解</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello/&#123;name&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@PathVariable(name = <span class="string">"name"</span>)</span> String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，这是一个供Feign调用的接口。Feign实现服务端通信有几个基本条件：</p>
<ul>
<li>该服务添加了<code>spring-cloud-starter-openfeign</code>依赖</li>
<li>该服务的启动器类上添加了<code>@EnableFeignClients</code>注解</li>
<li>该服务提供了一个接口类，并在该接口上添加了<code>@FeignClient</code>注解，并且<code>@FeignClient</code>注解中<code>value</code>属性值必须等于一个已在Eureka中注册的服务名称。</li>
<li>在该接口上添加一个调用的方法，该方法必须和被调用服务方Controller中的方法格式相同(除了没有方法具体实现，方法的返回值、参数列表都要相同)，并且需要和被调用方Controller接口一样在方法上添加<code>@RequestMapping</code>注解，指明被调用方接口的具体URL。</li>
</ul>
<ol start="9">
<li>修改<code>template-auth</code>服务中的<code>AuthController</code>类，添加一个请求接口：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthFeignService authFeignService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟Feign远程调用，这里暴露一个请求接口`/feignHello`</span></span><br><span class="line"><span class="comment">     * 这个请求接口将调用`AuthFeignService`（Feign接口）</span></span><br><span class="line"><span class="comment">     * Feign接口（`AuthFeignService`接口）将会通过`<span class="doctag">@FeignClient</span>(value = "template-admin")`在Eureka注册中心寻找`template-admin`模块</span></span><br><span class="line"><span class="comment">     * Feign接口类似Controller的Rest接口，也暴露一个地址，这个地址对应`template-admin`模块的一个Controller接口地址</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/feignHello/&#123;name&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">feignHello</span><span class="params">(@PathVariable String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> authFeignService.hello(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，这个<code>/feignHello/{name}</code>请求接口将调用<code>AuthFeignService</code>的<code>hello</code>方法，而<code>AuthFeignService</code>的<code>hello</code>方法最终由Feign调用<code>template-admin</code>中的<code>/hello</code>请求接口。</p>
<p>所以，<code>template-auth</code>服务中的<code>/feignHello/{name}</code>接口最终调用了<code>template-admin</code>服务中的<code>/hello/{name}</code>接口。重启<code>template-auth</code>服务，访问：<code>localhost:9002/feignHello/tycoding</code>:</p>
<p><img src="/2019/05/30/cloud/cloud-template-api/QQ20190519-145712.png" alt></p>
<p>显然，我们的分析都是正确的，使用Feign声明式服务调用，仅通过<code>@FeignClient</code>注解就能完成服务间通信。</p>
<h2 id="配置Hystrix熔断机制"><a href="#配置Hystrix熔断机制" class="headerlink" title="配置Hystrix熔断机制"></a>配置Hystrix熔断机制</h2><p>前面提到了Hystrix主要用于在多个服务间存在通信，而通信的某一方因为压力过大、响应时间过长而导致不可用，Hystrix就会阻止Eureka再给该服务分配请求，从而保证服务的高可用。</p>
<p>因此，Hystrix主要配置在存在服务间通信的地方。因为我们使用的Feign，Feign正是用来实现服务间通信的。所以我们只需要在自己创建的Feign接口中配置熔断器即可。因为Feign已经内置了Hystrix，我们只需要配置启用hystrix即可。</p>
<ol>
<li>修改<code>template-auth</code>中的<code>application.yml</code>:</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line"><span class="attr">  hystrix:</span></span><br><span class="line">    <span class="comment"># 开启Feign的Hystrix熔断器支持</span></span><br><span class="line"><span class="attr">    enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在<code>/feign/service/fallback</code>中创建<code>AuthFeignServiceFallbackImpl.java</code>:</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthFeignServiceFallbackImpl</span> <span class="keyword">implements</span> <span class="title">AuthFeignService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello "</span> + name + <span class="string">", this is template-auth, but request error"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类实现了<code>AuthFeignService</code>远程调用接口，作用就是当<code>AuthFeignService</code>调用的服务不可用时，Hystrix直接执行这个实现类中的方法，而不再执行<code>AuthFeignService</code>中的远程调用方法。</p>
<ol start="3">
<li>重启<code>template-auth</code>服务，访问<code>localhost:9002/feignHello/tycoding</code>发现正常访问。此时关闭<code>template-admin</code>服务：</li>
</ol>
<p><img src="/2019/05/30/cloud/cloud-template-api/2019051945927.png" alt></p>
<p>该服务已关闭，继续访问：<code>localhost:9002/feignHello/tycoding</code>:</p>
<p><img src="/2019/05/30/cloud/cloud-template-api/QQ20190519-162209.png" alt></p>
<p>可以看到访问该URL时，浏览器直接显示的<code>AuthFeignServiceFallbackImpl.java</code>中的响应数据，而不是再加载一下请求<code>AuthFeignService.java</code>中的请求。就是说如果被调用方服务一旦不可用，Hystrix就<strong>立刻</strong>熔断与该服务之间的通信。</p>
<h2 id="配置Hystrix-Dashboard"><a href="#配置Hystrix-Dashboard" class="headerlink" title="配置Hystrix-Dashboard"></a>配置Hystrix-Dashboard</h2><p>可以通过<code>hystrix-dashboard</code>工具实现对熔断器Hystrix的实时监控。因为我们在<code>template-auth</code>服务中使用了Feign远程调用，并且使用了Hystrix熔断器，所以我们只需要在<code>template-auth</code>服务中配置熔断监控：</p>
<ol>
<li>引入依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在<code>template-auth</code>启动器类上添加<code>@EnableHystrixDashboard</code>注解</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="meta">@EnableHystrixDashboard</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(AuthApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在<code>/config</code>文件夹下创建<code>HystrixDashboardConfig.java</code>:</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixDashboardConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">getServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HystrixMetricsStreamServlet streamServlet = <span class="keyword">new</span> HystrixMetricsStreamServlet();</span><br><span class="line">        ServletRegistrationBean registrationBean = <span class="keyword">new</span> ServletRegistrationBean(streamServlet);</span><br><span class="line">        registrationBean.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">        registrationBean.addUrlMappings(<span class="string">"/hystrix.stream"</span>);</span><br><span class="line">        registrationBean.setName(<span class="string">"HystrixMetricsStreamServlet"</span>);</span><br><span class="line">        <span class="keyword">return</span> registrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果项目中添加了<code>spring-cloud-starter-netflix-hystrix-dashboard</code>依赖，此依赖提供了 <code>/hystrix</code> 接口地址，这是访问<code>hystrix-dashboard</code>的入口地址。但是<code>hystrix-dashboard</code>需要监控某个Hystrix熔断器地址，那么这个监控地址哪来呢？</p>
<p>在SpringBoot2.x之前的版本中，SpringBoot默认提供了一个接口地址用于访问Hystrix熔断器。但是在SpringBoot2版本中需要手动提供一个Hystrix监控地址。上面的配置就是将Servlet ( HystrixMetricsStreamServlet )注入到Web容器中，类似<code>web.xml</code>中的<code>&lt;servlet-mapping&gt;</code>和<code>&lt;servlet-name&gt;</code>。</p>
<ol start="4">
<li>重启<code>template-auth</code>服务，访问：<code>localhost:9002/hystrix</code></li>
</ol>
<p><img src="/2019/05/30/cloud/cloud-template-api/2019051980018.png" alt></p>
<p>在上面输入<code>localhost:9002/hystrix.stream</code>，其中Delay是每隔几毫秒刷新一次</p>
<p><img src="/2019/05/30/cloud/cloud-template-api/2019051980353.png" alt></p>
<p>显示Loading说明连接成功，但是因为没有触发Hystrix熔断器，所以监控没有显示数据。我们继续访问：<code>localhost:9002/feignHello/tycoding</code>，重复刷新4次网页：</p>
<p><img src="/2019/05/30/cloud/cloud-template-api/2019051980909.png" alt></p>
<p>因为，所有的服务都是启动的，所以熔断器没有熔断。此时关掉<code>template-admin</code>服务，再次刷新<code>localhost:9002/feignHello/tycoding</code>接口10次：</p>
<p><img src="/2019/05/30/cloud/cloud-template-api/2019051981152.png" alt></p>
<h2 id="配置Zuul路由网关"><a href="#配置Zuul路由网关" class="headerlink" title="配置Zuul路由网关"></a>配置Zuul路由网关</h2><ol>
<li><p>在<code>cloud-template</code>下创建<code>template-zuul</code>文件夹</p>
</li>
<li><p>创建<code>pom.xml</code>，主要添加两个依赖：</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在父工程<code>cloud-template</code>的<code>pom.xml</code>下添加一个节点：</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>template-eureka<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>template-admin<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>template-auth<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>template-zuul<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>创建该服务的启动器类：<code>ZuulApplication.java</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ZuulApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>@EnableEurekaClient</code>表明此服务是Eureka的客户端，也就是此服务需要注册到Eureka注册中心；而注解<code>@EnableZuulProxy</code>就是开启Zuul网关的支持。</p>
<ol start="4">
<li>创建配置文件：<code>application.yml</code></li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">9003</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">template-zuul</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line">      <span class="comment"># Eureka注册中心连接地址</span></span><br><span class="line">      <span class="comment"># 如果注册中心地址配置的域名，这里使用 http://域名/eureka/ 格式</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8080/eureka/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">zuul:</span></span><br><span class="line"><span class="attr">  routes:</span></span><br><span class="line">    <span class="comment"># 路由名称，随意</span></span><br><span class="line"><span class="attr">    template-admin:</span></span><br><span class="line">      <span class="comment"># 路由地址</span></span><br><span class="line"><span class="attr">      path:</span> <span class="string">/api/admin/**</span></span><br><span class="line">      <span class="comment"># 该路由地址对应的服务名称</span></span><br><span class="line"><span class="attr">      serviceId:</span> <span class="string">template-admin</span></span><br><span class="line"><span class="attr">    template-auth:</span></span><br><span class="line"><span class="attr">      path:</span> <span class="string">/api/auth/**</span></span><br><span class="line"><span class="attr">      serviceId:</span> <span class="string">template-auth</span></span><br></pre></td></tr></table></figure>

<p>其中，<code>zuul.routers</code>下可以配置多个路由表，每个路由表中对应了具体的请求路径前缀<code>path</code>，这个请求路径最终会被Zuul路由到某个服务中，所需需要对应配置一个<code>serviceId</code>对应某个服务的名称。这样就实现了请求<code>/api/admin/xx</code>接口Zuul就会将请求转发到<code>template-admin</code>服务、请求<code>/api/auth/xx</code>接口Zuul就会将请求转发到<code>template-auth</code>服务。</p>
<ol start="5">
<li>按照<code>template-eureka</code> 、<code>template-zuul</code>、<code>template-admin</code>、<code>template-auth</code>的顺序启动项目。</li>
</ol>
<ul>
<li>访问：<code>localhost:9003/api/admin/hello/tycoding</code>:</li>
</ul>
<p><img src="/2019/05/30/cloud/cloud-template-api/QQ20190520-102309.png" alt></p>
<ul>
<li>访问：<code>localhost:9003/api/auth/hello/tycoding</code>:</li>
</ul>
<p><img src="/2019/05/30/cloud/cloud-template-api/QQ20190520-102331.png" alt></p>
<ul>
<li>访问：<code>localhost:9003/api/auth/feignHello/tycoding</code>:</li>
</ul>
<p><img src="/2019/05/30/cloud/cloud-template-api/QQ20190520-102515.png" alt></p>
<p>如此，通过<code>template-zuul</code>服务的路由转发功能，实现了仅仅通过请求<code>9003</code>这一个IP地址就能访问多个服务的接口。但实际测试中你可能还会遇到如下的错误：</p>
<p><img src="/2019/05/30/cloud/cloud-template-api/QQ20190520-102614.png" alt></p>
<p><img src="/2019/05/30/cloud/cloud-template-api/QQ20190520-102808.png" alt></p>
<p>这就是一个服务不可用的现象，Eureka会直接熔断与该服务的链接。而产生的原因与本地电脑的性能有关，所以就可能在项目运行中出现服务链接不上而被Eureka熔断的情况。</p>
<h3 id="配置Zuul的错误回调"><a href="#配置Zuul的错误回调" class="headerlink" title="配置Zuul的错误回调"></a>配置Zuul的错误回调</h3><p>上面两图中就一个Zuul网关路由错误的情况，而出现错误，肯定不能弹出Spring内置的错误页面，而需要定制一个错误信息，通常是JSON格式。</p>
<p>在<code>/fallback</code>目录下创建：<code>AuthFeignFallbackProvider.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthFeignFallbackProvider</span> <span class="keyword">implements</span> <span class="title">FallbackProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRoute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// serviceId，如果需要所有的调用都支持回退，则return "*" 或 return null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"template-auth"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回定制的错误信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> route</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cause</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClientHttpResponse <span class="title">fallbackResponse</span><span class="params">(String route, Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ClientHttpResponse() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> HttpStatus <span class="title">getStatusCode</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> HttpStatus.OK;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRawStatusCode</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> HttpStatus.OK.value();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getStatusText</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> HttpStatus.OK.getReasonPhrase();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> InputStream <span class="title">getBody</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">                Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                map.put(<span class="string">"status"</span>, <span class="number">200</span>);</span><br><span class="line">                map.put(<span class="string">"message"</span>, <span class="string">"链接失败，请检查您的网络"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ByteArrayInputStream(mapper.writeValueAsString(map).getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> HttpHeaders <span class="title">getHeaders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                HttpHeaders httpHeaders = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">                httpHeaders.setContentType(MediaType.APPLICATION_JSON_UTF8);</span><br><span class="line">                <span class="keyword">return</span> httpHeaders;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里要强调一个细节，如果Zuul路由服务失败不应该给客户端返回404、500等错误，因为客户端直接请求的是<code>template-zuul</code>路由网关服务，而请求<code>template-zuul</code>服务是成功的，<code>template-zuul</code>将请求转发到其他服务属于服务器内部错误，这中错误不应该暴露给客户端。除非是<code>template-zuul</code>路由网关服务自己挂了，才会返回给客户端404、500等错误。</p>
<p>重启<code>template-zuul</code>服务，<strong>立即</strong>访问<code>localhost:9003/api/auth/feignHello/tycoding</code>，一般都会链接不上服务：</p>
<p><img src="/2019/05/30/cloud/cloud-template-api/QQ20190520-105951.png" alt></p>
<h3 id="配置Zuul服务过滤器"><a href="#配置Zuul服务过滤器" class="headerlink" title="配置Zuul服务过滤器"></a>配置Zuul服务过滤器</h3><p>如果需要对请求进行拦截过滤，比如登录时应该携带Token值才运行请求，那么就可以使用Zuul提供的过滤器功能。</p>
<ul>
<li>在<code>/filter</code>目录下创建<code>LoginFilter.java</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过滤器类型：</span></span><br><span class="line"><span class="comment">     * pre: 路由前</span></span><br><span class="line"><span class="comment">     * routing: 路由时</span></span><br><span class="line"><span class="comment">     * post: 路由后</span></span><br><span class="line"><span class="comment">     * error: 路由发生错误时</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"pre"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过滤的顺序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否需要过滤</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过滤器的具体业务逻辑</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ZuulException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException </span>&#123;</span><br><span class="line">        RequestContext currentContext = RequestContext.getCurrentContext();</span><br><span class="line">        HttpServletRequest request = currentContext.getRequest();</span><br><span class="line">        logger.info(<span class="string">"&#123;&#125; &gt;&gt;&gt; &#123;&#125;"</span>, request.getMethod(), request.getRequestURI().toString());</span><br><span class="line">        String token = request.getParameter(<span class="string">"token"</span>);</span><br><span class="line">        <span class="keyword">if</span> (token == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.error(<span class="string">"Error! Request Token is Empty"</span>);</span><br><span class="line">            currentContext.setSendZuulResponse(<span class="keyword">false</span>);</span><br><span class="line">            currentContext.setResponseStatusCode(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                currentContext.getResponse().getWriter().write(<span class="string">"Request token is empty"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>重新启动<code>template-zuul</code>服务。访问<code>localhost:9003/api/admin/hello/tycoding</code></li>
</ul>
<p><img src="/2019/05/30/cloud/cloud-template-api/QQ20190520-125046.png" alt></p>
<p>访问<code>localhost:9003/api/admin/hello/tycoding?token=123</code></p>
<p><img src="/2019/05/30/cloud/cloud-template-api/QQ20190520-125103.png" alt></p>
<h2 id="搭建Config服务"><a href="#搭建Config服务" class="headerlink" title="搭建Config服务"></a>搭建Config服务</h2><h3 id="Server端"><a href="#Server端" class="headerlink" title="Server端"></a>Server端</h3><ol>
<li>在<code>cloud-template</code>下创建文件夹<code>template-config</code></li>
<li>创建<code>pom.xml</code>，主要添加以下两个依赖：</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建配置文件<code>application.yml</code></li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8888</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">template-config</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 获取本地配置文件，本身支持：本地储存、git远程、SVN</span></span><br><span class="line"><span class="attr">  profiles:</span></span><br><span class="line"><span class="attr">    active:</span> <span class="string">native</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    config:</span></span><br><span class="line"><span class="attr">      server:</span></span><br><span class="line">        <span class="comment"># 获取本地配置文件的位置</span></span><br><span class="line"><span class="attr">        native:</span></span><br><span class="line"><span class="attr">          search-locations:</span> <span class="attr">classpath:config/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line">      <span class="comment"># Eureka注册中心连接地址</span></span><br><span class="line">      <span class="comment"># 如果注册中心地址配置的域名，这里使用 http://域名/eureka/ 格式</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8080/eureka/</span></span><br></pre></td></tr></table></figure>

<p>这里使用的本地储存配置文件，也可以采用从远程github、gitlab端读取：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 远程读取</span></span><br><span class="line"><span class="attr">cloud:</span></span><br><span class="line"><span class="attr">  config:</span></span><br><span class="line"><span class="attr">    label:</span> <span class="string">master</span> <span class="comment"># 配置仓库的分支</span></span><br><span class="line"><span class="attr">    server:</span></span><br><span class="line"><span class="attr">      git:</span></span><br><span class="line"><span class="attr">        uri:</span> <span class="attr">https://github.com/xx/spring-cloud-config</span> <span class="comment"># 配置Git仓库地址，如果用Github需要加.git，如果用Gitlab则不需要</span></span><br><span class="line"><span class="attr">        search-paths:</span> <span class="string">respo</span> <span class="comment"># 配置仓库路径</span></span><br><span class="line"><span class="attr">        username:</span> <span class="comment"># 访问Git仓库的账号</span></span><br><span class="line"><span class="attr">        password:</span> <span class="comment"># 访问Git仓库的密码</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>创建该服务的启动器类<code>ConfigApplication.java</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConfigApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>@EnableConfigServer</code>就是开启配置文件服务支持</p>
<ol start="5">
<li>将<code>template-zuul</code>服务的配置文件<code>application.yml</code>拷贝到服务<code>template-zuul</code>的<code>/resources/config</code>目录下，重命名为<code>application-zuul-deb.yml</code>。</li>
<li>重启<code>template-zuul</code>服务，访问<code>localhost:8888/application-zuul/dev</code></li>
</ol>
<p><img src="/2019/05/30/cloud/cloud-template-api/2019052054730.png" alt></p>
<p>如此，就完成了Congi服务端配置。可以看到<code>application-zuul-dev.yml</code>文件中的数据已接口的形式可直接通过请求接口访问。注意主要使用<code>localhost:8888/config/application-zuul-dev.yml</code>访问，这样就相当于访问静态文件了。</p>
<h3 id="Client端"><a href="#Client端" class="headerlink" title="Client端"></a>Client端</h3><p>因为上面我们copy的<code>template-zuul</code>服务的配置文件到<code>template-config</code>服务的<code>/resources/config</code>文件夹下，所以以<code>template-zuul</code>服务举例，让<code>template-zuul</code>服务从<code>template-config</code>分布式配置中心获取配置文件。</p>
<ol>
<li>在<code>template-cloud</code>服务的<code>pom.xml</code>中添加依赖：</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改<code>template-zuul</code>服务的<code>application.yml</code>配置文件：</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span></span><br><span class="line"><span class="attr">    active:</span> <span class="string">native</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    config:</span></span><br><span class="line"><span class="attr">      uri:</span> <span class="attr">http://locahost:8888</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">application-zuul</span></span><br><span class="line"><span class="attr">      profile:</span> <span class="string">dev</span></span><br><span class="line"><span class="comment">#      label:</span></span><br></pre></td></tr></table></figure>

<p>如上，删除了<code>template-zuul</code>服务配置文件中原有的配置，这里仅配置从分布式配置中心<code>template-config</code>服务中读取配置文件信息。相关参数说明：</p>
<ul>
<li><code>spring.cloud.config.uri</code>: 配置服务中心的网址</li>
<li><code>spring.cloud.config.name</code>: 配置文件的前缀名</li>
<li><code>spring.cloud.config.label</code>: 配置仓库的分支。如果是本地读取，可不配置</li>
<li><code>spring.cloud.config.profile</code>: 配置文件的环境标识<ul>
<li><code>dev</code>: 开发环境</li>
<li><code>test</code>: 测试环境</li>
<li><code>prod</code>: 生产环境</li>
</ul>
</li>
</ul>
<ol start="3">
<li>重新启动<code>template-zuul</code>服务，访问：<code>localhost:9003/api/admin/hello/tycoding?token=123</code></li>
</ol>
<p><img src="/2019/05/30/cloud/cloud-template-api/QQ20190520-182552.png" alt></p>
<ol start="4">
<li><p>注意事项：</p>
<p>​    配置服务器的默认端口是 8888， 如果修改了默认端口，则客户端项目中就不能在<code>application.yml</code>或<code>application.properties</code>中配置<code>spring.cloud.config.uri</code>，必须在<code>bootstrap.yml</code>或是<code>bootstrap.properties</code>中配置，原因是<code>bootstrap</code>开头的配置文件会优先加载和配置。</p>
</li>
</ol>
<p><strong>开启Spring Boot Profile</strong></p>
<p>如果项目中分别部署了开发、测试、生产环境的配置文件，但如果切换不同的开发环境就可能要修改对应配置文件中的配置 ( <code>spring.cloud.config.profile</code>的参数值 )，而使用Spring Boot Profile就仅需要在启动项目时指定加载的文件，Spring就会自动加载该配置文件来启动项目。举个栗子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar template-auth-1.0.0-SNAPSHOT.jar --spring.profiles.active=prod</span><br></pre></td></tr></table></figure>

<p>其中<code>--spring.prodiles.active=prod</code>就会自动加载<code>application-auth-prod.yml</code>配置文件</p>
<h2 id="搭建ZipKin服务"><a href="#搭建ZipKin服务" class="headerlink" title="搭建ZipKin服务"></a>搭建ZipKin服务</h2><h3 id="Server端-1"><a href="#Server端-1" class="headerlink" title="Server端"></a>Server端</h3><ol>
<li>在<code>cloud-template</code>下创建文件夹<code>template-zipkin</code></li>
<li>创建<code>pom.xml</code></li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.zipkin.java<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zipkin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.zipkin.java<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zipkin-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-slf4j-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.zipkin.java<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zipkin-autoconfigure-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在父工程<code>pom.xml</code>中添加ZipKin依赖的版本约定：</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Greenwich.SR1<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">zipkin.version</span>&gt;</span>2.10.1<span class="tag">&lt;/<span class="name">zipkin.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>template-eureka<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>template-admin<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>template-auth<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>template-zuul<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>template-config<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>template-zipkin<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.zipkin.java<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zipkin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;zipkin.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.zipkin.java<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zipkin-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;zipkin.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.zipkin.java<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zipkin-autoconfigure-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;zipkin.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>创建该服务的启动器类<code>ZipKinApplication.java</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableZipkinServer</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZipkinApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ZipkinApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>创建配置文件<code>pom.xml</code></li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: template-zipkin</span><br><span class="line"></span><br><span class="line">  # 解决Zipkin启动The bean 'characterEncodingFilter', defined in</span><br><span class="line">  main:</span><br><span class="line">    allow-bean-definition-overriding: true</span><br><span class="line"></span><br><span class="line">server:</span><br><span class="line">  port: 9411</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http://localhost:8080/eureka/</span><br><span class="line"></span><br><span class="line">management:</span><br><span class="line">  metrics:</span><br><span class="line">    web:</span><br><span class="line">      # 解决Zipkin报错IllegalArgumentException: Prometheus requires that all meters</span><br><span class="line">      server:</span><br><span class="line">        auto-time-requests: false</span><br></pre></td></tr></table></figure>

<p>注意：<code>9411</code>是默认端口</p>
<ol start="6">
<li>启动项目，访问：<code>localhost:9411</code></li>
</ol>
<p><img src="/2019/05/30/cloud/cloud-template-api/20190521125746.png" alt></p>
<h3 id="Client端-1"><a href="#Client端-1" class="headerlink" title="Client端"></a>Client端</h3><p>如果需要ZipKin监控所有服务的信息，需要让每个服务都成为ZipKin的服务端。</p>
<p>除了<code>template-zipkin</code>服务本身，其他的服务全都要成为ZipKin的客户端，以下配置需要在每个服务中都添加：</p>
<ol>
<li>修改服务的<code>pom.xml</code></li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改服务的<code>application.yml</code>，如果服务的配置文件从<code>template-config</code>服务中加载的，就直接在<code>template-config</code>中配置该服务：</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  zipkin:</span></span><br><span class="line"><span class="attr">    base-url:</span> <span class="attr">http://localhost:9411</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>按照<code>template-eureka</code>、<code>template-config</code>、<code>template-zipkin</code>、<code>template-admin</code>、<code>template-auth</code>、<code>template-zuul</code>的顺序依次启动所有服务。访问<code>localhost:8080</code>:</li>
</ol>
<p><img src="/2019/05/30/cloud/cloud-template-api/2019052110510.png" alt></p>
<p>访问所有我们之前写好的接口，再访问<code>localhost:9411</code>:</p>
<p><img src="/2019/05/30/cloud/cloud-template-api/2019052110648.png" alt></p>
<p>比如观察<code>localhost:9003/api/auth/hello/tycoding?token=123</code>接口的链路信息：</p>
<p><img src="/2019/05/30/cloud/cloud-template-api/2019052110814.png" alt></p>
<p>参数说明：</p>
<ul>
<li><code>span</code>: 基本工作单元</li>
<li><code>Trace</code>: 一系列Spans组成的树状结构</li>
<li><code>Annotation</code>: 用来即时记录一个时间的存在，比如请求的开始于结束<ul>
<li><code>cs</code>: Client Server，客户端发起一个请求，这个Annotation描述了这个Span的开始</li>
<li><code>sr</code>: Server Received，服务端获取请求并开始处理它。<code>sr - cs</code>得到网络延迟时间</li>
<li><code>ss</code>: Server Sent 请求处理完成，请求返回客户端。<code>ss - sr</code> 得到服务端处理请求的时间</li>
<li><code>cr</code>: Client Received 表明Span的结束，客户端成功接收到服务端的回复。<code>cr - cs</code>得到客户端从服务端获取回复花费的总时间。 </li>
</ul>
</li>
</ul>
<h2 id="搭建SpringBootAdmin服务"><a href="#搭建SpringBootAdmin服务" class="headerlink" title="搭建SpringBootAdmin服务"></a>搭建SpringBootAdmin服务</h2><h3 id="Server端-2"><a href="#Server端-2" class="headerlink" title="Server端"></a>Server端</h3><ol>
<li>在<code>cloud-template</code>下创建<code>template-boot-admin</code>文件夹</li>
<li>在<code>template-boot-admin</code>下创建<code>pom.xml</code></li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jolokia<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jolokia-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-starter-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>和ZipKin一样，SpringBootAdmin不受SpringCloud管理，所以要手动管理版本。修改父工程<code>pom.xml</code>:</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring-boot-admin.version</span>&gt;</span>2.1.5<span class="tag">&lt;/<span class="name">spring-boot-admin.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-starter-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot-admin.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-starter-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot-admin.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>创建配置文件：<code>application.yml</code></li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">9004</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">template-boot-admin</span></span><br><span class="line"><span class="attr">  zipkin:</span></span><br><span class="line"><span class="attr">    base-url:</span> <span class="attr">http://localhost:9411</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line">      <span class="comment"># Eureka注册中心连接地址</span></span><br><span class="line">      <span class="comment"># 如果注册中心地址配置的域名，这里使用 http://域名/eureka/ 格式</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8080/eureka/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line"><span class="attr">  endpoint:</span></span><br><span class="line"><span class="attr">    health:</span></span><br><span class="line"><span class="attr">      show-details:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">  endpoints:</span></span><br><span class="line"><span class="attr">    web:</span></span><br><span class="line"><span class="attr">      exposure:</span></span><br><span class="line"><span class="attr">        include:</span> <span class="string">health,info</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>创建该服务的启动器类：<code>BootAdminApplication.java</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableAdminServer</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BootAdminApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(BootAdminApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Client端-2"><a href="#Client端-2" class="headerlink" title="Client端"></a>Client端</h3><p>和ZipKin一样，如果需要SpringBootAdmin监控所有服务，就必须让所有服务都成为SpringBootAdmin的客户端。除了<code>template-boot-admin</code>服务本身，其他所有的服务都执行下列配置：</p>
<ol>
<li>修改<code>pom.xml</code>，添加如下配置</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-starter-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改<code>application.yml</code>，添加如下配置。如果服务的配置加载于Config配置中心，就修改配置中心的配置文件。</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  boot:</span></span><br><span class="line"><span class="attr">    admin:</span></span><br><span class="line"><span class="attr">      client:</span></span><br><span class="line"><span class="attr">        url:</span> <span class="attr">http://localhost:9004</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>按照<code>template-eureka</code>、<code>template-config</code>、<code>template-zipkin</code>、<code>template-boot-admin</code>、<code>template-admin</code>、<code>template-auth</code>、<code>template-zuul</code> 顺序依次启动服务。</p>
<p>如果启动<code>template-boot-admin</code>服务时遇到下列错误：</p>
</li>
</ol>
<p><img src="/2019/05/30/cloud/cloud-template-api/QQ20190521-141906.png" alt></p>
<p>​        为该服务执行<code>mvn clean package</code>命令即可：</p>
<p><img src="/2019/05/30/cloud/cloud-template-api/QQ20190521-143322.png" alt></p>
<p>最后启动完成，访问<code>localhost:8004</code></p>
<p><img src="/2019/05/30/cloud/cloud-template-api/2019052124045.png" alt></p>
<br>

<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <categories>
        <category>spring-cloud</category>
      </categories>
      <tags>
        <tag>spring-cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud Template微服务前端</title>
    <url>/2019/05/30/cloud/cloud-template-app/</url>
    <content><![CDATA[<h1 id="Spring-Cloud-Template-分布式微服务系统-–-前端"><a href="#Spring-Cloud-Template-分布式微服务系统-–-前端" class="headerlink" title="Spring Cloud Template 分布式微服务系统 – 前端"></a>Spring Cloud Template 分布式微服务系统 – 前端</h1><p>项目地址：<a href="https://github.com/TyCoding/cloud-template" target="_blank" rel="noopener">Spring-Cloud-Template</a> 欢迎star, fork支持作者</p>
<p><strong>注意</strong></p>
<p>请仔细阅读<code>vue-admin-template</code>项目官方文档：<a href="https://panjiachen.gitee.io/vue-element-admin-site/zh/guide/" target="_blank" rel="noopener">传送门</a></p>
<p>如何食用 <code>vue-admin-template</code> 前端模板？</p>
<a id="more"></a>

<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><blockquote>
<p>因为该模板用mock模拟了前端所需数据，首先要删除mock相关的配置</p>
</blockquote>
<ul>
<li>删除<code>mock</code>文件夹</li>
<li>删除<code>/src/main.js</code>下这段代码：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mockXHR &#125; <span class="keyword">from</span> <span class="string">'../mock'</span></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'production'</span>) &#123;</span><br><span class="line">  mockXHR()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>删除<code>vue-config.js</code>下这段代码：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">after: <span class="built_in">require</span>(<span class="string">'./mock/mock-server.js'</span>)</span><br></pre></td></tr></table></figure>

<p>全局配置后端接口URL，以下配置文件中都存在一个<code>VUE_APP_BASE_API</code>配置，他指定了后端请求的URL根路径。比如我们后端的请求都是<code>http://localhost:9999/api/xx</code>的，所以可设置<code>VUE_APP_BASE_API=&#39;http://localhost:9999/api/&#39;</code>，其中<code>/xx</code>具体的接口请求放在<code>/src/api/*.js</code>中。</p>
<ul>
<li><code>.env.development</code>: 即<code>dev</code>开发环境</li>
<li><code>.env.production</code>: 即<code>prod</code>生产环境</li>
<li><code>.env.staging</code>: 即<code>mock</code>模拟环境</li>
</ul>
<p>注意：在SpringCloud微服务项目中，前端的所有请求都应该走Gateway网关服务的URL地址。</p>
<h3 id="取消ESLint校验"><a href="#取消ESLint校验" class="headerlink" title="取消ESLint校验"></a>取消ESLint校验</h3><p>在你开发项目中可能遇到前端莫名其妙报错语法不对，比如多一个空格、冒号啥的，这都是因为<code>vue-admin-template</code>这个模板启用了ESLint最严格模式，其实我们关闭ESLint检查即可：</p>
<p>修改<code>vue.config.js</code>中如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修改前：</span><br><span class="line">  lintOnSave: process.env.NODE_ENV === &apos;development&apos;,</span><br><span class="line">  </span><br><span class="line">修改后：</span><br><span class="line">  lintOnSave: false,</span><br></pre></td></tr></table></figure>

<h2 id="登录功能"><a href="#登录功能" class="headerlink" title="登录功能"></a>登录功能</h2><p>拿到的项目模板，首先需要解决的就是登录功能。按照 <a href="https://panjiachen.gitee.io/vue-element-admin-site/zh/guide/" target="_blank" rel="noopener">vue-admin-template</a> 官方文档的描述，所有的请求都将经过如下流程：</p>
<pre><code>1. `.vue` 首先是Vue组件内部发送了请求
 2. `src/utils/request.js` 作者对 axios 请求全局的封装
 3. `src/api/xx.js` vue组件使用的接口地址，配合`request.js`完成axios请求与相应
 4. `src/store/modules/user.js` 这个尤为重要，登录接口不同于其他接口，当登录成功后，需要使用vuex将登录接口响应的数据保存，以便维持与后端的会话通信。</code></pre><p>那么，登录功能不同于其他的CRUD业务流程，在<code>vue-admin-template</code>中登录需要后台提供：</p>
<ol>
<li>登录接口</li>
<li>获取用户信息接口</li>
</ol>
<p>这刚好符合了我们使用的Security-OAuth2框架。在Security-OAuth2框架汇总，默认提供了获取Token的接口(登录接口)，我们仅需要调用这个接口即可实现登录。</p>
<h3 id="登录接口"><a href="#登录接口" class="headerlink" title="登录接口"></a>登录接口</h3><p>如果你对Security-OAuth2还不熟悉，建议看下我之前写的文档：</p>
<ol>
<li><a href="https://www.tycoding.cn/2019/04/22/boot/spring-boot-security-oauth2-start/">Spring Security OAuth2概念引入</a></li>
<li><a href="https://tycoding.cn/2019/04/22/boot/spring-boot-security-oauth2/" target="_blank" rel="noopener">Spring Security OAuth2实战</a></li>
<li><a href="https://www.tycoding.cn/2019/04/23/boot/spring-boot-security-oauth2-db/">Spring Security OAuth2数据持久化</a></li>
</ol>
<p>Security-OAuth2中提供的默认获取Token的接口：<code>/oauth/token</code>，下面是使用Postman工具模拟请求的示例图：</p>
<p><img src="/2019/05/30/cloud/cloud-template-app/2019052872704.png" alt></p>
<p><img src="/2019/05/30/cloud/cloud-template-app/2019052872808.png" alt></p>
<p><img src="/2019/05/30/cloud/cloud-template-app/2019052872828.png" alt></p>
<blockquote>
<p>  <code>/oauth/token</code>接口是谁提供的？</p>
</blockquote>
<p>​        切记，<code>/oauth/token</code>接口是Security-OAuth2内部提供的获取Token的接口，这个接口不需要我们手动定义，并且即使使用了Spring Security，<code>/oauth</code>开头的接口也应为是内置的不会被拦截，所以我们也无需特殊配置Spring Security 不拦截这个接口。</p>
<blockquote>
<p>  <code>/oauth/token</code>登录请求需要传入什么参数？</p>
</blockquote>
<p>​        关于这点可以看下我的 <a href="https://tycoding.cn/" target="_blank" rel="noopener">博客</a> 中之前介绍OAuth2的文章。我们需要手动提供：</p>
<ol>
<li><code>username</code> 登录账户</li>
<li><code>password</code> 登录密码。这并不是必须的，但由于我们使用的OAuth的<strong>密码</strong>模式，所以需要定义</li>
<li><code>grant_type</code> 因为我们使用的OAuth2的密码模式，可直接定义为<code>grant_type=password</code></li>
<li>Request Headers &gt;&gt; <code>Authorization</code> 注意这个是客户端账户密码信息，对应了后端<code>ClientDetails</code>中查询的数据</li>
</ol>
<blockquote>
<p>  <code>/oauth/token</code> 响应什么数据？</p>
</blockquote>
<p>​        如上图，请求一般响应如下信息：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"access_token"</span>: <span class="string">"f59359c1-86c0-48a3-b060-ff97e5163bb2"</span>,</span><br><span class="line">    <span class="attr">"token_type"</span>: <span class="string">"bearer"</span>,</span><br><span class="line">    <span class="attr">"expires_in"</span>: <span class="number">22531</span>,</span><br><span class="line">    <span class="attr">"scope"</span>: <span class="string">"app"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>access_token</code> 尤为重要，后面所有的请求都需要携带这个Token值才能正常访问，否则就403拒绝。所以，在<code>vue-admin-template</code>项目中，一旦登录接口响应成功，会将返回的Token信息全局设置再请求头中，这样以后所有的请求中都携带这个请求都信息。具体可以看：<code>src/utils/request.js</code>中这段代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">config.headers[<span class="string">'Authorization'</span>] = getToken()</span><br></pre></td></tr></table></figure>

<p>这是全局配置axios实例，因为所有的API请求都需要经过这个<code>request.js</code>文件，所以其中的配置项对所有的请求都有效。</p>
<blockquote>
<p>  <code>vue-admin-template</code>中如何处理登录接口响应的数据？</p>
</blockquote>
<p>​        看完上面的配置，你觉得已经能完成前端的登录功能了？那你就错了。上面仅仅介绍了使用Postman工具模拟测试，而在<code>vue-admin-template</code>项目中，如果请求<code>/oauth/token</code>接口正常响应数据，需要将响应的数据储存到vuex中。那么主要涉及<code>src/store/modules/user.js</code>中的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">  <span class="comment">// user login</span></span><br><span class="line">  login(&#123; commit &#125;, userInfo) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; username, password &#125; = userInfo</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      login(&#123; <span class="attr">username</span>: username.trim(), <span class="attr">password</span>: password &#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        commit(<span class="string">'SET_TOKEN'</span>, response.access_token)</span><br><span class="line">        setToken(response.token_type + <span class="string">' '</span> + response.access_token)</span><br><span class="line">        resolve()</span><br><span class="line">      &#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// get user info</span></span><br><span class="line">  getInfo(&#123; commit, state &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      getInfo(state.token).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; data &#125; = response</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">          reject(<span class="string">'Verification failed, please Login again.'</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> &#123; name, avatar &#125; = data</span><br><span class="line"></span><br><span class="line">        commit(<span class="string">'SET_NAME'</span>, name)</span><br><span class="line">        commit(<span class="string">'SET_AVATAR'</span>, avatar)</span><br><span class="line">        resolve(data)</span><br><span class="line">      &#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// user logout</span></span><br><span class="line">  logout(&#123; commit, state &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      logout(state.token).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        commit(<span class="string">'SET_TOKEN'</span>, <span class="string">''</span>)</span><br><span class="line">        removeToken()</span><br><span class="line">        resetRouter()</span><br><span class="line">        resolve()</span><br><span class="line">      &#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// remove token</span></span><br><span class="line">  resetToken(&#123; commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      commit(<span class="string">'SET_TOKEN'</span>, <span class="string">''</span>)</span><br><span class="line">      removeToken()</span><br><span class="line">      resolve()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码才是登录、获取用户信息、注销功能实现的核心代码。其实就是利用<code>src/api/xx.js</code>中定义的接口方法发送axios请求。然后将响应response数据处理一下。</p>
<p>比如上面代码中，<code>login()</code>方法就是登录接口放他，它实际请求了<code>/oauth/token</code>接口，前面提到每次请求都需要携带<code>access_token</code>，所以需要vuex储存token信息(<code>setToken(token)</code>)，以便在<code>request.js</code>中使用<code>config.headers[]</code>全局定义请求头信息。</p>
<blockquote>
<p>  在Postman中设置的<code>Basic Auth</code>，在此项目中在哪体现呢？</p>
</blockquote>
<p>​        当然，按照OAuth2协议的规定，想要获取应用信息必须先请求<code>/oauth/token</code>获取令牌Token值，而想要获取令牌Token除了<code>username</code> <code>password</code> <code>grant_type</code>信息，还要告诉OAuth2这是哪个客户端的请求，所以在请求<code>/oauth/token</code>接口时需要携带客户端信息。</p>
<p>​        这一点在 <a href="https://tycoding.cn/2019/04/22/boot/spring-boot-security-oauth2/" target="_blank" rel="noopener">Spring Security OAuth2实战</a> 一文中我有详细介绍过。所以在<code>vue-admin-template</code>前端项目中，想要实现所有请求都携带客户端信息，就需要全局设置请求头参数，所以，我们直接在 <code>src/main.js</code> 中全局设置Axios 默认请求头参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line">axios.defaults.headers.post[<span class="string">'Authorization'</span>] = <span class="string">'Basic Y2xpZW50OnNlY3JldA=='</span>;</span><br></pre></td></tr></table></figure>

<p>上面设置了一个请求头参数<code>Authorization</code>，他的值是对<code>username: client, password: 123456</code>即<code>client:123456</code>按照Base64加密后的值。因为整个项目仅仅是个人使用的，所以这个写死也并无大碍，毕竟数据库中写死了客户端信息。</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>上面基本介绍了登录请求的流程和注意事项，下面使用浏览器F12看一下实际的请求信息：</p>
<p><img src="/2019/05/30/cloud/cloud-template-app/2019052880003.png" alt></p>
<p><img src="/2019/05/30/cloud/cloud-template-app/2019052880030.png" alt></p>
<p>如果登录请求响应成功，想要进入系统的第二关就是调用获取用户信息的接口，全局设置用户信息(用户名、头像…) 。所以，<code>vue-admin-template</code>会立即再请求获取用户信息的接口：</p>
<p><img src="/2019/05/30/cloud/cloud-template-app/2019052880107.png" alt></p>
<p>可看到，如果登录成功，可携带<code>access_token</code>访问应用的其他接口，只需要在请求时将请求头<code>Authorization</code>设置为<code>access_token</code>信息即可。</p>
<h2 id="CRUD业务"><a href="#CRUD业务" class="headerlink" title="CRUD业务"></a>CRUD业务</h2><p>一旦解决了登录功能，相信你对<code>vue-admin-template</code>这个前端模板项目有一定理解了，后端其他的业务也相对简单很多了。涉及Axios请求部分，只需要关注：</p>
<ol>
<li><code>src/views</code> 下定义 <code>.vue</code> 组件</li>
<li><code>src/api</code> 下定义API接口信息</li>
</ol>
<h3 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h3><p>举例：根据ID获取用户信息的功能</p>
<ol>
<li>在<code>src/api/user.js</code>中定义根据ID获取用户信息的API接口</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">findById</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> request(&#123;</span><br><span class="line">    url: <span class="string">'/admin/user/'</span> + id,</span><br><span class="line">    method: <span class="string">'get'</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在<code>.vue</code>组件中使用这个API接口</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;el-table-column align=<span class="string">"center"</span> label=<span class="string">"Actions"</span>&gt;</span><br><span class="line">	&lt;template slot-scope=<span class="string">"scope"</span>&gt;</span><br><span class="line">		&lt;el-button type=<span class="string">"danger"</span> @click=<span class="string">"handleDel(scope.row.id)"</span> icon=<span class="string">"el-icon-delete"</span> size=<span class="string">"mini"</span>&gt;删除&lt;<span class="regexp">/el-button&gt;</span></span><br><span class="line"><span class="regexp">	&lt;/</span>template&gt;</span><br><span class="line">&lt;<span class="regexp">/el-table-column&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">  import &#123; findById &#125; from '@/</span>api/user<span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  export default &#123;</span></span><br><span class="line"><span class="string">    components: &#123;Pagination, Save&#125;,</span></span><br><span class="line"><span class="string">    data() &#123;</span></span><br><span class="line"><span class="string">      return &#123;</span></span><br><span class="line"><span class="string">        form: null,</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    methods: &#123;</span></span><br><span class="line"><span class="string">      handleEdit(id) &#123;</span></span><br><span class="line"><span class="string">        findById(id).then(response =&gt; &#123;</span></span><br><span class="line"><span class="string">          this.form = response.data;</span></span><br><span class="line"><span class="string">        &#125;)</span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>以上即可实现根据ID查询用户信息的功能，是不是很简单呢？</p>
<h2 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h2><p>如果没有使用Vue+ElementUI实现分页查询经验的朋友可以先看下我的这篇文章：</p>
<p><a href="https://www.tycoding.cn/2018/07/30/vue/vue-6/">Vue+ElementUI+SpringMVC实现分页</a></p>
<p><code>vue-admin-template</code>的作者其实提供好了一个<code>pagination</code>分页组件，是对Element-UI的<code>&lt;el-pagination&gt;</code>控件的封装。作者封装的这个组件是通用的，可以在项目的任何需要分页的位置使用，非常方便。如何食用呢？</p>
<ol>
<li>在<code>src/components</code>下引入该组件</li>
</ol>
<p><img src="/2019/05/30/cloud/cloud-template-app/20190528211740.png" alt></p>
<ol start="2">
<li>在<code>src/api/user.js</code>中定义分页查询接口</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getList</span>(<span class="params">query, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> request(&#123;</span><br><span class="line">    url: <span class="string">'/admin/user/list?pageCode='</span> + query.page + <span class="string">'&amp;pageSize='</span> + query.limit,</span><br><span class="line">    method: <span class="string">'post'</span>,</span><br><span class="line">    data</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传递三个参数：<code>pageCode</code>当前页码、<code>pageSize</code>每页多少记录、<code>data</code>查询条件</p>
<ol start="3">
<li>在需要使用分页的组件中引入该分页组件</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;pagination v-show=<span class="string">"total&gt;0"</span> :total=<span class="string">"total"</span> :page.sync=<span class="string">"listQuery.page"</span> :limit.sync=<span class="string">"listQuery.limit"</span></span><br><span class="line">            @pagination=<span class="string">"fetchData"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">pagination</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">import</span> &#123;getList&#125; <span class="keyword">from</span> <span class="string">'@/api/user'</span></span><br><span class="line">  <span class="keyword">import</span> Pagination <span class="keyword">from</span> <span class="string">'@/components/Pagination'</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    components: &#123;Pagination&#125;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        list: <span class="literal">null</span>,</span><br><span class="line">        search: &#123;&#125;,</span><br><span class="line">        listQuery: &#123;</span><br><span class="line">          page: <span class="number">1</span>,</span><br><span class="line">          limit: <span class="number">20</span>,</span><br><span class="line">          importance: <span class="literal">undefined</span>,</span><br><span class="line">          title: <span class="literal">undefined</span>,</span><br><span class="line">          type: <span class="literal">undefined</span>,</span><br><span class="line">          sort: <span class="string">'+id'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        total: <span class="number">0</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    created() &#123;</span><br><span class="line">      <span class="keyword">this</span>.fetchData()</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      fetchData() &#123;</span><br><span class="line">        getList(<span class="keyword">this</span>.listQuery, <span class="keyword">this</span>.search).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.list = response.data.rows</span><br><span class="line">          <span class="keyword">this</span>.total = response.data.total</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以看到上面传递了两个参数：<code>listQuery</code>分页条件、<code>search</code>查询条件。</p>
<p>也就是说分页查询：</p>
<ul>
<li>前端需要传递的参数：<code>pageCode</code>: 当前页码、<code>pageSize</code>：每页多少条记录。如果需要条件查询再传递查询条件</li>
<li>后端需要返回的参数：<code>total</code>：数据库总记录数、<code>List&lt;T&gt;</code>：封装了查询到的数据集合</li>
</ul>
<p>可以看下后端的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Controller</span></span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/list"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result&lt;Map&gt; <span class="title">list</span><span class="params">(SysUser user, QueryPage queryPage)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Result&lt;Map&gt;(<span class="keyword">this</span>.selectByPageNumSize(queryPage, () -&gt; sysUserService.list(user)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// QueryPage</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueryPage</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> pageCode; <span class="comment">//当前页</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> pageSize; <span class="comment">//每页显示的记录数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="组件传值"><a href="#组件传值" class="headerlink" title="组件传值"></a>组件传值</h2><p>实际项目中，经常使用组件传值。比如：用户管理模块中，编辑功能通常需要一个弹出窗，而这个弹出窗通常是抽取在另外一个组件中，这样就涉及到了父组件 ( 用户管理组件 ) 和子组件 ( 编辑功能组件 ) 的通信；简单来说，在用户管理组件中需要控制编辑功能弹出框的弹出和关闭等操作。</p>
<h3 id="概念引入"><a href="#概念引入" class="headerlink" title="概念引入"></a>概念引入</h3><h4 id="父组件向子组件传值"><a href="#父组件向子组件传值" class="headerlink" title="父组件向子组件传值"></a>父组件向子组件传值</h4><p>比如在父组件中定义子组件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;son :info=<span class="string">"msg"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">son</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<p>那么在组件中获取到这个<code>info</code>中的数据：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;&#125;,</span><br><span class="line">props: [<span class="string">'info'</span>]</span><br></pre></td></tr></table></figure>

<p>即可获取到父组件传递来的数据，注意：这个<code>props</code>属于<code>new vue()</code>根路径下的属性，不属于<code>data</code>。如果获取父组件传进来的多个擦书，使用逗号隔开即可获取。</p>
<h4 id="子组件向父组件传值"><a href="#子组件向父组件传值" class="headerlink" title="子组件向父组件传值"></a>子组件向父组件传值</h4><p>在父组件中定义：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;son @func=<span class="string">"getMsg"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">son</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Vue实例</span></span><br><span class="line">methods: &#123;</span><br><span class="line">  <span class="comment">//父组件注册的方法，子组件通过`this.$emit()`的方式调用这个方法将参数传递给父组件的val。</span></span><br><span class="line">  getMsg(val) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"这是子组件传递来的数据："</span> + val);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么在子组件中通过<code>this.$emit(&#39;方法名&#39;, 要传递的数据)</code>的方式调用父组件中的方法，传递数据。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">"button"</span> value=<span class="string">"向父组件传值"</span> @click=<span class="string">"sendMsg"</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Vue实例</span></span><br><span class="line">methods: &#123;</span><br><span class="line">  sendMsg() &#123;</span><br><span class="line">      <span class="keyword">this</span>.$emit(<span class="string">'func'</span>, <span class="string">'我是来自子组件的数据'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="refs"><a href="#refs" class="headerlink" title="$refs"></a>$refs</h4><p><code>this.$refs</code>可以获取元素和组件（以及组件中的元素）。</p>
<ul>
<li>如果在HTML中定义了 <code>ref=&quot;xx&quot;</code> 那么在Vue实例中通过<code>this.$refs.xx</code>就能获取到当前定义<code>ref=&quot;xx&quot;</code>的DOM元素。</li>
<li>如果在组件引用上（比如<code>&lt;son ref=&quot;xx&quot;&gt;</code>）上使用了<code>ref</code>，那么在父组件Vue实例中通过<code>this.$refs</code>获取到的是整个子组件的对象，可以通过<code>.</code>的方式调用子组件<code>data</code>和<code>methods</code>中绑定数据。</li>
</ul>
<h3 id="栗子-1"><a href="#栗子-1" class="headerlink" title="栗子"></a>栗子</h3><ol>
<li>除了创建用户管理的组件，新增一个封装了用户信息编辑框的组件：</li>
</ol>
<p><img src="/2019/05/30/cloud/cloud-template-app/20190528213839.png" alt></p>
<p>其中的<code>save.vue</code>就是封装了用户信息编辑框的组件。</p>
<ol start="2">
<li>在用户管理组件中引入用户信息编辑框的组件</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;save :sonData=<span class="string">"form"</span> @sonStatus=<span class="string">"status"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">save</span>&gt;</span></span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">import</span> Save <span class="keyword">from</span> <span class="string">'./save'</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    components: &#123;Save&#125;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        form: <span class="literal">null</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    created() &#123;</span><br><span class="line">      <span class="keyword">this</span>.fetchData()</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      fetchData() &#123;</span><br><span class="line">        getList(<span class="keyword">this</span>.search).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">      handleEdit(id) &#123;</span><br><span class="line">        findById(id).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.form = response.data;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="comment">//子组件的状态Flag，子组件通过`this.$emit('sonStatus', val)`给父组件传值</span></span><br><span class="line">      <span class="comment">//父组件通过`@sonStatus`的方法`status`监听到子组件传递的值</span></span><br><span class="line">      status(data) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data) &#123;</span><br><span class="line">          <span class="keyword">this</span>.fetchData();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>如上，如果父组件<code>index.vue</code>想要给子组件<code>save.vue</code>传值，比如修改信息会在父组件<code>index.vue</code>中触发编辑按钮，触发事件去根据ID查询该用户信息，让后将信息绑定到子组件<code>save.vue</code>模态框上，最后在编辑模态框上修改完了用户数据，点击确定按钮提交修改后的数据，如此编辑功能就实现了。</p>
<p>So</p>
<p>父组件<code>index.vue</code>给子组件<code>save.vue</code>传递值，仅需要在子组件的实例上写 <code>:aa=&quot;bb&quot;</code> 即可，其中：</p>
<ul>
<li><code>aa</code>是传递的数据的key值，在子组件<code>save.vue</code>中可用<code>props: [&#39;aa&#39;]</code>接收到。( 实时监听 )</li>
<li><code>bb</code>是value值，可以是任意对象。( 实时更新，实时传递给子组件 )</li>
</ul>
<p>子组件可通过<code>props: [&#39;aa&#39;]</code>得到父组件传递的数据，但是要实时绑定到<code>save.vue</code>修改信息的表单上还需要监听一下，所以在子组件上：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//`props`不属于data，但是`props`中的参数可以像data中的参数一样直接使用</span></span><br><span class="line">props: [<span class="string">'sonData'</span>],</span><br><span class="line">    </span><br><span class="line">watch: &#123;</span><br><span class="line">  <span class="string">'sonData'</span>: <span class="function"><span class="keyword">function</span> (<span class="params">newVal, oldVal</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.form = newVal</span><br><span class="line">    <span class="keyword">this</span>.dialogVisible = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (newVal.id != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.dialogTitle = <span class="string">'Edit'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>如果父组件传递的值<code>sonData</code>改变了，就证明用户点击了编辑/新增按钮，立即将传递来的值绑定到表单对象<code>form</code>上，并打开模块框<code>diaalogVisible=true</code></p>
<p>如果子组件<code>save.vue</code>编辑完用户数据并更新了，按照常理，此时应该立即刷新用户列表数据以获取最新的数据。那么就涉及到子组件<code>save.vue</code>给父组件<code>index.vue</code>传值。</p>
<p>So</p>
<p>子组件<code>save.vue</code>给父组件<code>index.vue</code>传递值，仅需要在父组件<code>index.vue</code>上定义的子组件<code>save.vue</code>实例上写：<code>@sonStatus=&quot;status&quot;</code>，这就实现子组件给父组件传递值<code>status</code>：</p>
<ul>
<li>在子组件<code>save.vue</code>中写<code>this.$emit(&#39;sonStatus&#39;, val)</code>会立即改变父组件<code>index.vue</code>中绑定的对象<code>status</code></li>
<li>在父组件<code>index.vue</code>中子组件传递值实际绑定的是一个方法<code>status</code>，这个方法传递一个值也是子组件传递来的值</li>
</ul>
<p>子组件通过<code>this.$emit(&#39;sonStatus&#39;, val)</code>会强制父组件<code>index.vue</code>中改变绑定的值，是实时监听的。而父组件<code>index.vue</code>对应绑定的是一个方法对象<code>status()</code>，不同于父组件给子组件传值，子组件给父组件传值通过方法对象绑定，这个方法就相当于<code>watch</code>实时监听值的改变。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">status(data) &#123;</span><br><span class="line">  <span class="keyword">if</span> (data) &#123;</span><br><span class="line">    <span class="keyword">this</span>.fetchData();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>如上，一旦子组件告诉父组件，我已经修改了数据，你需要更新了。此时父组件的<code>status</code>方法会立即鉴定到值的变化并立即触发传方法<code>fetchData()</code>刷新表格数据。</p>
<h2 id="左侧路由导航"><a href="#左侧路由导航" class="headerlink" title="左侧路由导航"></a>左侧路由导航</h2><p><code>vue-admin-template</code>中作者也封装了路由和侧边栏，具体介绍看作者的这篇文章：<a href="https://panjiachen.gitee.io/vue-element-admin-site/zh/guide/essentials/router-and-nav.html" target="_blank" rel="noopener">路由和侧边栏</a></p>
<p>如果我们想增加组件 ( 页面 )，需要以下几步即可实现：</p>
<ol>
<li>在<code>src/views/</code>下新增一个<code>.vue</code>组件</li>
</ol>
<p><img src="/2019/05/30/cloud/cloud-template-app/20190529084410.png" alt></p>
<ol start="2">
<li>在<code>src/router/index.js</code>下新增一条路由：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: <span class="string">'/admin'</span>,</span><br><span class="line">  component: Layout,</span><br><span class="line">  redirect: <span class="string">'/admin/user'</span>,</span><br><span class="line">  name: <span class="string">'权限管理'</span>,</span><br><span class="line">  meta: &#123; <span class="attr">title</span>: <span class="string">'权限管理'</span>, <span class="attr">icon</span>: <span class="string">'example'</span> &#125;,</span><br><span class="line">  children: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'user'</span>,</span><br><span class="line">      name: <span class="string">'用户管理'</span>,</span><br><span class="line">      component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/views/user/index'</span>),</span><br><span class="line">      meta: &#123; <span class="attr">title</span>: <span class="string">'用户管理'</span>, <span class="attr">icon</span>: <span class="string">'table'</span> &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>如上，一旦在<code>router/index.js</code>中新增了一条路由导航，侧边栏会自动渲染一个导航。其中：</p>
<ul>
<li><code>path</code> 该路由的URL相对地址</li>
<li><code>component</code> 展示在哪个组件上，<code>src/layout</code>是整个前端项目的布局骨架，所以所有的子组件都要显示在该骨架上</li>
<li><code>children</code> 二级导航目录，如果不需要二级目录，就无需定义此节点</li>
<li><code>component =&gt; import</code> 该路由对应的组件位置 </li>
</ul>
<br>

<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <categories>
        <category>spring-cloud</category>
      </categories>
      <tags>
        <tag>spring-cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Security OAuth2数据持久化</title>
    <url>/2019/04/23/boot/spring-boot-security-oauth2-db/</url>
    <content><![CDATA[<p>在上一篇文章 <a href="https://tycoding.cn/2019/04/22/boot/spring-boot-security-oauth2/" target="_blank" rel="noopener">Spring Security OAuth2实战</a> 中我们尝试配置了一个最基础的Security OAuth2环境，但其中的用户数据都是模拟储存在内存中的，而实际开发中，这些数据应该是从数据库中获取的。这次我们就结合数据库、Redis进一步配置Security OAuth2环境。</p>
<p>:tada: :tada: :tada: <strong>这里有丰富的 Spring 框架学习案例</strong></p>
<p><strong>仓库地址：<a href="https://github.com/TyCoding/spring-learn" target="_blank" rel="noopener">spring-learn</a></strong><br><strong>欢迎star、fork，给作者一些鼓励</strong></p>
<a id="more"></a>

<h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security.oauth.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-oauth2-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 将token存储在redis中 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong> 在使用的<code>spring-security-oauth2-autoconfigure</code>依赖和<code>spring-boot-starter-data-redis</code>实现将Token持久化到Redis数据库如果会遇到错误：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Caused by: java.lang.NoSuchMethodError: org.springframework.data.redis.connection.RedisConnection.set([B[B)V</span><br></pre></td></tr></table></figure>

<p>报错大概就是说没有<code>set</code>方法，导致Token数据不能持久化到Redis中，通常是因为版本较老的原因，这好像是老版本的一个BUG，但是这在新版本中已经修复的。</p>
<h2 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  datasource:</span></span><br><span class="line"><span class="attr">    url:</span> <span class="attr">jdbc:mysql://127.0.0.1:3306/springboot_oauth2?useUnicode=true&amp;characterEncoding=UTF-8</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">    driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  redis:</span></span><br><span class="line"><span class="attr">    host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">6379</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#mybatis配置</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line"><span class="attr">  mapper-locations:</span> <span class="attr">classpath:mapper/**/*.xml</span></span><br><span class="line"><span class="attr">  type-aliases-package:</span> <span class="string">cn.tycoding.entity</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印sql</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line"><span class="attr">  level:</span></span><br><span class="line">    <span class="string">cn.tycoding.mapper:</span> <span class="string">DEBUG</span></span><br></pre></td></tr></table></figure>

<p>创建数据库：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> springboot_oauth2 <span class="keyword">CHARSET</span> utf8;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`sys_user`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line">  <span class="string">`username`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户名'</span>,</span><br><span class="line">  <span class="string">`password`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'密码'</span>,</span><br><span class="line">  <span class="string">`salt`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'随机盐'</span>,</span><br><span class="line">  <span class="string">`authorities`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'模拟权限列表'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">2</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`sys_user`</span> <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="string">'tycoding'</span>, <span class="string">'123'</span>, <span class="string">''</span>, <span class="string">'ADMIN'</span>);</span><br></pre></td></tr></table></figure>

<h2 id="findByUsername"><a href="#findByUsername" class="headerlink" title="findByUsername"></a>findByUsername</h2><h3 id="Entity"><a href="#Entity" class="headerlink" title="Entity"></a>Entity</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SysUser</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ID主键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 密码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 随机盐</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String salt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 权限，这里是方便模拟，其实应该从另一张表中获取</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String authorities;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from sys_user where username = #&#123;username&#125;"</span>)</span><br><span class="line">    <span class="function">SysUser <span class="title">findByUsername</span><span class="params">(String username)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"cn.tycoding.mapper.UserMapper"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据用户名查询</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">SysUser <span class="title">findByUsername</span><span class="params">(String username)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ServiceImpl"><a href="#ServiceImpl" class="headerlink" title="ServiceImpl"></a>ServiceImpl</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SysUser <span class="title">findByUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.findByUsername(username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello, this is test interface"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/info/&#123;name&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">info</span><span class="params">(@PathVariable String name)</span> </span>&#123;</span><br><span class="line">        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello "</span> + name + <span class="string">", this your info"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结"><a href="#结" class="headerlink" title="结"></a>结</h3><p>自此，<code>findByUsername</code>根据用户名查询用户数据的逻辑已经完成，很简单的逻辑，不再介绍</p>
<h2 id="Security-Config"><a href="#Security-Config" class="headerlink" title="Security Config"></a>Security Config</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过HttpSecurity实现Security的自定义过滤配置</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> http</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">"/hello"</span>)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .anyRequest()</span><br><span class="line">                .authenticated()</span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注入AuthenticationManager接口，启用OAuth2密码模式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationManager <span class="title">authenticationManager</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.authenticationManager();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在之前我们是重写<code>userDetailsService()</code>方法，模拟在内存中创建一个用户，然后将这个配置方法注入到Spring IOC容器中。但其实这种方式不是必须的，我们只需要向Spring IOC容器中注入一个实现了<code>UserDetailsService</code>接口的实现类就行了。而本例中我们从数据库中查询用户数据，所以这里不再模拟向内存中储存用户数据。</p>
<h2 id="AuthorizationServerConfig"><a href="#AuthorizationServerConfig" class="headerlink" title="AuthorizationServerConfig"></a>AuthorizationServerConfig</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAuthorizationServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizationServerConfig</span> <span class="keyword">extends</span> <span class="title">AuthorizationServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisConnectionFactory redisConnectionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        clients.inMemory().withClient(<span class="string">"client_1"</span>)</span><br><span class="line">                .authorizedGrantTypes(<span class="string">"client_credentials"</span>, <span class="string">"password"</span>, <span class="string">"refresh_token"</span>)</span><br><span class="line">                .scopes(<span class="string">"select"</span>)</span><br><span class="line">                .authorities(<span class="string">"client"</span>)</span><br><span class="line">                .secret(<span class="string">"123456"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 认证服务端点配置</span></span><br><span class="line"><span class="comment">     * 密码模式下需要配置认证管理器AuthenticationManager</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> endpoints</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        endpoints</span><br><span class="line">                .userDetailsService(userDetailsService)</span><br><span class="line">                .tokenStore(<span class="keyword">new</span> RedisTokenStore(redisConnectionFactory))</span><br><span class="line">                .authenticationManager(authenticationManager);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 认证安全检查流程配置</span></span><br><span class="line"><span class="comment">     * 配置checkTokenAccess为`permitAll()`，允许所有客户端发送请求，避免Spring Security拦截。默认是`denyAll()`，</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> security</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerSecurityConfigurer security)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        security.allowFormAuthenticationForClients();</span><br><span class="line">        security.checkTokenAccess(<span class="string">"permitAll()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong></p>
<ul>
<li>注入<code>RedisConnectionFactory</code>用户OAuth2将Token数据储存到Redis数据库中，我们并不需要配置具体的实现，Security-OAuth2本身提供了很多种方式储存Token数据</li>
</ul>
<p><img src="/2019/04/23/boot/spring-boot-security-oauth2-db/QQ20190423-155923.png" alt></p>
<ul>
<li>注入<code>UserDetailsService</code>，他用于初始化用户数据，我们仅仅在这里注入了<code>UserDetailsService</code>接口，而需要在其他地方注入实现了<code>UserDetailsService</code>接口的实现类。这样Security OAuth2会自动使用这个实现类中的配置。</li>
<li>在<code>configure(AuthorizationServerEndpointsConfigurer endpoints)</code>中配置<code>UserDetailsService</code>，配置<code>tokenStore()</code>，使用Security OAuth的<code>RedisTokenStore</code>实现，将<code>RedisConnectionFactory</code>连接工厂注入即可。</li>
<li>在上面<code>configure(ClientDetailsServiceConfigurer clients)</code>客户端配置中仍然直接在内存中创建一个客户端数据，实际上，客户端的数据应该是第三方提供的，比如微信、QQ等，而在这里都是我们个人使用的，暂时不处理第三方应用。</li>
</ul>
<h2 id="ResourceServerConfig"><a href="#ResourceServerConfig" class="headerlink" title="ResourceServerConfig"></a>ResourceServerConfig</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableResourceServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceServerConfig</span> <span class="keyword">extends</span> <span class="title">ResourceServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">"/hello"</span>)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .anyRequest()</span><br><span class="line">                .authenticated()</span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="UserDetailsServiceImpl"><a href="#UserDetailsServiceImpl" class="headerlink" title="UserDetailsServiceImpl"></a>UserDetailsServiceImpl</h2><p>上面介绍了，我们需要向Spring IOC容器中注入一个实现了<code>UserDetailsService</code>接口的Bean，这样Security OAuth2在初始化用户数据或身份校验时就能自动使用该Bean初始化用户数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDetailsServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现UserDetailsService中的loadUserByUsername方法，用于加载用户数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UsernameNotFoundException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">        SysUser user = userService.findByUsername(username);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UsernameNotFoundException(<span class="string">"用户不存在"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//用户权限列表。这里是为了方便模拟，实际应该从权限表中查询用户的权限列表</span></span><br><span class="line">        Collection&lt;? extends GrantedAuthority&gt; authorities = AuthorityUtils.createAuthorityList(user.getAuthorities());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AuthUser(</span><br><span class="line">                user.getId(),</span><br><span class="line">                user.getUsername(),</span><br><span class="line">                user.getPassword(),</span><br><span class="line">                <span class="keyword">true</span>,</span><br><span class="line">                <span class="keyword">true</span>,</span><br><span class="line">                <span class="keyword">true</span>,</span><br><span class="line">                <span class="keyword">true</span>,</span><br><span class="line">                authorities);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong></p>
<p>可以看<code>UserDetailsService</code>接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line">    <span class="function">UserDetails <span class="title">loadUserByUsername</span><span class="params">(String var1)</span> <span class="keyword">throws</span> UsernameNotFoundException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这个接口直接一个方法，这个方法用于根据用户名加载用户数据，最后需要返回一个<code>UserDetails</code>对象，可以看到<code>UserDetailsService</code>接口默认的实现：</p>
<p><img src="/2019/04/23/boot/spring-boot-security-oauth2-db/QQ20190423-174851.png" alt></p>
<p>如上，可以通过<code>InMemoryUserDetailsManager</code>从内存中获取数据、通过<code>JdbcUserDetailsManager</code>通过封装的JDBC操作从数据库中获取数据…。</p>
<blockquote>
<p>重写这个方法，该怎么返回一个<code>UserDetails</code>对象呢？</p>
</blockquote>
<p>查看<code>UserDetails</code>对象源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDetails</span> <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    Collection&lt;? extends GrantedAuthority&gt; getAuthorities();</span><br><span class="line">    <span class="function">String <span class="title">getPassword</span><span class="params">()</span></span>; <span class="comment">//密码</span></span><br><span class="line">    <span class="function">String <span class="title">getUsername</span><span class="params">()</span></span>; <span class="comment">//用户名</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAccountNonExpired</span><span class="params">()</span></span>; <span class="comment">//账户是否过期</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAccountNonLocked</span><span class="params">()</span></span>; <span class="comment">//账户是否锁定</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCredentialsNonExpired</span><span class="params">()</span></span>; <span class="comment">//账户凭证时候过期</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span></span>; <span class="comment">//账户是否可用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这个接口对象中封装了常见用户数据的获取方法。那么我们应该创建一个类实现这个接口，实现其中的方法并将正确的用户数据封装进去。这里，我们直接创建<code>AuthUser</code>类继承Spring Security内部实现了<code>UserDetails</code>接口的一个类<code>org.springframework.security.core.userdetails.User</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">UserDetails</span>, <span class="title">CredentialsContainer</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p><code>User</code>类中已经提供了很多实现方法，我们也没必要再复写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthUser</span> <span class="keyword">extends</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AuthUser</span><span class="params">(Long id, String username, String password, <span class="keyword">boolean</span> enabled, <span class="keyword">boolean</span> accountNonExpired, <span class="keyword">boolean</span> credentialsNonExpired, <span class="keyword">boolean</span> accountNonLocked, Collection&lt;? extends GrantedAuthority&gt; authorities)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(username, password, enabled, accountNonExpired, credentialsNonExpired, accountNonLocked, authorities);</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造方法<code>public AuthUser()</code>中包含了<code>UserDetails</code>接口中所涉及的属性值。下面我们把重点放在<code>authorities</code>这个属性上，他包含了用户的权限集合值，通常我们会建立五张表：1.用户表、2.角色表、3.权限表、4.用户角色表、5.角色权限表，以此来获取用户的角色、权限列表。这种方式方便维护，设计清晰。但是在本例中我们仅仅模拟在用户表中添加<code>authorities</code>这个字段，大家明白意思就好。</p>
<p>发现<code>authorities</code>这个属性是一个<code>Collection&lt;? extends GrantedAuthority&gt;</code>对象，也就是他是一个实现了<code>Collection</code>接口的集合，并且这个集合有一个泛型，标明这个接口存放的是实现了<code>GrantedAuthority</code>接口的对象。那么，总结而言，我们需要：</p>
<ol>
<li>一个实现了<code>Collection</code>接口的集合，作为权限集合</li>
<li>一堆实现了<code>GrantedAuthority</code>接口的对象，作为权限对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection&lt;? extends GrantedAuthority&gt; authorities = AuthorityUtils.createAuthorityList(user.getAuthorities());</span><br></pre></td></tr></table></figure>

<p>没错，Spring Security内部提供了一个工具类用于提供一个<code>List&lt;GrantedAuthority&gt;</code>对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorityUtils</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;GrantedAuthority&gt; <span class="title">commaSeparatedStringToAuthorityList</span><span class="params">(String authorityString)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;String&gt; <span class="title">authorityListToSet</span><span class="params">(Collection&lt;? extends GrantedAuthority&gt; userAuthorities)</span> </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;GrantedAuthority&gt; <span class="title">createAuthorityList</span><span class="params">(String... roles)</span> </span>&#123;</span><br><span class="line">		...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，我们准备好了<code>UserDetails</code>接口所需的全部数据，直接<code>return AuthUser(…)</code>即可。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>打开本地Redis</p>
<p><img src="/2019/04/23/boot/spring-boot-security-oauth2-db/QQ20190423-181918.png" alt></p>
<p>启动项目，观察断点:</p>
<p>首先，观察启动项目时<code>configure(AuthorizationServerEndpointsConfigurer endpoints)</code>方法：</p>
<p><img src="/2019/04/23/boot/spring-boot-security-oauth2-db/QQ20190423-182050.png" alt></p>
<p>此时，我们<code>@Autowire</code>的<code>UserDetailsService</code>对象已经包含了我们设置的一写逻辑 ==&gt; 通过Mybatis调用<code>findByUsername</code>方法查询数据库得到用户对象。</p>
<p>访问：<code>localhost:8080/hello</code>:</p>
<p><img src="/2019/04/23/boot/spring-boot-security-oauth2-db/QQ20190423-182423.png" alt></p>
<p>访问：<code>localhost:8080/info/tycoding</code>:</p>
<p><img src="/2019/04/23/boot/spring-boot-security-oauth2-db/QQ20190423-182538.png" alt></p>
<p>使用Postman工具访问<code>localhost:8080/oauth/token</code>接口获取Token：</p>
<p><img src="/2019/04/23/boot/spring-boot-security-oauth2-db/QQ20190423-182722.png" alt></p>
<p>注意Basic认证：</p>
<p><img src="/2019/04/23/boot/spring-boot-security-oauth2-db/QQ20190423-182821.png" alt></p>
<p>查看断点，经过自定义实现了<code>UserDetailsService</code>接口的实现类：</p>
<p><img src="/2019/04/23/boot/spring-boot-security-oauth2-db/QQ20190423-182918.png" alt></p>
<p>这里根据<code>findByUsername</code>查询到了用户数据，最终将数据封装到<code>AuthUser</code>对象中再返回即可：</p>
<p><img src="/2019/04/23/boot/spring-boot-security-oauth2-db/QQ20190423-183138.png" alt></p>
<p>再次访问：<code>localhost:8080/info/tycoding?access_token=xxx</code>:</p>
<p><img src="/2019/04/23/boot/spring-boot-security-oauth2-db/QQ20190423-183304.png" alt></p>
<p>查看Redis，可以看到认证数据已经储存在Redis中：</p>
<p><img src="/2019/04/23/boot/spring-boot-security-oauth2-db/QQ20190423-183511.png" alt></p>
<br>

<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <categories>
        <category>spring-boot</category>
      </categories>
      <tags>
        <tag>oauth</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Security OAuth2概念引入</title>
    <url>/2019/04/22/boot/spring-boot-security-oauth2-start/</url>
    <content><![CDATA[<p>:tada: :tada: :tada: <strong>这里有丰富的 Spring 框架学习案例</strong></p>
<p><strong>仓库地址：<a href="https://github.com/TyCoding/spring-learn" target="_blank" rel="noopener">spring-learn</a></strong><br><strong>欢迎star、fork，给作者一些鼓励</strong></p>
<h1 id="Spring-Security-OAuth2概念引入"><a href="#Spring-Security-OAuth2概念引入" class="headerlink" title="Spring Security OAuth2概念引入"></a>Spring Security OAuth2概念引入</h1><p>​    OAUTH协议为用户资源的授权提供了一个安全的、开放而又简易的标准。与以往的授权方式不同之处是OAUTH的授权不会使第三方触及到用户的帐号信息（如用户名与密码），即第三方无需使用用户的用户名与密码就可以申请获得该用户资源的授权，因此OAUTH是安全的。oAuth是Open Authorization的简写。</p>
<a id="more"></a>

<p>上面摘选自百度百科。想象一下，我们开发了一个微信小程序，他的功能是可以批量修改(美化)用户相册中的照片，那么这小程序就要获取用户相册数据。如果按照传统方式直接让用户通过用户名密码登录该小程序，那么该小程序通过用户名密码就能获取到用户的全部数据，这就造成了密码泄露的风险，且想要弃用这个小程序只能修改密码。这种方式显然不好。</p>
<p>而OAuth协议的出现正是解决了这些问题。他将用户名密码授权方式改为通过<code>令牌</code>授权，第三方应用请求访问资源，资源所有者(用户)同意授权后，再次访问服务提供商(微信官方)去向认证服务器申请令牌(Token)，认证服务器同意后发放令牌(Token)，然后第三方应用再拿这个令牌(Token)去向资源服务器(微信官方)申请想要的资源，资源服务器验证通过后开放这个应用所需的资源。</p>
<p>我们可以以下图简单的了解下Oauth2</p>
<p><img src="/2019/04/22/boot/spring-boot-security-oauth2-start/QQ20190422-081517.png" alt></p>
<p> 这种方式就完全避免了把用户名密码暴露给第三方应用的风险。</p>
<p>下面我们把重点放在右侧<strong>资源提供商(Provider)</strong></p>
<h1 id="服务提供商-Provider"><a href="#服务提供商-Provider" class="headerlink" title="服务提供商 Provider"></a>服务提供商 Provider</h1><p>Spring Security Oauth2的服务提供商实际上分为：</p>
<ul>
<li>认证服务 Authorization Server</li>
<li>资源服务 Resource Server</li>
</ul>
<p>上图中，我们把认证服务和资源服务放在一起，但实际上并不一定是这样的，资源服务可以放在不同的应用上，而且可以存在多个资源服务，他们共享同一个中央认证服务器。</p>
<p>获取令牌(Token)的请求以及其他OAuth内部的请求都会放在Spring Security的请求过滤器链中，但这些请求都不会被Spring Security拦截。</p>
<p>下面是配置一个认证服务必须实现的endpoints:</p>
<ul>
<li><code>AuthorizationEndpoint</code>: 用来作为请求者获得授权的服务，默认URL是：<code>/oauth/authorize</code></li>
<li><code>TokenEndpoint</code>: 用来作为请求者获取令牌(Token)的服务，默认URL是：<code>/oauth/token</code></li>
</ul>
<p>下面是配置一个资源服务必须实现的过滤器：</p>
<ul>
<li><code>OAuth2AuthenticationProcessingFilter</code>: 用来作为令牌(Token)的一个处理流程过滤器。只有当过滤器通过后，请求者才能获取受保护的资源</li>
</ul>
<h2 id="认证服务器-Authorization-Server"><a href="#认证服务器-Authorization-Server" class="headerlink" title="认证服务器 Authorization Server"></a>认证服务器 Authorization Server</h2><p>通过<code>EnableAuthorizationServer</code>注解配置</p>
<p>配置一个授权服务(即Authorization Server)，需要考虑集中授权类型(Grant Type)，不同授权类型的客户端(Client)可能提供了不同的方式获取令牌(Token)，为了实现并确定这几种授权，需要配置使用ClientDetailsService和TokenService来开启和禁用这几种授权机制。并且，在实际开发中，我们通常指定<code>authorizedGrantTypes</code>授权类型，Spring OAuth2提供了几种常用的授权模式：</p>
<ul>
<li><code>authorization_code</code>: 授权码模式</li>
<li><code>implicit</code>: 简易模式(隐式授权类型)</li>
<li><code>password</code>: 密码模式</li>
<li><code>client_credentials</code>: 客户端模式</li>
<li><code>refresh_token</code>: 通过以上授权获取的令牌(Token)来刷新令牌(获取新的令牌)</li>
</ul>
<p>通常，我们直接使用<code>@EnableAuthorizationServer</code>标记此服务是认证服务，然后继承<code>AuthorizationServerConfigurerAdapter</code>类来配置具体的认证授权服务。下面介绍一些常见的配置：</p>
<ul>
<li><code>ClientDetailsServiceConfigurer</code>: 配置客户端的详情服务(ClientDetailsService)，客户端的信息在这里初始化。通常这些信息从数据库中读取</li>
<li><code>AuthorizationServerSecurityConfigurer</code>: 配置令牌端点(Token Endpoint)的安全约束</li>
<li><code>AuthorizationServerEndpointsConfigurer</code>: 配置授权(authorization)以及令牌(Token)的访问端点和令牌服务(Token services)</li>
</ul>
<p>对应在<code>AuthorizationServerConfigurerAdapter</code>类中的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizationServerConfigurerAdapter</span> <span class="keyword">implements</span> <span class="title">AuthorizationServerConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AuthorizationServerConfigurerAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerSecurityConfigurer security)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置客户端详情-Client-Details"><a href="#配置客户端详情-Client-Details" class="headerlink" title="配置客户端详情(Client Details)"></a>配置客户端详情(Client Details)</h3><p><code>ClientDetailsServiceConfigurer</code>可以使用内存或者JDBC来配置客户端详情服务(ClientDeyailsService)，其中有几个重要属性：</p>
<ul>
<li><code>clientId</code>: 用来标识客户端的ID，相当于username</li>
<li><code>secret</code>: 客户端的安全码，相当于password</li>
<li><code>scope</code>: 客户端的域，用来限制客户端的访问范围</li>
<li><code>authorizedGrantTypes</code>: 此客户端可以使用的授权类型</li>
<li><code>authorities</code>: 此客户端的权限</li>
</ul>
<h3 id="管理令牌-Managing-Token"><a href="#管理令牌-Managing-Token" class="headerlink" title="管理令牌(Managing Token)"></a>管理令牌(Managing Token)</h3><p><code>AuthorizationServerTokenServices</code>接口定义了一些操作实现对令牌的一些必要的管理。其中<code>DefaultTokenServices</code>这个实现类提供了一些方法操作Token，而Token数据的持久化是委托给<code>TokenStore</code>接口实现的，<code>TokenStore</code>有很多实现类用于不同的方式持久化Token数据：</p>
<ul>
<li><code>InMemoryTokenStore</code>: 默认采用，将Token数据储存在内存中</li>
<li><code>JdbcTokenStore</code>: 封装一些JDBC的操作，将数据保存在关系型数据库中(需要<code>spring-jdbc</code>支持)</li>
<li><code>JwtTokenStore</code>: 将令牌相关的数据进行编码传输(需要<code>spring-security-jwt</code>支持)</li>
</ul>
<h3 id="JWT令牌-JWT-Tokens"><a href="#JWT令牌-JWT-Tokens" class="headerlink" title="JWT令牌(JWT Tokens)"></a>JWT令牌(JWT Tokens)</h3><p>使用JWT令牌，需要在守群服务中使用<code>JwtTokenStore</code>，资源服务器也需要一个解码Token令牌的类<code>JwtAccessTokenConverter</code>，<code>JwtTokenStore</code>依赖这个类进行编码和解码，因此你的授权服务和资源服务都需要使用这个转换类。Token令牌默认是有签名的，并且资源服务需要验证这个签名，因此需要使用一个对称的Key值来参与签名的计算，这个Key存在于授权服务以及资源服务之中。或者可以使用非对称加密加密算法对Token进行签名，Public Key公布在<code>/oauth/token_key</code>这个URL中，默认的访问规则是<code>denyAll()</code>，即在默认情况下他是关闭的，可以配置<code>permitAll()</code>来开启（<code>tokenKeyAccess</code>）。</p>
<h3 id="端点URL"><a href="#端点URL" class="headerlink" title="端点URL"></a>端点URL</h3><p>Spring Security OAuth2内部提供了一些接口作为认证和授权：</p>
<ul>
<li><code>/oauth/token</code>: 令牌端点</li>
<li><code>/oauth/authorize</code>: 授权端点</li>
<li><code>/oauth/confirm_access</code>: 用户确认授权提交端点</li>
<li><code>/oauth/error</code>: 授权服务错误信息端点</li>
<li><code>/oauth/check_token</code>: 用于资源服务访问的令牌解析端点</li>
<li><code>/oauth/token_key</code>: 提供公有的秘钥的端点，比如使用JWT令牌时用到</li>
</ul>
<h2 id="资源服务器-Resource-Server"><a href="#资源服务器-Resource-Server" class="headerlink" title="资源服务器 Resource Server"></a>资源服务器 Resource Server</h2><p>通过<code>@EnableResourceServer</code>注解配置</p>
<p>资源服务中储存着受保护或为受保护的资源，简单来说资源就是Controller中的一写接口，因为我们通常是通过接口来获取数据的。整个应用中所有的请求都受Spring Security的过滤器链保护，过滤器链决定了那些接口是直接可以访问的哪些是必须经过授权才能访问的。</p>
<p>通常我们使用<code>@EnableResourceServer</code>注解标记，再继承<code>ResourceServerConfigurerAdapter</code>类，重写其中的方法实现对资源服务器的配置，比如设置资源服务的ID，自定义一些权限保护规则等：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceServerConfigurerAdapter</span> <span class="keyword">implements</span> <span class="title">ResourceServerConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResourceServerConfigurerAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ResourceServerSecurityConfigurer resources)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ((AuthorizedUrl)http.authorizeRequests().anyRequest()).authenticated();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <categories>
        <category>spring-boot</category>
      </categories>
      <tags>
        <tag>oauth2</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Security OAuth2实战</title>
    <url>/2019/04/22/boot/spring-boot-security-oauth2/</url>
    <content><![CDATA[<p>在前面我们讲了：<a href="https://www.tycoding.cn/2019/04/22/boot/spring-boot-security-oauth2-start/">Spring Security OAuth2概念引入</a> 这次我们讲解如何在Spring Boot中使用Spring Security OAuth2搭建权限脚手架项目。</p>
<p>:tada: :tada: :tada: <strong>这里有丰富的 Spring 框架学习案例</strong></p>
<p><strong>仓库地址：<a href="https://github.com/TyCoding/spring-learn" target="_blank" rel="noopener">spring-learn</a></strong><br><strong>欢迎star、fork，给作者一些鼓励</strong></p>
<a id="more"></a>

<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>如果你还不了解OAuth2，可以去查阅一些资料:</p>
<ul>
<li><a href="https://www.tycoding.cn/2019/04/22/boot/spring-boot-security-oauth2-start/">Spring Security OAuth2概念引入</a></li>
<li><a href="https://tools.ietf.org/html/rfc6749" target="_blank" rel="noopener">OAuth2官网</a></li>
<li><a href="https://tycoding.cn/2019/04/11/boot/spring-boot-security/" target="_blank" rel="noopener">Spring Boot整合Spring Security</a></li>
</ul>
<p>本次博文使用SpringBoot-2.x 和 Spring-Security-oauth2-2.x</p>
<h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security.oauth.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-oauth2-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Security配置"><a href="#Security配置" class="headerlink" title="Security配置"></a>Security配置</h2><p>通常，我们直接创建一个配置类继承<code>WebSecurityConfigurerAdapter</code>类，重写其中的配置方法即可，并且需要<code>@EnableWebSecurity</code>注解标记即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> UserDetailsService <span class="title">userDetailsService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        InMemoryUserDetailsManager manager = <span class="keyword">new</span> InMemoryUserDetailsManager();</span><br><span class="line">        manager.createUser(User.withUsername(<span class="string">"user_1"</span>).password(<span class="string">"123456"</span>).authorities(<span class="string">"USER"</span>).build());</span><br><span class="line">        <span class="keyword">return</span> manager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">"/hello"</span>)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .anyRequest()</span><br><span class="line">                .authenticated()</span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationManager <span class="title">authenticationManager</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.authenticationManager();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<ul>
<li>这里重写了<code>userDetailsService()</code>方法，并<code>UserDetailsService</code>的一个实现类<code>InMemoryDetailsManager</code>将用户数据储存在内存中，其中用户名user_1(<code>withUsername</code>)、密码123456(<code>password</code>)、权限USER(<code>authorities</code>)。当然这里仅是为了模拟，实际开发中应该从数据库中读取用户数据。因此上述方式并不是唯一的，我们仅需要return一个实现了<code>UserDetailsService</code>接口的实现类即可。</li>
<li>重写<code>configure(HttpSecurity http)</code>方法，自定义一些请求过滤配置，这里开放了<code>/hello</code>接口，其他接口都被拦截。</li>
<li>最后一定要重写<code>authenticationManager()</code>方法，注入<code>AuthenticationManager</code>接口，目的是启用密码模式。如果不加这个配置很可能出现<code>Unsupported grant type:password</code>错误</li>
</ul>
<h2 id="Security-OAuth2配置"><a href="#Security-OAuth2配置" class="headerlink" title="Security-OAuth2配置"></a>Security-OAuth2配置</h2><p>在<a href="https://www.tycoding.cn/2019/04/22/boot/spring-boot-security-oauth2-start/">Spring Security OAuth2概念引入</a>一文中我们已经了解了OAuth2的两个核心就是:1.认证服务器、2.资源服务器。那么这里就是配置OAuth2的认证服务器<code>AuthorizationServer</code></p>
<p>通常我们直接创建一个配置类继承<code>AuthorizationServerConfigurerAdapter</code>类，并重写其中的方法完成配置，并且用<code>@EnableAuthorizationServer</code>注解标记即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAuthorizationServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizationServerConfig</span> <span class="keyword">extends</span> <span class="title">AuthorizationServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        clients.inMemory().withClient(<span class="string">"client_1"</span>)</span><br><span class="line">                .resourceIds(<span class="string">"info"</span>)</span><br><span class="line">                .authorizedGrantTypes(<span class="string">"client_credentials"</span>, <span class="string">"password"</span>, <span class="string">"refresh_token"</span>)</span><br><span class="line">                .scopes(<span class="string">"select"</span>)</span><br><span class="line">                .authorities(<span class="string">"client"</span>)</span><br><span class="line">                .secret(<span class="string">"123456"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        endpoints.authenticationManager(authenticationManager);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerSecurityConfigurer security)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        security.allowFormAuthenticationForClients();</span><br><span class="line">        security.checkTokenAccess(<span class="string">"permitAll()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<ul>
<li>重写<code>configure(ClientDetailsServiceConfigurer clients)</code>方法，配置客户端的信息，这里仍然将客户端数据储存在内存中，实际开发中应该从数据库中读取客户端数据：<ul>
<li><code>widthClient()</code>客户端ID，相当于username</li>
<li><code>authorizedGrantTypes()</code>客户端访问模式，客户端模式(<code>Client_credentials</code>)、密码模式(<code>password</code>)、授权码模式(<code>authorization_code</code>)</li>
<li><code>scopes</code>: 客户端域，限制客户端的访问范围</li>
<li><code>authorities()</code>: 客户端的权限</li>
<li><code>secret()</code>: 客户端的安全码，相当于password</li>
</ul>
</li>
<li>重写<code>configure(AuthorizationServerEndpointsConfigurer endpoints)</code>，将<code>AuthenticationManager</code>设置进去，支持密码模式的授权</li>
<li>重写<code>configure(AuthorizationServerSecurityConfigurer security)</code>，支持允许表单认证登录。配置checkTokenAccess为<code>permitAll()</code>，允许所有客户端发送请求，避免Spring Security拦截。默认是<code>denyAll()</code></li>
</ul>
<h2 id="Resource-Server配置"><a href="#Resource-Server配置" class="headerlink" title="Resource Server配置"></a>Resource Server配置</h2><p>上面Security-OAuth2配置，其实也就是<code>Authentication Server</code>认证服务的配置，但截至到目前，我们还未考虑过<code>Resource Server</code>资源服务配置，但对于我们目前的业务而言也不需要对Resource Server做什么自定义配置，如果需要按照Authentication Server的配置类似食用即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableResourceServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceServerConfig</span> <span class="keyword">extends</span> <span class="title">ResourceServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="PasswordEncoder配置"><a href="#PasswordEncoder配置" class="headerlink" title="PasswordEncoder配置"></a>PasswordEncoder配置</h2><p>你可能会在搭建上述环境后启动项目还是报错：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.IllegalArgumentException: There is no PasswordEncoder mapped <span class="keyword">for</span> the id <span class="string">"null"</span></span><br></pre></td></tr></table></figure>

<p>原因就是在Spring Security新版本中，必须手动配置<code>PasswordEncoder</code>密码校验服务，在 <a href="https://tycoding.cn/2019/04/11/boot/spring-boot-security/" target="_blank" rel="noopener">SpringBoot整合SpringSecurity</a> 一文中也讲过。所以这里我们简单配置一个类，不做密码加密</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PasswordEncoderImpl</span> <span class="keyword">implements</span> <span class="title">PasswordEncoder</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">encode</span><span class="params">(CharSequence charSequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> charSequence.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(CharSequence charSequence, String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.equals(charSequence.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>模拟创建Controller接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello, this is test interface"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/info/&#123;name&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">info</span><span class="params">(@PathVariable String name)</span> </span>&#123;</span><br><span class="line">        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello "</span> + name + <span class="string">", this your info"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问<code>localhost:8080/hello</code>:</p>
<p><img src="/2019/04/22/boot/spring-boot-security-oauth2/QQ20190422-203819.png" alt></p>
<p>不拦截，正常。</p>
<p>访问：<code>localhost:8080/info/tycoding</code>:</p>
<p><img src="/2019/04/22/boot/spring-boot-security-oauth2/QQ20190422-203951.png" alt></p>
<p>为授权，被拦截，正常。</p>
<h3 id="oauth-token获取Token"><a href="#oauth-token获取Token" class="headerlink" title="/oauth/token获取Token"></a><code>/oauth/token</code>获取Token</h3><p>在Postman上测试<code>localhost:8080/oauth/token?username=user_1&amp;password=123456&amp;grant_type=password</code>接口：</p>
<p><img src="/2019/04/22/boot/spring-boot-security-oauth2/QQ20190422-204235.png" alt></p>
<p>可以看到依然被拦截，这是因为Spring Security配置中默认食用Basic认证方式。我们直接将这个请求粘贴到浏览器上：</p>
<p><img src="/2019/04/22/boot/spring-boot-security-oauth2/QQ20190422-210819.png" alt></p>
<p>要解决这个问题，Postman提供模拟Basic登陆的效果：</p>
<p><img src="/2019/04/22/boot/spring-boot-security-oauth2/QQ20190422-214710.png" alt></p>
<h3 id="使用Token访问受保护的资源"><a href="#使用Token访问受保护的资源" class="headerlink" title="使用Token访问受保护的资源"></a>使用Token访问受保护的资源</h3><p>按照上述方式获取到了<code>access_token</code>值，在浏览器上直接访问<code>localhost:8080/info/tycoding?access_token=xxx</code>:</p>
<p><img src="/2019/04/22/boot/spring-boot-security-oauth2/QQ20190422-215027.png" alt></p>
<p>看到，还是被拦截，按道理，既然第三方应用拿到了Token值，通过这个Token值应该可以获取到受保护的资源。</p>
<p>这时就需要配置Resource Server了，前面我们仅仅提到了，并没有配置，那么这里创建Resource Server的配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableResourceServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceServerConfig</span> <span class="keyword">extends</span> <span class="title">ResourceServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果启用了<code>@EnableResourceServer</code>的配置，那么应该重写<code>configure(HttpSecurity http)</code>方法，和<code>@EnableWebSecurity</code>标记类的配置类似，我们这里要配置不需要拦截的请求。如果你仅仅是在<code>@EnableWebSecurity</code>配置类中配置了<code>/hello</code>请求不拦截，而你启用了<code>@EnableResourceServer</code>配置，但并没有配置<code>HttpSecurity</code>的过滤配置，那么默认OAuth还是拦截所有，直接访问<code>/hello</code>反而也被拦截到：</p>
<p><img src="/2019/04/22/boot/spring-boot-security-oauth2/QQ20190423-140351.png" alt></p>
<p>所以，应该配置为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableResourceServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceServerConfig</span> <span class="keyword">extends</span> <span class="title">ResourceServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">"/hello"</span>)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .anyRequest()</span><br><span class="line">                .authenticated()</span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重新运行项目，获取到Token值，直接去浏览器访问：<code>localhost:8080/info/tycoding?access_token=xx</code>:</p>
<p><img src="/2019/04/22/boot/spring-boot-security-oauth2/QQ20190422-215547.png" alt></p>
<p>出现这个错误可能是你的Token值需要更新了。</p>
<p><img src="/2019/04/22/boot/spring-boot-security-oauth2/QQ20190422-215702.png" alt></p>
<p>正常访问</p>
<h3 id="oauth-check-token"><a href="#oauth-check-token" class="headerlink" title="/oauth/check_token"></a><code>/oauth/check_token</code></h3><p>这个接口用于校验此token是否过期</p>
<p>如果错误或过期：</p>
<p><img src="/2019/04/22/boot/spring-boot-security-oauth2/QQ20190422-215825.png" alt></p>
<p>如果正确为过期：</p>
<p><img src="/2019/04/22/boot/spring-boot-security-oauth2/QQ20190422-215954.png" alt></p>
<p>显示该Token对应第三方应用和用户的数据。</p>
<h2 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h2><p>以下是我们在整合Spring Security OAuth2常见的错误：</p>
<h3 id="Request-method-39-GET-39-not-supported”"><a href="#Request-method-39-GET-39-not-supported”" class="headerlink" title="Request method &#39;GET&#39; not supported”"></a>Request method &#39;GET&#39; not supported”</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"error"</span>: <span class="string">"method_not_allowed"</span>,</span><br><span class="line">  <span class="attr">"error_description"</span>: <span class="string">"Request method &amp;#39;GET&amp;#39; not supported"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>错误描述</li>
</ol>
<p>通常是因为我们直接使用浏览器请求，那么就采用的GET请求</p>
<ol start="2">
<li>解决方案</li>
</ol>
<p>使用Postman等工具测试接口，发送POST请求即可</p>
<h3 id="Unsupported-grant-type-password"><a href="#Unsupported-grant-type-password" class="headerlink" title="Unsupported grant type: password"></a>Unsupported grant type: password</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"error"</span>: <span class="string">"unsupported_grant_type"</span>,</span><br><span class="line">    <span class="attr">"error_description"</span>: <span class="string">"Unsupported grant type: password"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>错误描述</li>
</ol>
<p>出现这个错误的原因通常是因为你没有配置支持OAuth2密码模式，这个常出现</p>
<ol start="2">
<li>解决方案</li>
</ol>
<p>Spring Security配置中将<code>AuthenticationManager</code>类注入到Spring IOC容器中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AuthenticationManager <span class="title">authenticationManager</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.authenticationManager();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Security OAuth认证服务器(<code>@EnableAuthorizationServer</code>)中配置<code>AuthenticationManager</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    endpoints.authenticationManager(authenticationManager);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Missing-grant-type"><a href="#Missing-grant-type" class="headerlink" title="Missing grant type"></a>Missing grant type</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"error"</span>: <span class="string">"invalid_request"</span>,</span><br><span class="line">    <span class="attr">"error_description"</span>: <span class="string">"Missing grant type"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>错误描述</li>
</ol>
<p>通产是请求URL中没有配置<code>grant_type</code>的值</p>
<ol start="2">
<li>解决方案</li>
</ol>
<p>请求中配置<code>grant_type</code>类型，比如：<code>grant_type:password</code></p>
<h3 id="401-Unauthorized"><a href="#401-Unauthorized" class="headerlink" title="401 Unauthorized"></a>401 Unauthorized</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"timestamp"</span>: <span class="string">"2019-04-22T07:18:52.341+0000"</span>,</span><br><span class="line">    <span class="attr">"status"</span>: <span class="number">401</span>,</span><br><span class="line">    <span class="attr">"error"</span>: <span class="string">"Unauthorized"</span>,</span><br><span class="line">    <span class="attr">"message"</span>: <span class="string">"Unauthorized"</span>,</span><br><span class="line">    <span class="attr">"path"</span>: <span class="string">"/oauth/token"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>错误描述</li>
</ol>
<p>如果是使用的Postman工具请求的URL，报这个错误，通常是因为配置的Spring Security拦截了这个请求，并启用了Basic的验证方式，我们直接将这个URL放在浏览器上访问，则会弹出Basic密码验证框：</p>
<p><img src="/2019/04/22/boot/spring-boot-security-oauth2/QQ20190422-152231.png" alt></p>
<p>正确输入客户端(Client)的账户（clientId）、密码(secret)，即可访问。</p>
<ol start="2">
<li>解决方案</li>
</ol>
<p>要解决这个问题，就要考虑怎么能让Postman请求不经过Basic登录框这个验证方式，这就需要知道Basic的加密方式。其实Basic登录框最终是将输入的用户名和密码通过Base64加密，然后在前面加上<code>Basic base64</code>，然后去请求这个URL接口，所以我们需要在 <a href="http://tool.oschina.net/encrypt?type=3" target="_blank" rel="noopener">在线加密解密网站</a> 将Client用户名和密码按照：<code>name:password</code>格式加密，最终在Postman中设置请求头<code>Authorization: Basic xxx</code>，这个xxx是按照<code>name:password</code>格式加密的数据：</p>
<p><img src="/2019/04/22/boot/spring-boot-security-oauth2/QQ20190422-154436.png" alt></p>
<h3 id="Full-authentication-is-required-to-access-this-resource"><a href="#Full-authentication-is-required-to-access-this-resource" class="headerlink" title="Full authentication is required to access this resource"></a>Full authentication is required to access this resource</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"error"</span>: <span class="string">"unauthorized"</span>,</span><br><span class="line">    <span class="attr">"error_description"</span>: <span class="string">"Full authentication is required to access this resource"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>错误描述</li>
</ol>
<p>如果此时后台也报错：<code>There is no PasswordEncoder mapped for the id &quot;null&quot;</code>，通常就是因为没有配置密码校验服务的原因。</p>
<p><strong>产生这个错误的原因有很多</strong></p>
<ol start="2">
<li>解决方案</li>
</ol>
<p>注入任意一个实现了<code>PasswordEncoder</code>接口的实现类。</p>
<br>

<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <categories>
        <category>spring-boot</category>
      </categories>
      <tags>
        <tag>oauth</tag>
      </tags>
  </entry>
  <entry>
    <title>（十五）SpringBoot2.x整合SpringSecurity</title>
    <url>/2019/04/11/boot/spring-boot-security/</url>
    <content><![CDATA[<h1 id="Spring-Boot整合SpringSecurity"><a href="#Spring-Boot整合SpringSecurity" class="headerlink" title="Spring Boot整合SpringSecurity"></a>Spring Boot整合SpringSecurity</h1><p>:tada: :tada: :tada: <strong>这里有丰富的 Spring 框架学习案例</strong></p>
<p><strong>仓库地址：<a href="https://github.com/TyCoding/spring-learn" target="_blank" rel="noopener">spring-learn</a></strong><br><strong>欢迎star、fork，给作者一些鼓励</strong></p>
<blockquote>
<p>写在前面</p>
</blockquote>
<p>之前都是在用Shiro做权限管理框架，并且写过一个不错的项目：<a href="https://github.com/TyCoding/permission/" target="_blank" rel="noopener">permission</a> (欢迎star,fork)。</p>
<p>这次我们学习下Spring Security权限框架。注意，这里使用的Spring Boot-2.1.4版本，那么Spring Security也是最新的5.1.5</p>
<a id="more"></a>

<h2 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h2><h3 id="依赖导入"><a href="#依赖导入" class="headerlink" title="依赖导入"></a>依赖导入</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="创建测试接口"><a href="#创建测试接口" class="headerlink" title="创建测试接口"></a>创建测试接口</h3><p>在<code>/cn/tycoding/controller</code>下创建<code>UserController.java</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello I'm TyCoding, this is Login test"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>启动项目，在浏览器上访问：<code>127.0.0.1:8080/test</code>接口： </p>
<p><img src="/2019/04/11/boot/spring-boot-security/1.png" alt></p>
<blockquote>
<p>可以看到，URL立即跳转到<code>/login</code>，并且，这个接口和页面并不是我们写的。</p>
</blockquote>
<p>所以，Spring Security帮我们写了一个默认的登录页面，并且项目引入了Spring Security，Spring Security就默认配置拦截所有URL请求。</p>
<blockquote>
<p>观察启动项目的控制台log</p>
</blockquote>
<p>可看到类似这段日志：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Using generated security password: 8b0e38a6-6af6-40cd-8882-a8c697fd803e</span><br></pre></td></tr></table></figure>

<p>这个就是Spring Security默认进行URL拦截并默认提供的登录密码，用户名是<code>user</code>。在登录页面上输入<code>user</code>和<code>8b0e38a6-6af6-40cd-8882-a8c697fd803e</code>，登录成功:</p>
<p><img src="/2019/04/11/boot/spring-boot-security/2.png" alt></p>
<h3 id="简单的配置"><a href="#简单的配置" class="headerlink" title="简单的配置"></a>简单的配置</h3><p>新建<code>cn/tycoding/config</code>，创建<code>WebSecurityConfig.java</code>继承<code>WebSecurityConfigurerAdapter</code>，并重写<code>void configure(HttpSecurity http)</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * fromLogin(): 表单认证</span></span><br><span class="line"><span class="comment">         * httpBasic(): 弹出框认证</span></span><br><span class="line"><span class="comment">         * authorizeRequests() 身份认证请求</span></span><br><span class="line"><span class="comment">         * anyRequest(): 所有请求</span></span><br><span class="line"><span class="comment">         * authenticated(): 身份认证</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        http.formLogin()</span></span><br><span class="line">        http.httpBasic()</span><br><span class="line">                .and()</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .anyRequest()</span><br><span class="line">                .authenticated();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最开始演示的是Spring Security默认的表单认证方式，当我们修改为<code>http.httpBasic()</code>后：</p>
<p><img src="/2019/04/11/boot/spring-boot-security/3.png" alt></p>
<h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>Spring Security基础的过滤器：</p>
<p><img src="/2019/04/11/boot/spring-boot-security/4.png" alt></p>
<p>当请求经过Spring Security，就会经过Spring Security的一系列过滤器，当都满足过滤器的条件，最终通过请求，响应请求。其中：</p>
<ul>
<li><code>UsernamePassword</code>是最前端的过滤器，用于处理基础的表单login请求</li>
<li>图中绿色的是用户可定制的过滤器，而后面的非绿色过滤器是用户不能控制的</li>
<li><code>FilterSecurityInterceptor</code>是最后段的过滤器，用于最终处理所有的请求过滤</li>
</ul>
<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h3 id="自定义登录实现"><a href="#自定义登录实现" class="headerlink" title="自定义登录实现"></a>自定义登录实现</h3><h4 id="1-自定义登录接口"><a href="#1-自定义登录接口" class="headerlink" title="1.自定义登录接口"></a>1.自定义登录接口</h4><p>在前面看到，Spring Security默认为拦截的URL提供登录页面，并内部提供一个接口用于处理默认的登录请求。但这在实际项目中显然是不行了，所以我们要定制化登录接口。</p>
<p>在<code>cn/tycoding/config/service/</code>下创建<code>UserDetailsServiceImpl.java</code>并实现<code>UserDetailsService</code>接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDetailsServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Spring Security接收login请求调用UserDetailsService这个接口中的loadUserByUsername方法</span></span><br><span class="line"><span class="comment">     * loadUserByUsername根据传进来的用户名进行校验工作，最后将查询到的用户信息封装到UserDetails这个接口的实现类中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username 用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UsernameNotFoundException 登录异常类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">        log.info(<span class="string">"登录，用户名：&#123;&#125;"</span>, username);</span><br><span class="line">        <span class="comment">//根据用户名查询用户数据，比如：从数据库中查询</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(username, <span class="string">"123456"</span>, AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="string">"admin"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>UserDetailsService</code>接口的唯一一个方法<code>loadUserByUsername</code>，负责接收登录请求传递的用户名，并根据用户名进行身份校验（比如查询数据库）。最后该方法返回一个封装了用户身份信息的<code>UserDetails</code>实现类对象。<br>这里我们返回一个Spring提供的<code>UserDetails</code>的实现类<code>User</code>（当然并不必须，我们只需要返回实现了<code>UserDetails</code>接口的实现类即可）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String username, String password, Collection&lt;? extends GrantedAuthority&gt; authorities)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String username, String password, <span class="keyword">boolean</span> enabled, <span class="keyword">boolean</span> accountNonExpired, <span class="keyword">boolean</span> credentialsNonExpired, <span class="keyword">boolean</span> accountNonLocked, Collection&lt;? extends GrantedAuthority&gt; authorities)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>该实现类有两个带参构造方法。其中<code>authorities</code>参数是携带了用户权限集合。为了模拟效果，我们写死数据。</p>
<h5 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h5><p>启动项目，访问<code>localhost:8080/test</code>，URL跳转到<code>/login</code>:</p>
<p>根据我们写死的密码，在页面上输入: username:<code>tycoding</code>, password:<code>123456</code>。点击登录发现页面刷新了，但并未跳转到<code>/test</code>，查看控制台日志：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.lang.IllegalArgumentException: There is no PasswordEncoder mapped for the id &quot;null&quot;</span><br></pre></td></tr></table></figure>

<p>原来在因为使用了Spring Security-5.x版本，需要手动提供一个<code>PasswordEncoder</code>实现类类，进行密码校验。那么我们在<code>cn/tycoding/config/</code>下创建<code>PasswordEncoderImpl</code>类并实现<code>PasswordEncoder</code>接口:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PasswordEncoderImpl</span> <span class="keyword">implements</span> <span class="title">PasswordEncoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">encode</span><span class="params">(CharSequence charSequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> charSequence.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(CharSequence charSequence, String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.equals(charSequence.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重启项目，输入用户名、密码，正常访问。</p>
<h4 id="2-自定义密码加密"><a href="#2-自定义密码加密" class="headerlink" title="2.自定义密码加密"></a>2.自定义密码加密</h4><p>上面我们创建了<code>PasswordEncoderImpl</code>实现类，实现了<code>PasswordEncoder</code>接口，在<code>PasswordEncoderImpl</code>中可以进行一些密码加密(<code>encode</code>)、密码校验(<code>matches</code>)操作。</p>
<p>而我们上面创建的<code>PasswordEncoderImpl</code>并没有进行任何加密、校验，仅仅是<code>toString()</code>的比对。若要实现密码的加密，我们可以直接使用Spring提供的一个<code>BCryptPasswordEncoder</code>类，他实现了<code>PasswordEncoder</code>接口，并重写了加密、校验方法。</p>
<p>修改<code>WebSecurityConfig.java</code>类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改<code>UserDetailsServiceImpl</code>类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDetailsServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Spring Security接收login请求调用UserDetailsService这个接口中的loadUserByUsername方法</span></span><br><span class="line"><span class="comment">     * loadUserByUsername根据传进来的用户名进行校验工作，最后将查询到的用户信息封装到UserDetails这个接口的实现类中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username 用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UsernameNotFoundException 登录异常类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">        String password = passwordEncoder.encode(<span class="string">"123456"</span>);</span><br><span class="line">        log.info(<span class="string">"登录，用户名：&#123;&#125;, 密码：&#123;&#125;"</span>, username, password);</span><br><span class="line">        <span class="comment">//根据用户名查询用户数据，比如：从数据库中查询</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(username, password, AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="string">"admin"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，此时使用了我们像Spring中注入了<code>BCryptPasswordEncoder</code>类，他实现了<code>PasswordEncoder</code>接口，那么我们再次调用<code>PasswordEncoder</code>中的<code>encoder</code>方法其实会调用其实现类<code>BCryptPasswordEncoder</code>中的<code>encoder</code>进行密码加密操作。</p>
<p>所以，我们需要将之前注入的<code>PasswordEncoderImpl</code>类去掉。</p>
<blockquote>
<p>测试</p>
</blockquote>
<p>重启项目，访问<code>localhost:8080/test</code>，在登录页中输入用户名、密码。可以看到控制台打印类似：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">登录，用户名：tycoding, 密码：$2a$10$WAri0CDq74nwaS/L1iU03en/1bgvwTZGsudVczRt5MNA/pO4nTnaa</span><br></pre></td></tr></table></figure>

<p>密码被加密了。并且每次登录，这个密码都会不同，原理和Shiro类似，Spring Security在进行密码加密的时候，也生成了一份随机salt，最终加密的密码=密码+随机salt。</p>
<p>如果我们需要冲数据库中读取数据，这个salt应该直接从数据库中取，而不是再次随机生成。</p>
<h4 id="3-自定义登录请求"><a href="#3-自定义登录请求" class="headerlink" title="3.自定义登录请求"></a>3.自定义登录请求</h4><p>在上面的案例中，我们完成了自定义登录接口、自定义密码加密，但始终都是在Spring Security提供的登录页面操作的，下面我们实现自定义登录请求：</p>
<blockquote>
<p>1.修改控制器类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello I'm TyCoding, this is Login test"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 页面路由，当使用GET请求访问/login接口，会自动跳转到`/templates/login.html`页面</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> login登录页面路由地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/login"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"login"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 页面路由，当使用GET请求访问/login接口，会自动跳转到`/templates/index.html`页面</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> index首页面路由地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/index"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>2.创建<code>index.html</code>和<code>login.html</code></p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>登录页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/auth/login"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">placeholder</span>=<span class="string">"Username"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">placeholder</span>=<span class="string">"Password"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Login"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>3.修改<code>WebSecurityConfig</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * fromLogin(): 表单认证</span></span><br><span class="line"><span class="comment">         * httpBasic(): 弹出框认证</span></span><br><span class="line"><span class="comment">         * authorizeRequests() 身份认证请求</span></span><br><span class="line"><span class="comment">         * anyRequest(): 所有请求</span></span><br><span class="line"><span class="comment">         * authenticated(): 身份认证</span></span><br><span class="line"><span class="comment">         * loginPage(): 登录页面地址（因为SpringBoot无法直接访问页面，所以这通常是一个路由地址）</span></span><br><span class="line"><span class="comment">         * loginProcessingUrl(): 登录表单提交地址</span></span><br><span class="line"><span class="comment">         * .csrf().disable(): 关闭Spring Security的跨站请求伪造的功能</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        http.csrf().disable().formLogin()</span><br><span class="line">                .loginPage(<span class="string">"/login"</span>)</span><br><span class="line">                .loginProcessingUrl(<span class="string">"/auth/login"</span>)</span><br><span class="line"><span class="comment">//        http.httpBasic()</span></span><br><span class="line">                .and()</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">"/login"</span>).permitAll()</span><br><span class="line">                .anyRequest()</span><br><span class="line">                .authenticated();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<p>可以看到，上面我们定义了两个路由接口<code>/login</code>和<code>/index</code>分别路由到<code>/login.html</code>和<code>/index.html</code>页面。<strong>但是</strong>，我们在login.html登录表单中定义的提交地址<code>/auth/login</code>并不在<code>UserController</code>中定义，而是在<code>WebSecurityConfig</code>的<code>loginProcessingUrl</code>中配置了，为什么呢？</p>
<p>回想之前没有进行定制化操作时，登录系统，Spring Security默认拦截所有请求，并将URL 302重定向到<code>/login</code>这个地址，并提供了一个表单登录页面，我们使用Spring Security初始化的用户名和密码即可登录。显然，这个登录页面的地址和表单提交地址在Spring Security中都提供好了。</p>
<p>所以，这里我们直接使用Spring Security提供的登录表单提交地址，即可实现Spring Security的登录校验，这和Shiro的<code>Subject.login()</code>是一个道理，最终都是要将登录数据交由权限框架进行身份校验处理。</p>
<p>在前面Spring Security的过滤器链中提到了<code>UsernamePasswordAuthenticationFilter</code>是最前端的过滤器，用于处理表单提交数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsernamePasswordAuthenticationFilter</span> <span class="keyword">extends</span> <span class="title">AbstractAuthenticationProcessingFilter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SPRING_SECURITY_FORM_USERNAME_KEY = <span class="string">"username"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SPRING_SECURITY_FORM_PASSWORD_KEY = <span class="string">"password"</span>;</span><br><span class="line">    <span class="keyword">private</span> String usernameParameter = <span class="string">"username"</span>;</span><br><span class="line">    <span class="keyword">private</span> String passwordParameter = <span class="string">"password"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> postOnly = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UsernamePasswordAuthenticationFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">new</span> AntPathRequestMatcher(<span class="string">"/login"</span>, <span class="string">"POST"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看源码得知<code>UsernamePasswordAuthenticationFilter</code>接收<code>/login</code> POST请求，那么我们只需要指定我们自己的登录表单最终提交到这个地址即可。所以我们在<code>WebSecurityConfig</code>中定义<code>loginProcessingUrl(&quot;/auth/login&quot;)</code>，当表单提交<code>/auth/login</code>这个地址时，其实最终提交到<code>UsernamePasswordAuthenticationFilter</code>的<code>/login</code>接口，交由<code>UsernamePasswordAuthenticationFilter</code>进行第一层身份过滤，然后经过一系列的过滤器，最判断如果条件满足就通过校验，跳转到目的请求。</p>
<h4 id="5-自定义登录请求状态"><a href="#5-自定义登录请求状态" class="headerlink" title="5.自定义登录请求状态"></a>5.自定义登录请求状态</h4><p>在未进行前后端分离时，通常我们的登录请求是同步的，登录成功或失败都是返回一个视图地址，这用上面的学习完全可以实现（配置<code>.loginPage()</code>即可）。但若前后端分离，登录请求通常是异步的，比如通过ajax请求，此时返回页面视图地址显然不合适。</p>
<p>如果需要自定义登录成功、失败的状态，我们仅需要了解两个handle处理器：<code>AuthenticationSuccessHandler</code>和<code>AuthenticationFailureHandler</code>。他们两个分别用于登录成功和登录失败的处理，我们仅需要创建两个类分别实现这两个接口然后自定义一些逻辑处理即可：</p>
<blockquote>
<p>1.在<code>cn/tycoding/handler/</code>下创建<code>AuthenticationSuccessHandlerImpl</code>:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthenticationSuccessHandlerImpl</span> <span class="keyword">implements</span> <span class="title">AuthenticationSuccessHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthenticationSuccess</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        log.info(<span class="string">"登录成功"</span>);</span><br><span class="line">        httpServletResponse.setContentType(<span class="string">"application/json;charset=utf-8"</span>);</span><br><span class="line">        httpServletResponse.getWriter().write(objectMapper.writeValueAsString(authentication));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>2.创建<code>AuthenticationFailureHandlerImpl</code>:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthenticationFailureHandlerImpl</span> <span class="keyword">implements</span> <span class="title">AuthenticationFailureHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthenticationFailure</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        log.info(<span class="string">"登录失败"</span>);</span><br><span class="line">        httpServletResponse.setStatus(HttpStatus.INTERNAL_SERVER_ERROR.value());</span><br><span class="line">        httpServletResponse.setContentType(<span class="string">"application/json;charset=utf-8"</span>);</span><br><span class="line">        httpServletResponse.getWriter().write(objectMapper.writeValueAsString(e));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>3.测试</p>
</blockquote>
<p>启动项目，分别模拟登录成功和登录失败的情况。</p>
<p><img src="/2019/04/11/boot/spring-boot-security/6.png" alt></p>
<p><img src="/2019/04/11/boot/spring-boot-security/5.png" alt></p>
<hr>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="身份校验流程"><a href="#身份校验流程" class="headerlink" title="身份校验流程"></a>身份校验流程</h3><p><img src="/2019/04/11/boot/spring-boot-security/7.png" alt></p>
<p><img src="/2019/04/11/boot/spring-boot-security/8.png" alt></p>
<p><img src="/2019/04/11/boot/spring-boot-security/9.png" alt></p>
<p><img src="/2019/04/11/boot/spring-boot-security/10.png" alt></p>
<p><img src="/2019/04/11/boot/spring-boot-security/11.png" alt></p>
<p><img src="/2019/04/11/boot/spring-boot-security/12.png" alt></p>
<p><img src="/2019/04/11/boot/spring-boot-security/13.png" alt></p>
<p><img src="/2019/04/11/boot/spring-boot-security/14.png" alt></p>
<p><img src="/2019/04/11/boot/spring-boot-security/15.png" alt></p>
<p><img src="/2019/04/11/boot/spring-boot-security/16.png" alt></p>
<h3 id="认证结果在多个请求中共享"><a href="#认证结果在多个请求中共享" class="headerlink" title="认证结果在多个请求中共享"></a>认证结果在多个请求中共享</h3><p>通常保证认证信息能在多个请求获取，会将认证信息储存在Session中。</p>
<p><img src="/2019/04/11/boot/spring-boot-security/17.png" alt></p>
<p><img src="/2019/04/11/boot/spring-boot-security/18.png" alt></p>
<p><code>SecurityContext</code>其实是<code>Authentication</code>的一个封装，而<code>SecurityContextHolder</code>是<code>ThreadLocal</code>的一个封装。</p>
<p>一般情况下一个请求和响应都是在一个线程中的，而通过<code>SecurityContextHolder</code>将认证信息放到了当前线程中，那么在任何使用该线程的地方调用<code>SecurityContextHolder</code>都能获取到认证数据。</p>
<p>那么最终是由<code>SecurityontextPersistenceFilter</code>使用<code>SecurityContextHolder</code>进行认证信息的读取。</p>
<p><img src="/2019/04/11/boot/spring-boot-security/19.png" alt></p>
<p><code>SecurityontextPersistenceFilter</code>过滤器位于<code>UsernamePasswordAuthenticationFilter</code>过滤器前面，请求和响应都会经过这个过滤器。</p>
<ul>
<li><strong>请求</strong>：检查Session，如果有认证信息，就把认证信息放到当前线程中</li>
<li><strong>响应</strong>：检查线程，如果有认证信息，就把认证信息放到Session中</li>
</ul>
<h3 id="获取当前登录用户信息"><a href="#获取当前登录用户信息" class="headerlink" title="获取当前登录用户信息"></a>获取当前登录用户信息</h3><p>和Shiro不同，我们不需要写很长的代码用于获取当前用户信息，只需要简单的在请求接口参数列表中加入<code>Authentication</code>对象参数即可获取到封装了用户信息的<code>Authentication</code>对象。</p>
<p>修改<code>UserController.java</code>，创建一个新的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前登录用户信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> authentication 封装了当前登录用户信息的Authentication对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 用户信息集合对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/info"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getCurrentUser</span><span class="params">(Authentication authentication)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> authentication;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2019/04/11/boot/spring-boot-security/20.png" alt></p>
<br>

<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>（十三）Spring Boot整合MongoDB</title>
    <url>/2019/03/23/boot/spring-boot-mongo/</url>
    <content><![CDATA[<p>:tada: :tada: :tada: <strong>这里有丰富的 Spring 框架学习案例</strong></p>
<p><strong>仓库地址：<a href="https://github.com/TyCoding/spring-learn" target="_blank" rel="noopener">spring-learn</a></strong><br><strong>欢迎star、fork，给作者一些鼓励</strong><a href="https://github.com/TyCoding/tumo-vue" target="_blank" rel="noopener">https://github.com/TyCoding/tumo-vue</a>)</p>
<h1 id="MongoDB-简介"><a href="#MongoDB-简介" class="headerlink" title="MongoDB 简介"></a>MongoDB 简介</h1><p>MongoDB是一个跨平台的面向文档的数据库，他介于关系型数据库和非关系型数据库之间，储存的数据结构较为松散，是类似JSON的BSON格式，可以存放较为复杂的数据。常用MongoDB储存一些结构复杂、交互频繁、不太重要的数据。</p>
<a id="more"></a>

<h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><ul>
<li><strong>document</strong> – 文档  – 相当于一条记录</li>
<li><strong>collection</strong> – 多个文档组成一个集合  – 相当于一张表</li>
<li><strong>database</strong> – 多个文档组成一个数据库 </li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li><strong>null:</strong> 用于表示空值或不存在的字段， {“x”: null}</li>
<li><strong>数值：</strong> 默认使用64位浮点值，即默认储存的数值为浮点类型，若要储存整数：<code>{&quot;x&quot;: NumberInt(&quot;3&quot;)}</code></li>
<li><strong>布尔值：</strong> true false</li>
<li><strong>数组：</strong>  {“x”: [“a”, “b”]}</li>
<li><strong>内嵌文档：</strong> {“x”: {“y”: 1}}</li>
</ul>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>请查看这篇教程：</p>
<p><a href="https://github.com/TyCoding/spring-learn/blob/master/boot-mongodb/doc/install/install.md" target="_blank" rel="noopener">MongoDB安装教程</a></p>
<p>上面的教程中讲解了在本地电脑安装Mongodb数据库，并且在远程服务器Docker环境下安装了Mongodb。下面我们总结几个常用命令:</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>./mongod --dbpath=../data/db</code></td>
<td align="left">指定上级目录的<code>/data/db</code>文件件为mongodb存放数据的目录</td>
</tr>
<tr>
<td align="left"><code>./mongo</code></td>
<td align="left">启动服务</td>
</tr>
<tr>
<td align="left"><code>exit</code></td>
<td align="left">退出服务</td>
</tr>
<tr>
<td align="left"><code>docker pull mongo</code></td>
<td align="left">在Docker中拉取mongo镜像</td>
</tr>
<tr>
<td align="left"><code>docker run -di --name=vm_mongo -p 27017:27017 mongo</code></td>
<td align="left">创建<code>mongo</code>守护容器，名称为<code>vm_mongo</code>，端口27017</td>
</tr>
<tr>
<td align="left"><code>./mongo ip</code></td>
<td align="left">远程登录</td>
</tr>
</tbody></table>
<h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><p>作为一个介于关系型和非关系型数据库之间的数据库，<code>mongodb</code>有自己独特的SQL语句：</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">讲解</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>use 数据库名称</code></td>
<td align="left">选择数据库，若没有改名称的数据库就自动创建 ，有就选择</td>
</tr>
<tr>
<td align="left"><code>show dbs</code></td>
<td align="left">显示所有数据库名称</td>
</tr>
<tr>
<td align="left"><code>db.集合名.find()</code></td>
<td align="left">查询该数据库的所有数据</td>
</tr>
<tr>
<td align="left"><code>db.集合名.insert()</code></td>
<td align="left">插入一条记录，注意要是JSON格式</td>
</tr>
<tr>
<td align="left"><code>db.mydb.insert({_id: &quot;1&quot;, content: &quot;测试&quot;})</code></td>
<td align="left">插入一条记录，并设置id</td>
</tr>
<tr>
<td align="left"><code>db.mydb.find({_id: &quot;1&quot;})</code></td>
<td align="left">条件查询</td>
</tr>
<tr>
<td align="left"><code>db.mydb.findOne({_id: &quot;1&quot;})</code></td>
<td align="left">仅查询符合条件的一条记录</td>
</tr>
<tr>
<td align="left"><code>db.mydb.find().limit(1)</code></td>
<td align="left">限制查询数量</td>
</tr>
</tbody></table>
<p><img src="/2019/03/23/boot/spring-boot-mongo/1.png" alt></p>
<p>注意，如果使用<code>db.数据库名.insert</code>就会以该数据库名，创建一个同名的集合，将数据放到该集合下。</p>
<p>如果使用<code>db.集合名.insert()</code>就会在该<strong>数据库</strong>下创建一个集合，并将数据放到该集合下。</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">详解</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>db.mydb.update({条件}, {修改内容})</code></td>
<td align="left">修改</td>
</tr>
<tr>
<td align="left"><code>db.mydb.remove(条件)</code></td>
<td align="left">删除，<code>{}</code>删除所有</td>
</tr>
<tr>
<td align="left"><code>db.mydb.count(条件)</code></td>
<td align="left">统计条数，不加条件统计所有</td>
</tr>
</tbody></table>
<h2 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h2><p>使用正则匹配实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.mydb.find(&#123;content: /测试/&#125;)</span><br><span class="line">db.mydb.find(&#123;content: /^试/&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="大于-小于-不等于"><a href="#大于-小于-不等于" class="headerlink" title="大于 小于 不等于"></a>大于 小于 不等于</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.mydb.find(&#123;&quot;age&quot;: &#123; $gt: 12 &#125;&#125;) //age &gt; 12</span><br><span class="line">db.mydb.find(&#123;&quot;age&quot;: &#123; $lt: 12 &#125;&#125;) //age &lt; 12</span><br><span class="line">db.mydb.find(&#123;&quot;age&quot;: &#123; $gte: 12 &#125;&#125;) //age &gt;= 12</span><br><span class="line">db.mydb.find(&#123;&quot;age&quot;: &#123; $lte: 12 &#125;&#125;) //age &lt;= 12</span><br><span class="line">db.mydb.find(&#123;&quot;age&quot;: &#123; $ne: 12 &#125;&#125;) //age != 12</span><br></pre></td></tr></table></figure>

<h2 id="包含、不包含"><a href="#包含、不包含" class="headerlink" title="包含、不包含"></a>包含、不包含</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.mydb.find(&#123;&quot;age&quot;: &#123;$in: [&quot;12&quot;, &quot;18&quot;]&#125;&#125;) //包含</span><br><span class="line">db.mydb.find(&#123;&quot;age&quot;: &#123;$nin: [&quot;12&quot;, &quot;18&quot;]&#125;&#125;) //不包含</span><br></pre></td></tr></table></figure>

<h2 id="条件连接"><a href="#条件连接" class="headerlink" title="条件连接"></a>条件连接</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.mydb.find(&#123;$and: [&#123;&quot;age&quot;: &#123;$gt: 18&#125;&#125;, &#123;&quot;content&quot;: /^测试/&#125;]&#125;)</span><br><span class="line">db.mydb.find(&#123;$or: [&#123;&quot;age&quot;: &#123;$gt: 18&#125;&#125;, &#123;&quot;content&quot;: /^测试/&#125;]&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="列值增长"><a href="#列值增长" class="headerlink" title="列值增长"></a>列值增长</h2><p>实现某个数值在原有基础上增长：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.mydb.update(&#123;_id: &quot;1&quot;&#125;, &#123;$inc: &#123;num: NumberInt(1)&#125;&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="Spring-Data-MongoDB"><a href="#Spring-Data-MongoDB" class="headerlink" title="Spring Data MongoDB"></a>Spring Data MongoDB</h1><p>Spring Data家族也对MongoDB进行了封装支持，如同Spring Data JPA, Spring Data Redis一样，操作MongoDB也变得格外简单。</p>
<h2 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-mongodb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="添加配置"><a href="#添加配置" class="headerlink" title="添加配置"></a>添加配置</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  data:</span></span><br><span class="line"><span class="attr">    mongodb:</span></span><br><span class="line"><span class="attr">      host:</span> <span class="number">192.168</span><span class="number">.160</span><span class="number">.128</span></span><br><span class="line"><span class="attr">      database:</span> <span class="string">commentsdb</span></span><br></pre></td></tr></table></figure>

<p>注意，这里的<code>host</code>我填写的是远程服务器的主机地址。Spring Data MongoDB会自动连接这个远程地址，使用默认的端口号连接远程主机的MongoDB服务。</p>
<h1 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h1><h2 id="创建实体"><a href="#创建实体" class="headerlink" title="创建实体"></a>创建实体</h2><p>创建mongo数据库并插入数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; use commentsdb</span><br><span class="line">&gt; db.comments.insert(&#123;_id: &quot;1&quot;, create_time: new Date(), username: &quot;tycoding&quot;, content: &quot;我是第一条留言&quot;, visits: NumberInt(12)&#125;)</span><br><span class="line">&gt; db.comments.insert(&#123;_id: &quot;2&quot;, create_time: new Date(), username: &quot;tumo&quot;, content: &quot;我是第二条留言&quot;, visits: NumberInt(100)&#125;)</span><br><span class="line">&gt; db.comments.find()</span><br></pre></td></tr></table></figure>

<p>创建<code>Comments.java</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Comments</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> Long _id;</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line">    <span class="keyword">private</span> Long visits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建Dao层"><a href="#创建Dao层" class="headerlink" title="创建Dao层"></a>创建Dao层</h2><p>Spring Data MongoDB提供了一个接口：<code>MongoRepository</code>，这和Spring Data JPA的<code>JpaRepository</code>、Spring Data Redis的<code>RedisRepository</code>很像，封装的方法都类似：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MongoDbRepository</span> <span class="keyword">extends</span> <span class="title">MongoRepository</span>&lt;<span class="title">Comments</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MongoServiceImpl</span> <span class="keyword">implements</span> <span class="title">MongoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MongoDbRepository mongoDbRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Comments&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mongoDbRepository.findAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Comments <span class="title">findById</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mongoDbRepository.findById(id.toString()).get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Comments comments)</span> </span>&#123;</span><br><span class="line">        comments.set_id(<span class="keyword">new</span> Random().nextLong());</span><br><span class="line">        mongoDbRepository.save(comments);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Comments comments)</span> </span>&#123;</span><br><span class="line">        mongoDbRepository.save(comments);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(List&lt;Long&gt; ids)</span> </span>&#123;</span><br><span class="line">        ids.forEach(id -&gt; &#123;</span><br><span class="line">            mongoDbRepository.deleteById(id.toString());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MongoServiceImplTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MongoService mongoService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Comments&gt; list = mongoService.findAll();</span><br><span class="line">        list.forEach(comments -&gt; &#123;</span><br><span class="line">            logger.info(<span class="string">"comments ==&gt; &#123;&#125;"</span>, comments);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findById</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Comments comments = mongoService.findById(<span class="number">1L</span>);</span><br><span class="line">        logger.info(<span class="string">"comments ==&gt; &#123;&#125;"</span>, comments);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Comments comments = <span class="keyword">new</span> Comments();</span><br><span class="line">        comments.setContent(<span class="string">"我是测试类"</span>);</span><br><span class="line">        comments.setCreateTime(<span class="keyword">new</span> Date());</span><br><span class="line">        comments.setUsername(<span class="string">"tycoding"</span>);</span><br><span class="line">        comments.setVisits(<span class="number">12L</span>);</span><br><span class="line">        mongoService.add(comments);</span><br><span class="line">        <span class="keyword">this</span>.findAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Comments comments = <span class="keyword">new</span> Comments();</span><br><span class="line">        comments.set_id(<span class="number">1L</span>);</span><br><span class="line">        comments.setUsername(<span class="string">"我是修改的"</span>);</span><br><span class="line">        mongoService.update(comments);</span><br><span class="line">        <span class="keyword">this</span>.findAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Long&gt; ids = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ids.set(<span class="number">1</span>, <span class="number">2L</span>);</span><br><span class="line">        mongoService.delete(ids);</span><br><span class="line">        <span class="keyword">this</span>.findAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过方法名就能猜到他们的作用，这里就不再解释了。</p>
<br>

<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <categories>
        <category>mongodb</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title>（十四）Spring Boot整合ElasticSearch</title>
    <url>/2019/03/23/boot/spring-boot-es/</url>
    <content><![CDATA[<h1 id="Spring-Boot整合ElasticSearch"><a href="#Spring-Boot整合ElasticSearch" class="headerlink" title="Spring Boot整合ElasticSearch"></a>Spring Boot整合ElasticSearch</h1><p>:tada: :tada: :tada: <strong>这里有丰富的 Spring 框架学习案例</strong></p>
<p><strong>仓库地址：<a href="https://github.com/TyCoding/spring-learn" target="_blank" rel="noopener">spring-learn</a></strong><br><strong>欢迎star、fork，给作者一些鼓励</strong><a href="https://github.com/TyCoding/spring-learn" target="_blank" rel="noopener">https://github.com/TyCoding/spring-learn</a>)</p>
<p>之前我们已经学习了 <a href="https://github.com/TyCoding/spring-boot-learn/tree/master/spring-boot-solr" target="_blank" rel="noopener">Spring Boot整合Solr</a>。而今天学习的ElasticSearch，是一个分布式搜索和分析引擎，他可以帮你用前所未有的速度处理大规模数据，ElasticSearch是建立在Apache Lucene基础上的搜索引擎。</p>
<a id="more"></a>

<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol>
<li>ElasticSearch是分布式的，不需要其他组件，分发是实时的。</li>
<li>ElasticSearch完全支持Apache Lucene的接近实时的搜索</li>
<li>缺点：不够成熟、不够自动化</li>
</ol>
<h2 id="Solr和ElasticSearch"><a href="#Solr和ElasticSearch" class="headerlink" title="Solr和ElasticSearch"></a>Solr和ElasticSearch</h2><ol>
<li>Solr利用Zookeeper进行分布式管理，而ElasticSearch自身带有分布式协调管理功能。</li>
<li>Solr支持更多格式的数据，而ElasticSearch仅支持JSON文件格式。</li>
<li>Solr官方提供的功能更多，而ElasticSearch本身更注重核心功能，高级功能多由第三方插件提供。</li>
<li>Solr在传统的搜索应用中效率优于ElasticSearch，但ElasticSearch更适用于新兴的实时搜索应用。</li>
</ol>
<h1 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h1><p>直接去 <a href="https://www.elastic.co/downloads/" target="_blank" rel="noopener">官网</a> 下载最新版的ElasticSearch安装包，这里使用最新版-6.6.2。解压后的文件如下：</p>
<p><img src="/2019/03/23/boot/spring-boot-es/1.png" alt></p>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>在命令行中进入ElasticSearch安装目录的<code>bin</code>文件夹下，执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./elasticsearch</span><br></pre></td></tr></table></figure>

<p><img src="/2019/03/23/boot/spring-boot-es/2.png" alt></p>
<p>如上证明启动成功。在浏览器上访问：<code>127.0.0.1:9200</code>即会输出ElasticSearch的版本信息。</p>
<p><img src="/2019/03/23/boot/spring-boot-es/3.png" alt></p>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><blockquote>
<p>新建索引</p>
</blockquote>
<p><strong>PUT</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:9200/索引名</span><br></pre></td></tr></table></figure>

<p><img src="/2019/03/23/boot/spring-boot-es/4.png" alt></p>
<blockquote>
<p>新建文档</p>
</blockquote>
<p><strong>POST</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:9200/索引名/文档名</span><br><span class="line"></span><br><span class="line">body: &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2019/03/23/boot/spring-boot-es/5.png" alt></p>
<blockquote>
<p>查询全部文档</p>
</blockquote>
<p><strong>GET</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:9200/索引名/文档名/_search</span><br></pre></td></tr></table></figure>

<p><img src="/2019/03/23/boot/spring-boot-es/6.png" alt></p>
<ul>
<li><code>took：</code>本次操作花费的时间，单位为毫秒。</li>
<li><code>timed_out：</code>请求是否超时_</li>
<li><code>shards：</code>说明本次操作共搜索了哪些分片</li>
<li><code>hits：</code>搜索命中的记录</li>
<li><code>hits.total：</code> 符合条件的文档总数</li>
<li><code>hits.hits：</code>匹配度较高的前N个文档</li>
<li><code>hits.max_score：</code>文档匹配得分，这里为最高分</li>
<li><code>_score：</code>每个文档都有一个匹配度得分，按照降序排列。</li>
<li><code>_source：</code>显示了文档的原始内容。</li>
</ul>
<blockquote>
<p>修改文档</p>
</blockquote>
<p><strong>PUT</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:9200/索引名/文档名/ID</span><br></pre></td></tr></table></figure>

<p><img src="/2019/03/23/boot/spring-boot-es/7.png" alt></p>
<p><strong>如果该ID指定的文档不存在，就以该ID创建新的文档</strong></p>
<p><img src="/2019/03/23/boot/spring-boot-es/8.png" alt></p>
<blockquote>
<p>按ID查询</p>
</blockquote>
<p><strong>GET</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:9200/索引名/文档名/ID</span><br></pre></td></tr></table></figure>

<blockquote>
<p>基本条件查询</p>
</blockquote>
<p><strong>GET</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:9200/索引名/文档名/_search?q=条件</span><br></pre></td></tr></table></figure>

<blockquote>
<p>模糊查询</p>
</blockquote>
<p><strong>GET</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:9200/索引名/文档名/_search?q=*条件*</span><br></pre></td></tr></table></figure>

<blockquote>
<p>删除文档</p>
</blockquote>
<p><strong>DELETE</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:9200/索引名/文档名/ID</span><br></pre></td></tr></table></figure>

<h2 id="安装ElasticSearch-Head"><a href="#安装ElasticSearch-Head" class="headerlink" title="安装ElasticSearch-Head"></a>安装ElasticSearch-Head</h2><p>使用Solr时，Solr自身提供了一个非常方面的可视化界面，但ElasticSearch官方并未提供，这里使用第三方插件ElasticSearch-Head来完成对ElasticSearch的可视化操作。</p>
<blockquote>
<p>去Github下载elasticsearch-head源码</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/mobz/elasticsearch-head.git</span><br></pre></td></tr></table></figure>

<blockquote>
<p>全局安装grunt项目构建工具</p>
</blockquote>
<p>首先你的电脑要安装Node.js开发环境。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo npm install -g grunt-cli</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在elasticsearch-head目录下安装依赖</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>

<blockquote>
<p>修改ElasticSearch配置文件<code>/config/elasticsearch.yml</code></p>
</blockquote>
<p>允许跨域访问，在配置文件中增加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>启动head</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grunt server</span><br></pre></td></tr></table></figure>

<p>浏览器访问：<code>localhost:9100</code></p>
<p><img src="/2019/03/23/boot/spring-boot-es/9.png" alt></p>
<h2 id="安装IK分词器"><a href="#安装IK分词器" class="headerlink" title="安装IK分词器"></a>安装IK分词器</h2><p>和Solr一样，ElasticSearch也需要安装IK分析器以实现对中文更好的分词支持。</p>
<blockquote>
<p>去Github下载最新版elasticsearch-ik</p>
</blockquote>
<p><a href="https://github.com/medcl/elasticsearch-analysis-ik/releases" target="_blank" rel="noopener">https://github.com/medcl/elasticsearch-analysis-ik/releases</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/medcl/elasticsearch-analysis-ik/releases</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解压文件，并将文件夹重命名为<code>ik</code></p>
</blockquote>
<p><img src="/2019/03/23/boot/spring-boot-es/10.png" alt></p>
<blockquote>
<p>将<code>ik</code>文件夹放在<code>elasticsearch/plugins</code>目录下，重启elasticsearch</p>
</blockquote>
<p>在ElasticSearch6之前的版本，直接访问：<code>http://127.0.0.1:9200/_analyze?analyzer=ik_max_word&amp;pretty=true&amp;text=测试IK分词器</code> 即可展示分词效果。</p>
<p>但是在ElasticSearch6开始的版本中，分词查询要用GET、POST请求，但要把请求参数写在body中，且需要JSON格式。</p>
<p><img src="/2019/03/23/boot/spring-boot-es/11.png" alt></p>
<h3 id="扩展词典"><a href="#扩展词典" class="headerlink" title="扩展词典"></a>扩展词典</h3><p>在<code>elasticsearch/plugins/ik/config</code>下新建<code>my.dic</code>文件，在<code>my.dic</code>中写入想要分词识别的文字；修改<code>IKAnalyzer.cfg.xml</code>文件，在<code>&lt;entry key=&quot;ext_dict&quot;&gt;</code>中指定<code>my.dic</code>。</p>
<p>重启elasticsearch即可看到分词效果。</p>
<h1 id="Spring-Data-ElasticSearch"><a href="#Spring-Data-ElasticSearch" class="headerlink" title="Spring Data ElasticSearch"></a>Spring Data ElasticSearch</h1><p>Spring Data家族对ElasticSearch也进行了封装支持，使用<strong>spring-data-elasticsearch</strong>，就像使用<strong>spring-data-jpa</strong>,<strong>spring-data-solr</strong>,<strong>spring-data-redis</strong>,<strong>spring-data-mongodb</strong>等一样操作简单，他们封装的方法类似，提供的接口格式都基本相同，所以开发流程也基本是一样的。</p>
<h2 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="添加配置"><a href="#添加配置" class="headerlink" title="添加配置"></a>添加配置</h2><p>修改<code>application.yml</code>配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  data:</span></span><br><span class="line"><span class="attr">    elasticsearch:</span></span><br><span class="line"><span class="attr">      cluster-nodes:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9300</span></span><br></pre></td></tr></table></figure>

<h2 id="Entity"><a href="#Entity" class="headerlink" title="Entity"></a>Entity</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Document</span>(indexName = <span class="string">"articleindex"</span>, type = <span class="string">"article"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Article</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field</span>(index = <span class="keyword">true</span>, analyzer = <span class="string">"ik_max_word"</span>, searchAnalyzer = <span class="string">"ik_max_word"</span>)</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field</span>(index = <span class="keyword">true</span>, analyzer = <span class="string">"ik_max_word"</span>, searchAnalyzer = <span class="string">"ik_max_word"</span>)</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为避免类型转换错误，请将<code>id</code>设置为String类型。</p>
<p>其中<code>indexName</code>代表ES索引名称，<code>type</code>代表文档名称。</p>
<ul>
<li><code>index=true</code>代表是否开启索引，即该字段数据是否能被搜索到</li>
<li><code>analyzer=&quot;ik_max_word&quot;</code>代表搜索的时候是如何分词匹配，<code>ik_max_word</code>使用IK分词器最细颗粒度分词查询。</li>
<li><code>searchAnalyzer = &quot;ik_max_word&quot;</code>搜索分词的类型</li>
</ul>
<h2 id="Repository"><a href="#Repository" class="headerlink" title="Repository"></a>Repository</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EsRepository</span> <span class="keyword">extends</span> <span class="title">ElasticsearchRepository</span>&lt;<span class="title">Article</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据文章标题或内容模糊查询</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> title</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pageable</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Page&lt;Article&gt; <span class="title">findByTitleOrContentLike</span><span class="params">(String title, String content, Pageable pageable)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>联想solr,redis,jpa,mongodb，基本都是依赖继承一个<code>XxxRepository</code>接口即可，并且对于IDEA，如果继承了<code>XxxRepository</code>接口，IDEA会自动提示自定义查询方法的构建：</p>
<p><img src="/2019/03/23/boot/spring-boot-es/12.png" alt></p>
<p>如上的<code>findByTitleOrContentLike</code>就是根据<code>Title</code>或者<code>Cotent</code>字段<code>Like</code>模糊查询。</p>
<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueryPage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前页</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer current;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每页记录数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EsServiceImpl</span> <span class="keyword">implements</span> <span class="title">EsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EsRepository esRepository;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Article article)</span> </span>&#123;</span><br><span class="line">        esRepository.save(article);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Page&lt;Article&gt; <span class="title">search</span><span class="params">(String keyword, QueryPage queryPage)</span> </span>&#123;</span><br><span class="line">        PageRequest pageRequest = PageRequest.of(queryPage.getCurrent() - <span class="number">1</span>, queryPage.getSize());</span><br><span class="line">        <span class="keyword">return</span> esRepository.findByTitleOrContentLike(keyword, keyword, pageRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>因为，在Solr，ElasticSearch中，分页查询，默认都是从<code>0</code>索引位置开始的，和Mybatis中的分页查询不同，所以需要<code>current -1</code>。</li>
<li>其次，同Solr，用户查询的字段是不确定的，可能查询多个字段，所以需要根据用户输入的数据去ElasticSearch中模糊匹配所有字段，以此实现模糊查询。</li>
</ul>
<h2 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EsServiceImplTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EsService esService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Article article = <span class="keyword">new</span> Article();</span><br><span class="line">        article.setId(<span class="string">"1"</span>);</span><br><span class="line">        article.setTitle(<span class="string">"测试添加文章索引"</span>);</span><br><span class="line">        article.setContent(<span class="string">"这是测试数据"</span>);</span><br><span class="line">        esService.add(article);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">search</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        QueryPage page = <span class="keyword">new</span> QueryPage();</span><br><span class="line">        page.setCurrent(<span class="number">1</span>);</span><br><span class="line">        page.setSize(<span class="number">10</span>);</span><br><span class="line">        Page&lt;Article&gt; list = esService.search(<span class="string">"测试"</span>, page);</span><br><span class="line">        list.forEach(article -&gt; &#123;</span><br><span class="line">            logger.info(<span class="string">"article ==&gt; &#123;&#125;"</span>, article);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，添加时，如果指定<code>id</code>字段，这个id值如果在ES文档中有匹配的，就是更新操作，如果没有就是添加操作</p>
<h1 id="实现Mysql导入Es"><a href="#实现Mysql导入Es" class="headerlink" title="实现Mysql导入Es"></a>实现Mysql导入Es</h1><blockquote>
<p>下载logstash</p>
</blockquote>
<p><a href="https://www.elastic.co/cn/downloads/logstash" target="_blank" rel="noopener">logstash官网</a></p>
<blockquote>
<p>解压文件，并在其根目录下创建<code>mysqletc</code>文件夹（名称随意）</p>
</blockquote>
<p><img src="/2019/03/23/boot/spring-boot-es/14.png" alt></p>
<blockquote>
<p>在<code>mysqletc</code>文件夹下创建<code>mysql.conf</code>（名称随意）</p>
</blockquote>
<p>在<code>mysql.conf</code>配置文件中写入如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  jdbc &#123;</span><br><span class="line">    # 数据库连接语句</span><br><span class="line">    jdbc_connection_string =&gt; &quot;jdbc:mysql://127.0.0.1:3306/springboot_es?characterEncoding=UTF8&quot;</span><br><span class="line">    jdbc_user =&gt; &quot;root&quot;</span><br><span class="line">    jdbc_password =&gt; &quot;root&quot;</span><br><span class="line">    # mysql-connection驱动的绝对路径</span><br><span class="line">    jdbc_driver_library =&gt; &quot;/develop/software/logstash-6.6.2/mysqletc/mysql-connector-java-5.1.47.jar&quot;</span><br><span class="line">    jdbc_driver_class =&gt; &quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line">    jdbc_paging_enabled =&gt; &quot;true&quot;</span><br><span class="line">    jdbc_page_size =&gt; &quot;50000&quot;</span><br><span class="line">    # SQL查询语句，用于将查询到的数据导入到ElasticSearch</span><br><span class="line">    statement =&gt; &quot;select id,title,content from tb_article&quot;</span><br><span class="line">    # 定时任务，各自表示：分 时 天 月 年 。全部为 * 默认每分钟执行</span><br><span class="line">    schedule =&gt; &quot;* * * * *&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    hosts =&gt; &quot;localhost:9200&quot;</span><br><span class="line">    # 索引名称</span><br><span class="line">    index =&gt; &quot;aritcleindex&quot;</span><br><span class="line">    # 自增ID编号</span><br><span class="line">    document_id =&gt; &quot;%&#123;id&#125;&quot;</span><br><span class="line">    # 文档名称</span><br><span class="line">    document_type =&gt; &quot;article&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  stdout &#123;</span><br><span class="line">    # JSON格式输出</span><br><span class="line">    codec =&gt; json_lines</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置完成，找一个<code>mysql-connection.jar</code>包拷贝到<code>/mysqletc/</code>根目录下，并修改配置文件中的<code>jdbc_driver_library</code>路径地址。</p>
<blockquote>
<p>创建数据库</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> springboot_es <span class="keyword">DEFAULT</span> <span class="built_in">CHARACTER</span> utf8;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`tb_article`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`tb_article`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line">  <span class="string">`title`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'文章标题'</span>,</span><br><span class="line">  <span class="string">`content`</span> <span class="built_in">text</span> <span class="keyword">COMMENT</span> <span class="string">'文章内容'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">3</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`tb_article`</span> <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">'测试'</span>, <span class="string">'测试'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`tb_article`</span> <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">'测试啊'</span>, <span class="string">'测试啊'</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在终端中切换到<code>logstash</code>根目录下</p>
</blockquote>
<p>执行<code>logstash -f ../mysqletc/mysql.conf</code>：</p>
<p><img src="/2019/03/23/boot/spring-boot-es/15.png" alt></p>
<p>并且查询语句会每分钟执行一次。</p>
<h1 id="Docker中部署ElasticSearch"><a href="#Docker中部署ElasticSearch" class="headerlink" title="Docker中部署ElasticSearch"></a>Docker中部署ElasticSearch</h1><blockquote>
<p>拉取elasticsearch镜像</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull elasticsearch:6.6.2</span><br></pre></td></tr></table></figure>

<blockquote>
<p>创建一个容器</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker run -di --name=vm_es -p 9200:9200 -p 9300:9300 elasticsearch:6.6.2</span><br></pre></td></tr></table></figure>

<p>此时该容器就正在启动中，你可以稍等，在本地浏览器上访问：<code>http://ip:9200</code>地址（IP是虚拟机的IP地址），如果出现ElasticSearch的版本信息就证明启动成功</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>如果访问这个地址一直显示连接不上，并且<code>docker ps</code>查看我们刚创建的<code>vm_es</code>容器并没有启动，很可能是Linux默认分配的虚拟内存太小了，可以尝试修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# cat /proc/sys/vm/max_map_count</span><br><span class="line">65530</span><br><span class="line">[root@localhost ~]# sysctl -w vm.max_map_count=262144</span><br><span class="line">vm.max_map_count = 262144</span><br></pre></td></tr></table></figure>

<h2 id="Docker容器中ES服务配置IK分词器"><a href="#Docker容器中ES服务配置IK分词器" class="headerlink" title="Docker容器中ES服务配置IK分词器"></a>Docker容器中ES服务配置IK分词器</h2><blockquote>
<p>首先Docker elasticsearch，查看安装目录</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker exec -it vm_es /bin/bash</span><br><span class="line">[root@bcf04318cdab elasticsearch]# cd ..</span><br><span class="line">[root@bcf04318cdab share]# cd ..</span><br><span class="line">[root@bcf04318cdab usr]#</span><br></pre></td></tr></table></figure>

<p>可以看到<code>elasticsearch</code>在Docker中的安装目录为：<code>/usr/share/elasticsearch</code>。
<strong>注意</strong>直接在宿主机上访问这个地址是不存在的，这个地址是在Docker虚拟路径下的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# cd /usr/share/elasticsearch</span><br><span class="line">-bash: cd: /usr/share/elasticsearch: 没有那个文件或目录</span><br></pre></td></tr></table></figure>

<blockquote>
<p>复制本地的<code>ik</code>文件夹到远程宿主机上</p>
</blockquote>
<p>发送文档到虚拟机上有很多方式，这里使用<code>scp</code>命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp /develop/software/elasticsearch/plugins/ik root@192.168.160.128:/root/</span><br></pre></td></tr></table></figure>

<blockquote>
<p>用Docker命令将宿主机上的文件拷贝到Docker-es容器中</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# cd /root</span><br><span class="line">[root@localhost ~]# ls</span><br><span class="line">anaconda-ks.cfg  ik</span><br><span class="line">[root@localhost ~]# docker cp ik vm_es:/usr/share/elasticsearch/plugins</span><br></pre></td></tr></table></figure>

<blockquote>
<p>重启ES容器</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker restart vm_es</span><br></pre></td></tr></table></figure>

<p>执行这个重启命令，通过<code>docker ps</code>命令发现，ES服务启动一会就又关闭了，</p>
<p><img src="/2019/03/23/boot/spring-boot-es/16.png" alt></p>
<p>执行<code>docker logs vm_es</code>查看<code>vm_es</code>容器的日志：</p>
<p><img src="/2019/03/23/boot/spring-boot-es/17.png" alt></p>
<p>此时，心里真TM一万个草泥马在奔腾。只好<code>docker rm vm_es</code>删除镜像，重新创建。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker run -di --name=vm_es -p 9200:9200 -p 9300:9300 elasticsearch:6.6.2</span><br></pre></td></tr></table></figure>

<p>进入到<code>vm_es</code>容器内：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@3e01ce5eb235 elasticsearch]# cd plugins </span><br><span class="line">[root@3e01ce5eb235 plugins]# ls -la </span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x. 4 elasticsearch root  51 Mar  6 15:19 .</span><br><span class="line">drwxrwxr-x. 1 elasticsearch root  44 Mar  6 15:20 ..</span><br><span class="line">drwxr-xr-x. 2 elasticsearch root 264 Mar  6 15:19 ingest-geoip</span><br><span class="line">drwxr-xr-x. 2 elasticsearch root 114 Mar  6 15:19 ingest-user-agent</span><br></pre></td></tr></table></figure>

<p>此时看到<code>vm_es</code>内部文件夹的访问权限如上，但是查看自己上传的<code>ik</code>文件夹的权限：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ls -la</span><br><span class="line">drwx------.  3 root root  243 3月  20 09:44 ik</span><br></pre></td></tr></table></figure>

<p>明显发现权限不对，于是修改<code>ik</code>文件夹的访问权限：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# chmod a+x+r ik</span><br><span class="line">[root@localhost ~]# ls -la</span><br><span class="line">drwx--x--x.  3 root root  243 3月  20 09:44 ik</span><br></pre></td></tr></table></figure>

<p>然后再拷贝到Docker内ES容器<code>plugins</code>目录下，重启ES，启动成功。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker cp ik vm_es:/usr/share/elasticsearch/plugins</span><br></pre></td></tr></table></figure>

<h2 id="Docker容器中ES服务配置HEAD插件"><a href="#Docker容器中ES服务配置HEAD插件" class="headerlink" title="Docker容器中ES服务配置HEAD插件"></a>Docker容器中ES服务配置HEAD插件</h2><p>在本地配置HEAD插件，是直接在<code>HEAD</code>官网下载，然后启动HEAD内置的服务器，直接在页面访问：<code>localhost:9100</code>即可，而在Docker中，提供了HEAD的镜像，我们只需要pull下来即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull mobz/elasticsearch-head:5</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行容器</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -di --name=vm_es_head -p 9100:9100 mobz/elasticsearch-head:5</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong> 如果运行容器时遇到如下错误，尝试重启Docker服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables failed: iptables --wait -t nat -A DOCKER -p tcp -d 0/0 --dport 5000 -j DNAT --to-destination 172.18.0.4:5000 ! -i br-ff45d935188b: iptables: No chain/target/match by that name. (exit status 1)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行ES容器，并进入容器内部修改<code>elasticsearch.yml</code>允许跨域访问</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker start vm_es</span><br><span class="line">[root@localhost ~]# docker exec -it vm_es /bin/bash</span><br><span class="line">[root@3e01ce5eb235 elasticsearch]# cd config</span><br><span class="line">[root@3e01ce5eb235 config]# vi elasticsearch.yml</span><br><span class="line"></span><br><span class="line"># 添加如下：</span><br><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>重启ES容器</p>
</blockquote>
<p><img src="/2019/03/23/boot/spring-boot-es/18.png" alt></p>
<p><img src="/2019/03/23/boot/spring-boot-es/19.png" alt></p>
<h1 id="连接远程ElasticSearch服务"><a href="#连接远程ElasticSearch服务" class="headerlink" title="连接远程ElasticSearch服务"></a>连接远程ElasticSearch服务</h1><p>上面在远程服务器Docker上部署了ElasticSearch服务，下面我们可以测试用<code>spring-data-elasticsearch</code>连接远程ES服务。</p>
<h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  data:</span></span><br><span class="line"><span class="attr">    elasticsearch:</span></span><br><span class="line">      <span class="comment"># cluster-nodes: 127.0.0.1:9300</span></span><br><span class="line"><span class="attr">      cluster-nodes:</span> <span class="number">192.168</span><span class="number">.160</span><span class="number">.128</span><span class="string">:9300</span></span><br><span class="line"><span class="attr">      cluster-name:</span> <span class="string">docker-cluster</span></span><br></pre></td></tr></table></figure>

<p>注意，和本地ES服务不同的除了要修改<code>cluster-nodes</code>对应的IP地址，还要指定<code>cluster-name</code>，如何查看远程ES服务的<code>cluster-name</code>值呢？</p>
<blockquote>
<p>进入到远程Docker的ES服务中</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost /]# docker exec -it vm_es /bin/bash</span><br></pre></td></tr></table></figure>

<p>这个<code>vm_es</code>是我创建的ES服务名称。</p>
<p>然后会进入到Docker中ES安装文件地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost /]# docker exec -it vm_es /bin/bash</span><br><span class="line">[root@bcf04318cdab elasticsearch]# ls</span><br><span class="line">LICENSE.txt  NOTICE.txt  README.textile  bin  config  data  lib  logs  modules  plugins</span><br></pre></td></tr></table></figure>

<blockquote>
<p>进入到<code>config/</code>文件夹下，编辑配置文件<code>elasticsearch.yml</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我这里测试的可以直接通过`vi`命令编辑</span><br><span class="line"></span><br><span class="line">[root@bcf04318cdab elasticsearch]# cd config</span><br><span class="line">[root@bcf04318cdab config]# vi elasticsearch.yml</span><br></pre></td></tr></table></figure>

<p>就能看到此ES服务的<code>cluster-name</code>值</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>执行配置文件中的<code>save</code>方法，测试添加功能。</p>
<br>

<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <categories>
        <category>mongodb</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title>Permission - 一个基于SpringBoot2+Shiro的权限管理系统</title>
    <url>/2019/03/17/project/permission/</url>
    <content><![CDATA[<p><img src="/2019/03/17/project/permission/9.png" alt></p>
<p><strong>仓库源码地址：<a href="https://github.com/TyCoding/permission" target="_blank" rel="noopener">https://github.com/TyCoding/permission</a></strong></p>
<p>之前有学习了 <a href="https://jinnianshilongnian.iteye.com/blog/2018936" target="_blank" rel="noopener">张开涛老师</a> 老师的作品写的一个简单的 <a href="https://github.com/TyCoding/shiro" target="_blank" rel="noopener">Shiro入门级权限管理项目</a>，但由于一些原因感觉学习的不够深入，最近仔细拜读了 <a href="https://github.com/wuyouzhuguli" target="_blank" rel="noopener">wuyouzhuguli</a> 大神的作品，学习到了很多，顾写下此项目实战练习。 </p>
<p><strong>欢迎大家clone下来学习，如果可以，希望能点亮右上角star, fork，给作者一些鼓励</strong></p>
<a id="more"></a>

<p><strong>线上地址：</strong> <a href="http://39.105.46.235:8083/login" target="_blank" rel="noopener">http://39.105.46.235:8083/login</a></p>
<table>
<thead>
<tr>
<th>用户名</th>
<th>密码</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>admin</td>
<td>123456</td>
<td>管理员，拥有所有权限</td>
</tr>
<tr>
<td>tycoding</td>
<td>123456</td>
<td>测试账号，可查看所有页面，但无操作权限</td>
</tr>
<tr>
<td>tumo</td>
<td>123456</td>
<td>用户管理员</td>
</tr>
</tbody></table>
<h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><ul>
<li><a href="https://github.com/wuyouzhuguli" target="_blank" rel="noopener">wuyouzhuguli</a> </li>
</ul>
<p>可以说<strong>本项目</strong>仅是一个学习的项目，非常感谢这位大神的作品：<a href="https://github.com/wuyouzhuguli/FEBS-Shiro" target="_blank" rel="noopener">https://github.com/wuyouzhuguli/FEBS-Shiro</a>，<strong>本项目</strong>就来自学习了大神的项目后把自己理解的部分（加上自己的代码风格、思路）写了出来。欢迎大家学习这个项目，相信对大家的学习很有帮助。</p>
<h2 id="功能模块"><a href="#功能模块" class="headerlink" title="功能模块"></a>功能模块</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├─项目文档(Swagger2.0)</span><br><span class="line">├─系统管理</span><br><span class="line">│  ├─用户管理</span><br><span class="line">│  ├─角色管理</span><br><span class="line">│  ├─菜单管理</span><br><span class="line">│  └─部门管理</span><br><span class="line">├─系统监控</span><br><span class="line">│  ├─在线用户</span><br><span class="line">│  ├─登录日志</span><br><span class="line">│  ├─系统日志</span><br><span class="line">│  ├─Redis监控</span><br><span class="line">│  └─Druid监控</span><br><span class="line">├─对象储存</span><br><span class="line">│  ├─七牛云</span><br><span class="line">│─网络资源</span><br><span class="line">│  ├─天气查询</span><br><span class="line">│  └─影视资讯</span><br></pre></td></tr></table></figure>

<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><ul>
<li><p><a href="https://tycoding.cn/2019/01/25/boot/springboot-shiro/" target="_blank" rel="noopener">在基于SpringBoot的前后端分离项目中使用Shiro</a></p>
</li>
<li><p><a href="https://tycoding.cn/2019/02/16/ssm/shiro/54-shiro-session/" target="_blank" rel="noopener">Shiro在线会话管理</a></p>
</li>
<li><p><a href="https://tycoding.cn/2019/01/30/ssm/shiro/shiro-tree/" target="_blank" rel="noopener">Shiro权限管理项目中如何构建权限菜单</a></p>
</li>
<li><p><a href="https://tycoding.cn/2019/02/16/ssm/shiro/53-shiro-tree2-md/" target="_blank" rel="noopener">ElementUI - Tree &amp; Shiro</a></p>
</li>
<li><p>文档正在完善中…</p>
</li>
</ul>
<h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><ul>
<li><p>基础框架： Spring Boot 2.1.2.RELEASE</p>
</li>
<li><p>持久层框架： MyBatis 3.4.6 </p>
</li>
<li><p>权限框架： Shiro 1.4.0</p>
</li>
<li><p>模板引擎： Thymeleaf 3.0.11.RELEASE</p>
</li>
<li><p>缓存框架： Redis </p>
</li>
<li><p>其他： Swagger2、七牛云、Mybatis通用Mapper、druid、Logback、fastjson、pageHelper</p>
</li>
</ul>
<h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><ul>
<li><p>基础框架： ElementUI</p>
</li>
<li><p>JavaScript插件： Vue.js</p>
</li>
</ul>
<h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><ul>
<li><p>语言： JDK1.8</p>
</li>
<li><p>IDE： IDEA 2018.3</p>
</li>
<li><p>依赖管理： Maven</p>
</li>
<li><p>数据库： Mysql 5.7.24</p>
</li>
</ul>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>如果你看到技术选型可能会疑问前面完全依赖Vue.js，为何还是HTML页面？没错，前端是完全依赖Vue.js的，整个项目都没有用到JQuery。如果你学过Vue肯定熟悉NPM，Vue官方也推荐使用NPM开发，但为了更方便部署学习，这里使用HTML + Thymeleaf 解析页面。</p>
<p>虽然用了Thymeleaf，但也仅是用来解析页面视图地址，并没有在数据层用到Thymeleaf，所有的数据都依赖vue-resource异步获取，我以一张简单的图来解释项目交互流程：</p>
<p><img src="http://cdn.tycoding.cn/20190315204846.png" alt></p>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>由于一些原因，<strong>线上地址</strong>部署的项目不太完美，请clone到本地运行。</p>
<ol>
<li>克隆</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/TyCoding/permission.git</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>使用IDEA打开<code>permission</code>项目，创建数据库（执行<code>db/sys_schema.sql</code>）。</p>
</li>
<li><p>修改<code>application.yml</code>中MySQL、Redis连接信息。（如果需要七牛云另完善七牛云的信息）。</p>
</li>
<li><p>配置好Redis，启动Redis服务。</p>
</li>
<li><p>启动项目，访问<code>localhost:8080</code></p>
</li>
<li><p>更多的文档后续补充…</p>
</li>
</ol>
<h2 id="项目截图"><a href="#项目截图" class="headerlink" title="项目截图"></a>项目截图</h2><p><img src="/2019/03/17/project/permission/1.png" alt></p>
<p><img src="/2019/03/17/project/permission/2.png" alt></p>
<p><img src="/2019/03/17/project/permission/3.png" alt></p>
<p><img src="/2019/03/17/project/permission/4.png" alt></p>
<p><img src="/2019/03/17/project/permission/5.png" alt></p>
<p><img src="/2019/03/17/project/permission/6.png" alt></p>
<p><img src="/2019/03/17/project/permission/7.png" alt></p>
<p><img src="/2019/03/17/project/permission/8.png" alt></p>
<p><img src="/2019/03/17/project/permission/9.png" alt></p>
<p><img src="/2019/03/17/project/permission/10.png" alt></p>
<p><img src="/2019/03/17/project/permission/11.png" alt></p>
<p><img src="/2019/03/17/project/permission/12.png" alt></p>
<p><img src="/2019/03/17/project/permission/13.png" alt></p>
<br>

<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <categories>
        <category>shiro</category>
      </categories>
      <tags>
        <tag>shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础回顾（一）</title>
    <url>/2019/03/12/java/java-base01/</url>
    <content><![CDATA[<h1 id="对象与类"><a href="#对象与类" class="headerlink" title="对象与类"></a>对象与类</h1><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p>比如<code>Student s = new Student()</code>实例化一个对象，其实经历了如下几个过程：</p>
<ol>
<li>将<code>Student.class</code>加载到内存中</li>
<li>在<strong>栈内存</strong>中给<code>s</code>开辟内存空间。</li>
<li>在<strong>堆内存</strong>给<code>Student</code>类申请一个内存空间。</li>
<li>给成员变量进行默认初始化，0 null false…</li>
<li>自定义给成员变量初始化赋值</li>
<li>初始化完毕，把堆内存地址赋值给栈内存的<code>s</code>变量</li>
</ol>
<a id="more"></a>

<h2 id="Main方法剖析"><a href="#Main方法剖析" class="headerlink" title="Main方法剖析"></a>Main方法剖析</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>public</code>: 公共的，访问权限最大，因为main方法是被JVM调用的。</li>
<li><code>static</code>：静态的，不需要创建对象，通过类名就能调用，方便JVM调用。</li>
<li><code>void</code>: 无返回值，因为main方法是被JVM调用的，所以给JVM返回数据没有意义。</li>
<li><code>main</code>: 常见的方法入口，很多语言的入口方法都是main方法。</li>
<li><code>String[] args</code>: 字符串数组，是作为命令行参数调用的。</li>
</ul>
<h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><p><code>static</code>关键字特点：（可以修饰成员变量，也可修饰成员方法）</p>
<ul>
<li>随着类的加载而加载</li>
<li>优先于对象存在</li>
<li>被类中的所有对象共享</li>
<li>可直接通过类名调用</li>
</ul>
<p><strong>拓展</strong></p>
<p>静态方法中没有<code>this</code>关键字，因为<code>this</code>代表当前方法对象，但<code>static</code>优于对象存在，所以在对象还未创建完毕<code>static</code>修饰的方法就被调用，此时<code>this</code>代表的对象还未创建。</p>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p><code>String</code>底层定义为<code>public final class String</code>，说明<code>String</code>是常量，一旦被创建就不能修改。可以查看如Integer Long String这些类的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Integer</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Long</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这些<strong>基本类型</strong>，在初始化值、赋值时都是先<strong>从常量池中</strong>取数据，如果常量池中没有该数据，就<code>new</code>对象初始化为新数据。</p>
<p>比如常见的一个面试题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">"ab"</span>;</span><br><span class="line">s = <span class="string">"abc"</span>;</span><br><span class="line">String ss = <span class="string">"ab"</span>;</span><br><span class="line">ss = <span class="keyword">new</span> String(<span class="string">"ab"</span>);</span><br></pre></td></tr></table></figure>

<p>这个<code>s</code>和<code>ss</code>各自创建了几个对象？答案：<code>s</code>创建两个对象；<code>ss</code>创建一个对象。因为<code>s</code>的常量池中有值<code>ab</code>，而重新赋值<code>s = &quot;abc&quot;</code>这个<code>abc</code>在<code>s</code>的常量池中不存在，所以<code>new String()</code>创建了一个新对象。<code>ss</code>同理分析。可以通过如下方式验证：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String ss = <span class="string">"ab"</span>;</span><br><span class="line">System.out.println(ss.hashCode());</span><br><span class="line">ss = <span class="string">"abc"</span>;</span><br><span class="line">System.out.println(ss.hashCode());</span><br></pre></td></tr></table></figure>

<p><img src="http://cdn.tycoding.cn/2019031184233.png" alt></p>
<h3 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h3><p><code>String</code>是不可变的字符串，<code>StringBuffer</code>是线程安全的可变字符串，用<code>StringBuffer</code>做字符串的拼接可以避免资源的浪费，因为<code>String</code>每次拼接新的字符串都是创建一个新的String对象。</p>
<p><strong>String转换为StringBuffer</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一</span></span><br><span class="line">String s = <span class="string">"hello"</span>;</span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(s);</span><br><span class="line"><span class="comment">//方式二</span></span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">sb.append(s);</span><br></pre></td></tr></table></figure>

<p><strong>StringBuffer转换成String</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一</span></span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">"hello"</span>);</span><br><span class="line">String s = <span class="keyword">new</span> String(sb);</span><br><span class="line"><span class="comment">//方式二</span></span><br><span class="line">String s = sb.toString();</span><br></pre></td></tr></table></figure>

<h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><blockquote>
<p>String, StringBuffer, StringBuilder 的区别？</p>
</blockquote>
<ul>
<li>String的内容不可变，StringBuffer和StringBuilder的内容都可变。</li>
<li>StringBuffer是线程同步的，数据安全，效率低；String和StringBuilder是线程不同步的，数据不安全，效率高。</li>
</ul>
<blockquote>
<p>StringBuffer和数组的区别？</p>
</blockquote>
<ul>
<li>二者都是一个容器，装其他数据</li>
<li>但StringBuffer最终是一个字符串数据；而数组可以存放多种数据，但必须是用一种数据类型。</li>
</ul>
<blockquote>
<p>String和StringBuffer作为参数传递</p>
</blockquote>
<ul>
<li>String可理解为<strong>特殊的引用类型</strong>，和基本类型一样，参数传递不会改变原数据内容。</li>
<li>StringBuffer作为引用类型，基本的赋值不会改变原数据内容，但是调用StringBuffer的方法去改变形式参数就会影响原数据内容。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBufferDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String s1 = <span class="string">"hello"</span>;</span><br><span class="line">		String s2 = <span class="string">"world"</span>;</span><br><span class="line">		System.out.println(s1 + <span class="string">"---"</span> + s2);<span class="comment">// hello---world</span></span><br><span class="line">		change(s1, s2);</span><br><span class="line">		System.out.println(s1 + <span class="string">"---"</span> + s2);<span class="comment">// hello---world</span></span><br><span class="line"></span><br><span class="line">		StringBuffer sb1 = <span class="keyword">new</span> StringBuffer(<span class="string">"hello"</span>);</span><br><span class="line">		StringBuffer sb2 = <span class="keyword">new</span> StringBuffer(<span class="string">"world"</span>);</span><br><span class="line">		System.out.println(sb1 + <span class="string">"---"</span> + sb2);<span class="comment">// hello---world</span></span><br><span class="line">		change(sb1, sb2);</span><br><span class="line">		System.out.println(sb1 + <span class="string">"---"</span> + sb2);<span class="comment">// hello---worldworld</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(StringBuffer sb1, StringBuffer sb2)</span> </span>&#123;</span><br><span class="line">		sb1 = sb2;</span><br><span class="line">		sb2.append(sb1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">		s1 = s2;</span><br><span class="line">		s2 = s1 + s2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>Java中的参数传递：</p>
<ul>
<li>基本类型：形式参数的改变对实际参数没有影响。</li>
<li>引用类型：形式参数的改变直接影响实际参数。</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01_Object</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">        change(a, b);</span><br><span class="line">        System.out.println(<span class="string">"main: a:"</span> + a + <span class="string">", b:"</span> + b); <span class="comment">//10, 20</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        change(arr);</span><br><span class="line">        System.out.println(<span class="string">"main: "</span> + arr[<span class="number">0</span>]); <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        a = b;</span><br><span class="line">        b = a + b;</span><br><span class="line">        System.out.println(<span class="string">"change: a:"</span> + a + <span class="string">", b:"</span> + b); <span class="comment">//20, 40</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        arr[<span class="number">0</span>] = arr[<span class="number">1</span>];</span><br><span class="line">        System.out.println(<span class="string">"change"</span> + arr[<span class="number">0</span>]); <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>引入概念</strong>： 在Java中<strong>一个对象变量并没有实际包含一个对象，而仅仅引用一个对象</strong>。<strong>所有的Java对象都储存在堆内存中</strong>。例如：<code>Date t = new Date()</code>其中的<code>t</code>就是一个对象变量，<code>new Date()</code>是在堆内存中开辟了一个空间，而<code>t</code>指向<code>new Date()</code>的堆内存地址。</p>
<p>因此，在上述代码中<code>a b</code>都是基本类型，而<code>int[]</code>是一个引用类型，那<strong>基本类型形式参数改变对实际参数没有影响</strong>；<strong>对象类型形式参数改变直接影响实际参数</strong>。</p>
<p><img src="http://cdn.tycoding.cn/2019031181231.png" alt></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>Java程序语言总是采用按值调用</strong>，也就是说，方法得到的是所有参数值的一个拷贝，特别的，方法不能修改传递给他的任何变量的内容。</p>
<ul>
<li>一个方法不能修改一个基本数据类型的参数（即数值型和布尔型）。</li>
<li>一个方法可以改变一个对象的引用状态</li>
<li>一个方法不能让对象参数引用一个新对象</li>
</ul>
<p>比如：下列是无意义的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Employee x, Employee y)</span> </span>&#123;</span><br><span class="line">    Employee temp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当调用<code>swap(e1, e2)</code>时并不会改变<code>e1</code>和<code>e2</code>的对象引用，swap方法的参数x,y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝。</p>
<ul>
<li><strong>基本类型</strong>（包括<code>Integer</code> <code>String</code> <code>Long</code>）传递的参数是参数<strong>值</strong>的拷贝；</li>
</ul>
<p>特别是对于Integer Long String这些类型数据，在初始化、赋值的时候都是从常量池中取数据，比如<code>IntgerCache</code> <code>LongCache</code>，如果常量池中没有就重新new对象，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s = <span class="string">"123"</span>;</span><br><span class="line">    System.out.println(<span class="string">"main: "</span> + s.hashCode()); <span class="comment">//48690</span></span><br><span class="line">    change(s);</span><br><span class="line">    change2(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    s = <span class="string">"123"</span>;</span><br><span class="line">    System.out.println(<span class="string">"change: "</span> + s.hashCode()); <span class="comment">//48690</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="title">change2</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    s = <span class="string">"456"</span>;</span><br><span class="line">    System.out.println(<span class="string">"change2: "</span> + s.hashCode()); <span class="comment">//51669</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>引用类型</strong>传递的参数是原对象在<strong>堆内存的地址</strong>的拷贝</li>
</ul>
<p>对象类型参数的传递，实际上传递这个对象堆内存地址的拷贝，所以形式参数和原参数操作的都是同一个堆内存地址，即形式参数的改变会直接影响原参数。</p>
<h2 id="成员变量和局部变量"><a href="#成员变量和局部变量" class="headerlink" title="成员变量和局部变量"></a>成员变量和局部变量</h2><p>成员变量和局部变量的区别：</p>
<ul>
<li>在类中的位置不同：<ul>
<li>成员变量：在类中方法外</li>
<li>局部变量：在方法定义中或方法声明上</li>
</ul>
</li>
<li>在内存中的位置不同：<ul>
<li>成员变量：在堆内存</li>
<li>局部变量：在栈内存</li>
</ul>
</li>
<li>声明周期不同：<ul>
<li>成员变量：随着对象的创建而存在，随着对象的消失而消失。</li>
<li>局部变量：随着方法的调用而存在，随着方法调用完毕而消失</li>
</ul>
</li>
<li>初始化值不同：<ul>
<li>成员变量：有默认初始化值</li>
<li>局部变量：没有默认初始化值，必须定义、赋值后才能使用</li>
</ul>
</li>
</ul>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>在Java中，当需要调用构造方法时，<strong>若该类没有定义构造方法，系统会自动提供一个无参构造方法；如果该类定义了构造方法（带参构造），系统将不再提供无参构造，必须手动定义</strong>。举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2_Construct</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo2Student student = <span class="keyword">new</span> Demo2Student();</span><br><span class="line">        student.show();</span><br><span class="line">        <span class="comment">// Demo2School school = new Demo2School(); //error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo2Student</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this student show"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo2School</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">1000</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo2School</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p><code>final</code>可以修改类、方法、变量。</p>
<p><strong>特点：</strong></p>
<ul>
<li><code>final</code>可以修饰类，该类不能被继承。</li>
<li><code>final</code>可以修饰方法，该方法不能被重写。</li>
<li><code>final</code>可以修饰变量，该变量不能被重新赋值。</li>
</ul>
<p><strong>面试题：</strong> <code>final</code>修饰局部变量的问题</p>
<ul>
<li>基本类型：被<code>final</code>修饰的基本类型的值不能被改变</li>
<li>引用类型：引用类型的地址值不能被改变，但是该对象的堆内存地址是可以改变的。</li>
</ul>
<p><strong>初始化时机</strong></p>
<p>被<code>final</code>修饰的变量必须在构造方法完毕前被初始化，比如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> WIDTH = <span class="number">12</span>;</span><br><span class="line">    <span class="comment">//final int HEIGHT; //error</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> AREA;</span><br><span class="line">    &#123;</span><br><span class="line">        AREA = <span class="number">120</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ol>
<li>Java支持单继承不支持多继承，但Java支持多层继承</li>
<li>子类只能继承父类非私有成员（成员变量、成员方法）</li>
<li>子类不能继承父类的构造方法，但可以通过<code>super</code>关键字访问父类的构造方法。</li>
</ol>
<h3 id="子类和父类的关系"><a href="#子类和父类的关系" class="headerlink" title="子类和父类的关系"></a>子类和父类的关系</h3><p><strong>子类中的所有构造方法都默认访问父类的无参构造方法</strong>。因为子类继承父类，并可能使用父类中的数据，所以子类初始化前一定要完成父类的初始化。所以子类每一个构造方法第一行默认都是<code>super()</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04_Extends</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo04Son son = <span class="keyword">new</span> Demo04Son();</span><br><span class="line">        son.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo04Son</span> <span class="keyword">extends</span> <span class="title">Demo04Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo04Son</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.num);</span><br><span class="line">        System.out.println(<span class="keyword">super</span>.num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo04Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo04Parent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是父类的无参构造函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="this-super"><a href="#this-super" class="headerlink" title="this-super"></a>this-super</h3><p><code>this</code>和<code>super</code>关键字的区别和使用场景？</p>
<p>区别：</p>
<ul>
<li><code>this</code>: 代表当前类的对象引用</li>
<li><code>super</code>: 代表父类的空间标识（可以理解为父类的引用，通过他访问父类的成员）</li>
</ul>
<p>场景：</p>
<ul>
<li>this.成员变量/方法</li>
<li>super.成员变量/方法</li>
<li>this(…)  super(…) </li>
</ul>
<h3 id="加载顺序"><a href="#加载顺序" class="headerlink" title="加载顺序"></a>加载顺序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04_Extends2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo04Zi zi = <span class="keyword">new</span> Demo04Zi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo04Fu</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Fu 静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Fu 构造代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo04Fu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Fu 构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo04Zi</span> <span class="keyword">extends</span> <span class="title">Demo04Fu</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Zi 静态代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Zi 构造代码块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo04Zi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Zi 构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Fu 静态代码块</span><br><span class="line">Zi 静态代码块</span><br><span class="line">Fu 构造代码块</span><br><span class="line">Fu 构造方法</span><br><span class="line">Zi 构造代码块</span><br><span class="line">Zi 构造方法</span><br></pre></td></tr></table></figure>

<p>静态代码块 &gt; 构造代码块 &gt; 构造方法</p>
<h3 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h3><p><strong>调用对象方法的执行过程：</strong></p>
<p><img src="http://cdn.tycoding.cn/20190312122515.png" alt></p>
<ol>
<li>编译器首先查看对象的声明类型和方法名。如调用<code>change(a)</code>方法，由于存在多个<code>change()</code>方法，JVM会先列举该类以及其超类中访问属性为public且名为<code>change</code>的方法。</li>
<li>接下来，JVM将查看调用方法时提供的参数类型，并且JVM会预先为每个类创建一个<strong>方法表（method table）</strong>，JVM会直接从这个方法表中寻找名为<code>change</code>的方法中存在一个与提供的参数类型匹配的方法，这个过程称为<strong>重载解析</strong>。</li>
<li>如果是<code>private</code>、<code>static</code>、<code>final</code>方法或者构造器，那么JVM就能准确的知道调用哪个方法，我们将这种调用方式称为<strong>静态绑定</strong>。与此对应，调用的方法依赖于隐式参数的实际类型，并且在运行时实现<strong>动态绑定</strong>。</li>
<li>当程序运行，并且采用动态绑定调用方法时，JVM就一定调用于此最适合的一个方法，否则从超类中继续寻找。</li>
</ol>
<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>将一个类型强制转换为另外一个类型的过程称为类型转换。数值类型直接<code>(int) double</code>这样转换；对象引用的转换也类似，实现将某个类的对象引用转换为另一个类的对象引用。</p>
<ul>
<li><strong>向上转型</strong>：将一个子类的引用赋值给一个超类变量。</li>
<li><strong>向下转型</strong>：将一个超类的引用赋值给一个子类变量，且必须进行类型转换。</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>只能在继承层次内进行类型转换。</li>
<li>在将超类转换成子类之前，应该使用<code>instanceof</code>进行检查。</li>
</ul>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>一个类存在于另一个类中方法外，这个类就称为内部类；一个类存在于另一个类方法内，这个类称为局部内部类。</p>
<ul>
<li>内部类可以直接访问外部类的成员，包括私有</li>
<li>外部类可以访问内部类的成员，必须创建对象</li>
<li>直接访问内部类的成员：<code>Outer.Inner in = new Outer().new Inner()</code></li>
</ul>
<h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><p>局部内部类可以直接访问外部类的成员，在局部位置可以创建内部类对象，通过对象调用内部类成员。</p>
<blockquote>
<p><strong>局部内部类访问局部变量注意事项?</strong></p>
</blockquote>
<p>​        局部内部类访问局部变量必须用<code>final</code>修饰。因为<strong>局部内部类的声明周期比局部变量长</strong>，局部变量随着方法的调用而存在，随着调用完毕而消失；但局部内部类不一定消失，他调用一个消失的变量就会报错。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">        outer.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num2 = <span class="number">10</span>;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(num2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Inner inner = <span class="keyword">new</span> Inner();</span><br><span class="line">        inner.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时调用不会报错，但并没有加<code>final</code>修饰。这个类编译后会生成<code>InnerClass.class</code>和<code>Outer.class</code>两个文件，我们来看下<code>Outer.class</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    Outer() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> num2 = <span class="number">10</span>;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">            Inner() &#123;&#125;</span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(num2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Inner inner = <span class="keyword">new</span> Inner();</span><br><span class="line">        inner.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的<code>num2</code>被自动加上了<code>final</code>修饰（这是因为JDK1.8的原因），所以如果你再添上<code>num2 = 1000</code>就会报错。</p>
<blockquote>
<p>解决办法</p>
</blockquote>
<p>上面说过了应该将<code>num2</code>用<code>final</code>修饰。其原因就是<code>Inner</code>类的生命周期要比<code>num2</code>的声明周期长，当<code>show()</code>方法调用完毕后<code>num2</code>就已经消失了，但此时<code>Inner</code>类在堆内存中仍然存在，他调用一个不存在的变量就会报错。而用<code>final</code>修饰，这个变量成为常量，在初始化内部类的时候，<code>final num2</code>就在内部类中生成了一份拷贝，这个拷贝和这个内部类的声明周期相同，所以不会报错。</p>
<br>

<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>（十二）Spring-Boot-Solr 踩坑记！</title>
    <url>/2019/03/06/boot/spring-boot-solr/</url>
    <content><![CDATA[<h1 id="Spring-Boot整合Solr"><a href="#Spring-Boot整合Solr" class="headerlink" title="Spring Boot整合Solr"></a>Spring Boot整合Solr</h1><p>:tada: :tada: :tada: <strong>这里有丰富的 Spring 框架学习案例</strong></p>
<p><strong>仓库地址：<a href="https://github.com/TyCoding/spring-learn" target="_blank" rel="noopener">spring-learn</a></strong><br><strong>欢迎star、fork，给作者一些鼓励</strong></p>
<p><strong>写在前面</strong></p>
<p>在之前我就写过一篇文档：<a href="https://tycoding.cn/2018/09/24/other/solr/" target="_blank" rel="noopener">Solr及Spring-Data-Solr入门学习</a>，这篇文章其实来自于我学习黑马项目时写的笔记，其中用的版本都比较老。而最近这两天一直在研究Solr，发现还是老版本好用（坑</p>
<p>而今天既然学spring-boot，发现万能的spring-boot自己又对<code>spring-data-solr</code>进行了封装简化：<code>spring-boot-starter-data-solr</code>，今天就来学习一下。</p>
<p>之前我使用SSM项目写了一个ssm-solr的项目，如果你想看SSM项目中如何整合Solr，可以参考这个项目：<a href="https://github.com/TyCoding/ssm-redis-solr" target="_blank" rel="noopener">ssm-redis-solr</a> </p>
<p><strong>欢迎star, fork</strong></p>
<p><img src="/2019/03/06/boot/spring-boot-solr/9.png" alt></p>
<a id="more"></a>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>如果你阅读过我的这篇文章：<a href="https://tycoding.cn/2018/09/24/other/solr/" target="_blank" rel="noopener">Solr及Spring-Data-Solr入门学习</a>。会发现其中是将下载的solr source再提取出来放到tomcat容器中，过程比较复杂，也遇到很多坑，我自己再尝试将solr放到tomcat容器中也遇到很多很多的问题。<strong>但</strong>，<a href="http://www.apache.org/dyn/closer.lua/lucene/solr/7.7.1" target="_blank" rel="noopener">Solr官网</a>提供的源码其实已经将Solr放在了Jetty容器中，我们只需要通过命令运行Jetty容器也依然可以访问Solr。</p>
<p><strong>So</strong>，我这里推荐使用Solr自带的Jetty容器运行Solr，详细的安装文档请看：</p>
<p><a href="https://tycoding.cn/2019/03/05/other/solr-server/" target="_blank" rel="noopener">手摸手教你部署Solr-7.7.1</a></p>
<p>如果安装完成，启动Solr服务器，浏览器访问Solr-Admin主页，先吧数据库中的数据导入到Solr中，上面链接的文档中已经介绍了。如果你查询到了这些数据，证明Solr安装成功：</p>
<p><img src="/2019/03/06/boot/spring-boot-solr/1.png" alt></p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>按照 <a href="https://tycoding.cn/2019/03/05/other/solr-server/" target="_blank" rel="noopener">手摸手教你部署Solr-7.7.1</a> 这篇文章中部署好的服务器，我们可以着手创建springboot_solr项目了。</p>
<blockquote>
<p>修改<code>application.yml</code></p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  data:</span></span><br><span class="line"><span class="attr">    solr:</span></span><br><span class="line"><span class="attr">      host:</span> <span class="attr">http://127.0.0.1:8983/solr/new_core</span></span><br></pre></td></tr></table></figure>

<p>其中就是solr服务器的连接URL，这个路径并不是可以直接访问的，在Solr-Admin中访问<code>new_core</code>的URL地址是：<code>http://localhost:8983/solr/#/new_core/query</code>，而实际的请求地址就是<code>http://127.0.0.1:8983/solr/new_core</code>了。</p>
<h3 id="创建Entity"><a href="#创建Entity" class="headerlink" title="创建Entity"></a>创建Entity</h3><p>首先，创建Search.java:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Search</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="meta">@Field</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@Field</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="meta">@Field</span></span><br><span class="line">    <span class="keyword">private</span> String qq;</span><br><span class="line">    <span class="meta">@Field</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="comment">//省略getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为我们在<code>solr-7.7.1/server/solr/new_core/conf/managed-schema</code>和<code>db-data-config.xml</code>中定义了solr和MySQL关联的配置，那么想要操控Solr数据库，就必须保证：</p>
<p>Solr字段约束=MySQL表字段=Entity属性</p>
<p>其中的<code>@Field</code>注解来自<code>org.apache.solr.client.solrj.beans.Field</code>，用于将Solr字段和Entity字段进行匹配。若名称相同直接加<code>@Field</code>，若不同加<code>@Field(&quot;name&quot;)</code></p>
<hr>
<blockquote>
<p><strong>本文中采用两种方式实现Solr的查询功能，这两种方式各自有坑，请注意！</strong></p>
</blockquote>
<hr>
<h2 id="SolrQuery"><a href="#SolrQuery" class="headerlink" title="SolrQuery"></a>SolrQuery</h2><p>Solr提供最基本的方式就是用SolrClient完成对Solr的操作，那么必然要用<code>org.apache.solr.client.solrj.SolrQuery</code>进行查询条件封装，下面我们就用<code>SolrQuery</code>类进行操作。</p>
<h3 id="最基本的查询"><a href="#最基本的查询" class="headerlink" title="最基本的查询"></a>最基本的查询</h3><p>使用<code>SolrQuery</code>完成一个最基本的查询，创建测试类：<code>SolrQuerySearchServiceTest</code>：</p>
<ul>
<li><ol>
<li>注入SolrClient类</li>
</ol>
</li>
<li><ol start="2">
<li>构建查询类</li>
</ol>
</li>
<li><ol start="3">
<li>封装查询条件</li>
</ol>
</li>
<li><ol start="4">
<li>查询</li>
</ol>
</li>
<li><ol start="5">
<li>从response中获取查询结果</li>
</ol>
</li>
<li><ol start="6">
<li>打印查询结果</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SolrQuerySearchServiceTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 注入SolrClient类</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SolrClient solrClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">search</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//2. 构建查询类</span></span><br><span class="line">        SolrQuery query = <span class="keyword">new</span> SolrQuery();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 封装查询条件，在solr中对应: localhost:8983/solr/new_core/select?q=keyword:*:*</span></span><br><span class="line">        query.set(<span class="string">"q"</span>, <span class="string">"keyword:*"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//4. 查询，获取response响应数据</span></span><br><span class="line">            QueryResponse response = solrClient.query(query);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//5. 从response中获取查询结果</span></span><br><span class="line">            SolrDocumentList documents = response.getResults();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//6. 打印查询结果</span></span><br><span class="line">            documents.forEach(document -&gt; &#123;</span><br><span class="line">                logger.info(<span class="string">"id=&#123;&#125; --&gt; username=&#123;&#125;"</span>, document.getFieldValue(<span class="string">"id"</span>), document.getFieldValue(<span class="string">"username"</span>));</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><p>通过设置<code>setStart()</code>：从哪一行开始；设置<code>setRows()</code>：查询到第几行结束，来实现分页查询。</p>
<p>注意：我们常用pageHelper进行数据库的分页查询，但是那里是：起始<strong>页</strong> –&gt; 查询多少条记录。而在solr中起始查询的是记录，从<strong>0</strong>开始的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">query.setStart(current);</span><br><span class="line">query.setRows(rows);</span><br></pre></td></tr></table></figure>

<p>上面两段配置在solr中实际的构建的渲染条件：</p>
<p><code>http://localhost:8983/solr/new_core/select?start=0&amp;rows=20</code></p>
<h3 id="高亮查询"><a href="#高亮查询" class="headerlink" title="高亮查询"></a>高亮查询</h3><p>高亮查询是<strong>最坑的</strong>，主要有涉及以下几个过程：</p>
<ul>
<li><p>1.查询时构建高亮查询条件，并且限定需要高亮匹配的字段。</p>
</li>
<li><p>2.从response查询数据中获取被高亮的集合，类似：<code>[{id: &#39;xx&#39;, field: &#39;&lt;em&gt;xx&lt;/em&gt;&#39;}]</code> 这样的结构，<code>field</code>对应的数据是被标记高亮的。</p>
</li>
<li><p>3.根据限定的高亮字段匹配高亮集合中对应标记高亮的数据。</p>
</li>
<li><p>4.遍历response中返回的总数据集合，将高亮集合中的标记的高亮数据<strong>替换</strong>掉原未高亮的数据，于是，就实现了高亮。</p>
</li>
</ul>
<blockquote>
<p>1.构建查询条件</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//高亮配置</span></span><br><span class="line">String[] lightNames = &#123;<span class="string">"username"</span>, <span class="string">"email"</span>, <span class="string">"qq"</span>&#125;; <span class="comment">//设置需要高亮的域</span></span><br><span class="line">query.setParam(<span class="string">"hl"</span>, <span class="string">"true"</span>);</span><br><span class="line">query.setParam(<span class="string">"hl.fl"</span>, lightNames);</span><br><span class="line">query.setHighlightSimplePre(<span class="string">"&lt;em  style='color: red'&gt;"</span>);</span><br><span class="line">query.setHighlightSimplePost(<span class="string">"&lt;/em&gt;"</span>);</span><br></pre></td></tr></table></figure>

<p>这些条件在solr中实际查询的URL是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://localhost:8983/solr/new_core/select?start=0&amp;rows=20&amp;hl=true&amp;hl.fl=username&amp;hl.fl=email&amp;hl.fl=qq&amp;hl.simple.pre=&lt;em+style=%27color:red%27&gt;&amp;hl.simple.post=&lt;/em&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>2.从response查询数据中获取被高亮的集合，类似：<code>[{id: &#39;xx&#39;, field: &#39;&lt;em&gt;xx&lt;/em&gt;&#39;}]</code> 这样的结构，<code>field</code>对应的数据是被标记高亮的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">QueryResponse response = solrClient.query(query);</span><br><span class="line"><span class="comment">//获取被高亮的数据集合，其中的数据结构类似：[&#123;id: "123", field: "&lt;em&gt;xxx&lt;/em&gt;"&#125;]</span></span><br><span class="line">Map&lt;String, Map&lt;String, List&lt;String&gt;&gt;&gt; highlighting = response.getHighlighting();</span><br></pre></td></tr></table></figure>

<p><code>highlighting</code>数据结构：</p>
<p><img src="/2019/03/06/boot/spring-boot-solr/2.png" alt></p>
<blockquote>
<p>3.根据限定的高亮字段匹配高亮集合中对应标记高亮的数据。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">QueryResponse response = solrClient.query(query);</span><br><span class="line"><span class="comment">//获取被高亮的数据集合，其中的数据结构类似：[&#123;id: "123", field: "&lt;em&gt;xxx&lt;/em&gt;"&#125;]</span></span><br><span class="line">Map&lt;String, Map&lt;String, List&lt;String&gt;&gt;&gt; highlighting = response.getHighlighting();</span><br><span class="line">SolrDocumentList documents = response.getResults(); <span class="comment">//获取匹配结果</span></span><br><span class="line"><span class="keyword">long</span> numFound = documents.getNumFound(); <span class="comment">//获取匹配的数据个数</span></span><br><span class="line"><span class="keyword">if</span> (numFound != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (SolrDocument document : documents) &#123;</span><br><span class="line">        <span class="comment">//documents中存放了匹配的所有数据（未高亮），而highlighting中存放了高亮匹配的数据（高亮）</span></span><br><span class="line">        <span class="comment">//通过id主键获取到id值，在highlighting中通过id值获取对应的高亮数据</span></span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; listMap = highlighting.get(document.getFieldValue(<span class="string">"id"</span>).toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，我们看一下查询原始数据结构<code>documents</code>:</p>
<p><img src="/2019/03/06/boot/spring-boot-solr/3.png" alt></p>
<p>可以看到这些数据是原始数据，并未高亮。而<code>document.getFieldValue(&quot;id&quot;)</code>就是获取到id值。</p>
<p>而<code>highlighting.get(document.getFieldValue(&quot;id&quot;).toString())</code>就是根据id从高亮集合中获取对应的高亮字段和值，也就是：</p>
<p><img src="/2019/03/06/boot/spring-boot-solr/4.png" alt></p>
<blockquote>
<p>4.遍历response中返回的总数据集合，将高亮集合中的标记的高亮数据<strong>替换</strong>掉原未高亮的数据</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> String[] fields = &#123;<span class="string">"username"</span>, <span class="string">"email"</span>, <span class="string">"qq"</span>, <span class="string">"password"</span>&#125;; <span class="comment">//设置solr中定义的域</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//高亮配置</span></span><br><span class="line">String[] lightNames = &#123;<span class="string">"username"</span>, <span class="string">"email"</span>, <span class="string">"qq"</span>&#125;; <span class="comment">//设置需要高亮的域</span></span><br><span class="line">query.setParam(<span class="string">"hl"</span>, <span class="string">"true"</span>);</span><br><span class="line">query.setParam(<span class="string">"hl.fl"</span>, lightNames);</span><br><span class="line">query.setHighlightSimplePre(<span class="string">"&lt;em  style='color: red'&gt;"</span>);</span><br><span class="line">query.setHighlightSimplePost(<span class="string">"&lt;/em&gt;"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置查询关键字的域</span></span><br><span class="line"><span class="comment"> * 一般对应solr中的复制域(&lt;copyFiled&gt;)。</span></span><br><span class="line"><span class="comment"> * 因为用户查询的数据不确定是什么，定义在复制域中的字段，Solr会自动进行多字段查询匹配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">query.set(<span class="string">"q"</span>, <span class="string">"keyword:*"</span> + keyword + <span class="string">"*"</span>); <span class="comment">//在Solr中查询语句：/select?q=keyword:xxx</span></span><br><span class="line"></span><br><span class="line">QueryResponse response = solrClient.query(query);</span><br><span class="line"><span class="comment">//获取被高亮的数据集合，其中的数据结构类似：[&#123;id: "123", field: "&lt;em&gt;xxx&lt;/em&gt;"&#125;]</span></span><br><span class="line">Map&lt;String, Map&lt;String, List&lt;String&gt;&gt;&gt; highlighting = response.getHighlighting();</span><br><span class="line">SolrDocumentList documents = response.getResults(); <span class="comment">//获取匹配结果</span></span><br><span class="line"><span class="keyword">long</span> numFound = documents.getNumFound(); <span class="comment">//获取匹配的数据个数</span></span><br><span class="line"><span class="keyword">if</span> (numFound != <span class="number">0</span>) &#123;</span><br><span class="line">    List&lt;Object&gt; entityList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (SolrDocument document : documents) &#123;</span><br><span class="line">        <span class="comment">//documents中存放了匹配的所有数据（未高亮），而highlighting中存放了高亮匹配的数据（高亮）</span></span><br><span class="line">        <span class="comment">//通过id主键获取到id值，在highlighting中通过id值获取对应的高亮数据</span></span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; listMap = highlighting.get(document.getFieldValue(<span class="string">"id"</span>).toString());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lightNames.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (listMap.get(lightNames[i]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//根据设置的高亮域，将documents中未高亮的域的值替换为高亮的值</span></span><br><span class="line">                document.setField(lightNames[i], listMap.get(lightNames[i]).get(<span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;String, Object&gt; fieldMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fields.length; i++) &#123;</span><br><span class="line">            fieldMap.put(fields[i], String.valueOf(document.getFieldValue(fields[i])));</span><br><span class="line">        &#125;</span><br><span class="line">        entityList.add(fieldMap);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ResponseCode(entityList, numFound);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ResponseCode(<span class="string">"未搜索到任何结果"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>document.setField()</code>根据key,value将高亮的数据替换点原始未高亮的数据，实现的效果就是：</p>
<p><img src="/2019/03/06/boot/spring-boot-solr/5.png" alt></p>
<p>通过不断的循环替换，就能将原始未高亮的数据替换为高亮的数据，那么最终在前端页面实现的效果是：</p>
<p><img src="/2019/03/06/boot/spring-boot-solr/6.png" alt></p>
<h3 id="结"><a href="#结" class="headerlink" title="结"></a>结</h3><p>最终的查询代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ResponseCode <span class="title">solrQuerySearch</span><span class="params">(String keyword, Integer current, Integer rows)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(keyword)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseCode(<span class="string">"请输入查询内容"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (current == <span class="number">1</span>) &#123;</span><br><span class="line">        current = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        current = (current - <span class="number">1</span>) * rows;</span><br><span class="line">    &#125;</span><br><span class="line">    SolrQuery query = <span class="keyword">new</span> SolrQuery();</span><br><span class="line">    query.setStart(current);</span><br><span class="line">    query.setRows(rows);</span><br><span class="line">    query.set(<span class="string">"wt"</span>, <span class="string">"json"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String[] fields = &#123;<span class="string">"username"</span>, <span class="string">"email"</span>, <span class="string">"qq"</span>, <span class="string">"password"</span>&#125;; <span class="comment">//设置solr中定义的域</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//高亮配置</span></span><br><span class="line">        String[] lightNames = &#123;<span class="string">"username"</span>, <span class="string">"email"</span>, <span class="string">"qq"</span>&#125;; <span class="comment">//设置需要高亮的域</span></span><br><span class="line">        query.setParam(<span class="string">"hl"</span>, <span class="string">"true"</span>);</span><br><span class="line">        query.setParam(<span class="string">"hl.fl"</span>, lightNames);</span><br><span class="line">        query.setHighlightSimplePre(<span class="string">"&lt;em  style='color: red'&gt;"</span>);</span><br><span class="line">        query.setHighlightSimplePost(<span class="string">"&lt;/em&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 设置查询关键字的域</span></span><br><span class="line"><span class="comment">         * 一般对应solr中的复制域(&lt;copyFiled&gt;)。</span></span><br><span class="line"><span class="comment">         * 因为用户查询的数据不确定是什么，定义在复制域中的字段，Solr会自动进行多字段查询匹配</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        query.set(<span class="string">"q"</span>, <span class="string">"keyword:*"</span> + keyword + <span class="string">"*"</span>); <span class="comment">//在Solr中查询语句：/select?q=keyword:xxx</span></span><br><span class="line"></span><br><span class="line">        QueryResponse response = solrClient.query(query);</span><br><span class="line">        <span class="comment">//获取被高亮的数据集合，其中的数据结构类似：[&#123;id: "123", field: "&lt;em&gt;xxx&lt;/em&gt;"&#125;]</span></span><br><span class="line">        Map&lt;String, Map&lt;String, List&lt;String&gt;&gt;&gt; highlighting = response.getHighlighting();</span><br><span class="line">        SolrDocumentList documents = response.getResults(); <span class="comment">//获取匹配结果</span></span><br><span class="line">        <span class="keyword">long</span> numFound = documents.getNumFound(); <span class="comment">//获取匹配的数据个数</span></span><br><span class="line">        <span class="keyword">if</span> (numFound != <span class="number">0</span>) &#123;</span><br><span class="line">            List&lt;Object&gt; entityList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (SolrDocument document : documents) &#123;</span><br><span class="line">                <span class="comment">//documents中存放了匹配的所有数据（未高亮），而highlighting中存放了高亮匹配的数据（高亮）</span></span><br><span class="line">                <span class="comment">//通过id主键获取到id值，在highlighting中通过id值获取对应的高亮数据</span></span><br><span class="line">                Map&lt;String, List&lt;String&gt;&gt; listMap = highlighting.get(document.getFieldValue(<span class="string">"id"</span>).toString());</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lightNames.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (listMap.get(lightNames[i]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//根据设置的高亮域，将documents中未高亮的域的值替换为高亮的值</span></span><br><span class="line">                        document.setField(lightNames[i], listMap.get(lightNames[i]).get(<span class="number">0</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                Map&lt;String, Object&gt; fieldMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fields.length; i++) &#123;</span><br><span class="line">                    fieldMap.put(fields[i], String.valueOf(document.getFieldValue(fields[i])));</span><br><span class="line">                &#125;</span><br><span class="line">                entityList.add(fieldMap);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ResponseCode(entityList, numFound);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ResponseCode(<span class="string">"未搜索到任何结果"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseCode(<span class="string">"服务器异常"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h3><h4 id="q-xx-and-type-39-string-39"><a href="#q-xx-and-type-39-string-39" class="headerlink" title="q=*xx* and type=&#39;string&#39;"></a><code>q=*xx* and type=&#39;string&#39;</code></h4><p>首先我们看下我在solr的<code>managed-schema</code>中定义的域如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">type</span>=<span class="string">"string"</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">stored</span>=<span class="string">"true"</span> <span class="attr">required</span>=<span class="string">"true"</span> <span class="attr">multiValued</span>=<span class="string">"false"</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">type</span>=<span class="string">"string"</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">stored</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"email"</span> <span class="attr">type</span>=<span class="string">"string"</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">stored</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"qq"</span> <span class="attr">type</span>=<span class="string">"string"</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">stored</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">type</span>=<span class="string">"string"</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">stored</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"keyword"</span> <span class="attr">type</span>=<span class="string">"text_ik"</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">stored</span>=<span class="string">"false"</span> <span class="attr">multiValued</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">copyField</span> <span class="attr">source</span>=<span class="string">"username"</span> <span class="attr">dest</span>=<span class="string">"keyword"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">copyField</span> <span class="attr">source</span>=<span class="string">"email"</span> <span class="attr">dest</span>=<span class="string">"keyword"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uniqueKey</span>&gt;</span>id<span class="tag">&lt;/<span class="name">uniqueKey</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>最终渲染效果如图：</p>
<p><img src="/2019/03/06/boot/spring-boot-solr/6.png" alt></p>
<p>看到，实际高亮的是<code>tycoding@163.com</code>整个数据，并不是仅高亮<code>163</code>这三个字符串。</p>
<p><strong>但是</strong>，在上面代码中，查询条件是：<code>http://localhost:8983/solr/new_core/select?q=keyword:*163*</code>，显然这是模糊查询，<code>*</code>匹配0个或多个字符。</p>
<p>关于Solr查询语句可以看 <a href="https://blog.csdn.net/yelllowcong/article/details/78709435" target="_blank" rel="noopener">Solr之精确、匹配、排序、模糊查询</a></p>
<h4 id="q-xx-and-type-39-string-39-1"><a href="#q-xx-and-type-39-string-39-1" class="headerlink" title="q=xx and type=&#39;string&#39;"></a><code>q=xx and type=&#39;string&#39;</code></h4><p>如果，我们把查询条件改为：<code>http://localhost:8983/solr/new_core/select?q=keyword:163</code>，即不加检索运算符，会怎样呢？</p>
<p>修改代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">query.set(<span class="string">"q"</span>, <span class="string">"keyword:"</span> + keyword)</span><br></pre></td></tr></table></figure>

<p><img src="/2019/03/06/boot/spring-boot-solr/7.png" alt></p>
<p>看到高亮集合中虽然有key，但是没有value。那么最终也就没法实现高亮</p>
<h4 id="q-xx-and-type-39-text-ik-39"><a href="#q-xx-and-type-39-text-ik-39" class="headerlink" title="q=xx and type=&#39;text_ik&#39;"></a><code>q=xx and type=&#39;text_ik&#39;</code></h4><p>修改solr配置文件<code>managed-schema</code>:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">type</span>=<span class="string">"text_ik"</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">stored</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"email"</span> <span class="attr">type</span>=<span class="string">"text_ik"</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">stored</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>即让<code>username</code>和<code>email</code>域使用<code>text_ik</code>IK分词器，那么实际的效果：</p>
<p><img src="/2019/03/06/boot/spring-boot-solr/8.png" alt></p>
<p>并且，仅对查询的数据<code>163</code>进行了高亮显示</p>
<p><img src="/2019/03/06/boot/spring-boot-solr/9.png" alt></p>
<h4 id="q-xx-and-type-39-text-ik-39-1"><a href="#q-xx-and-type-39-text-ik-39-1" class="headerlink" title="q=*xx* and type=&#39;text_ik&#39;"></a><code>q=*xx* and type=&#39;text_ik&#39;</code></h4><p><img src="/2019/03/06/boot/spring-boot-solr/10.png" alt></p>
<p>可以看到，数据被高亮显示了，但是还是整个字段值全被标记高亮。</p>
<h4 id="结-1"><a href="#结-1" class="headerlink" title="结"></a>结</h4><p>综上，因为IK分词器能将查询数据分词匹配，且类似163,qq,com,cn 这些名词可以直接匹配到并可以精确到具体的字符串高亮显示。但是若solr域定义为<code>string</code>类型，就不能使用<code>*</code>运算符匹配数据。</p>
<p>可以看下这篇文章：<a href="https://blog.csdn.net/wohaqiyi/article/details/78264117" target="_blank" rel="noopener">搜索引擎solr系列—高亮配置及问题总结</a></p>
<h2 id="SolrTemplate"><a href="#SolrTemplate" class="headerlink" title="SolrTemplate"></a>SolrTemplate</h2><p>使用<code>SolrTemplate</code>就相对简单很多，<code>org.springframework.data.solr.core.SolrTemplate</code>是spring-data-solr提供的一个solr模板类，类似spring-data-redis的RedisTemplate，使用SolrTemplate就像使用RedisTemplate或者spring-data-jpa一样方便的操作mysql, nosql数据库，快速实现CRUD业务。</p>
<p>在 <a href="https://tycoding.cn/2018/09/24/other/solr/" target="_blank" rel="noopener">Solr及Spring-Data-Solr入门学习</a> 一文中我已经详细介绍过了，对应<a href="https://github.com/TyCoding/ssm-redis-solr" target="_blank" rel="noopener">ssm-redis-solr</a>项目，欢迎参考，start,fork。</p>
<p>所以在这里就不再详细介绍，按照上面使用<code>SolrQuery</code>的查询，这里使用<code>SolrTemplate</code>模板类完成数据查询：</p>
<h3 id="创建SolrConfig"><a href="#创建SolrConfig" class="headerlink" title="创建SolrConfig"></a>创建SolrConfig</h3><blockquote>
<p>创建SolrConfig.java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SolrConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.data.solr.host&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String solrHost;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SolrClient <span class="title">solrClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HttpSolrClient.Builder(solrHost).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SolrTemplate <span class="title">solrTemplate</span><span class="params">(SolrClient client)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SolrTemplate(client);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>目的就是根据URL创建SolrClient，并将其注入到SolrTemplate中，以便可以使用SolrTemplate模板类操作Solr数据库。</p>
<blockquote>
<p>编写Service服务层代码实现</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ResponseCode <span class="title">solrTemplateSearch</span><span class="params">(String keyword, Integer current, Integer rows)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//高亮配置</span></span><br><span class="line">    HighlightQuery query = <span class="keyword">new</span> SimpleHighlightQuery();</span><br><span class="line">    String[] fieldNames = &#123;<span class="string">"username"</span>, <span class="string">"email"</span>, <span class="string">"qq"</span>&#125;;</span><br><span class="line">    HighlightOptions highlightOptions = <span class="keyword">new</span> HighlightOptions().addField(fieldNames); <span class="comment">//设置高亮域</span></span><br><span class="line">    highlightOptions.setSimplePrefix(<span class="string">"&lt;em style='color: red'&gt;"</span>); <span class="comment">//设置高亮前缀</span></span><br><span class="line">    highlightOptions.setSimplePostfix(<span class="string">"&lt;/em&gt;"</span>); <span class="comment">//设置高亮后缀</span></span><br><span class="line">    query.setHighlightOptions(highlightOptions); <span class="comment">//设置高亮选项</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">""</span>.equals(keyword)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseCode(<span class="string">"请输入查询内容"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 通过Criteria构建查询过滤条件</span></span><br><span class="line"><span class="comment">         * 其中这里的`keyword`等价于solr core中schema.xml配置的域，且`keyword`是复制域名</span></span><br><span class="line"><span class="comment">         * 因为查询的内容是不确定的，solr提供了复制域实现同时查询多个域中的数据，并返回匹配的结果</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Criteria criteria = <span class="keyword">new</span> Criteria(<span class="string">"keyword"</span>);</span><br><span class="line">        <span class="comment">//按照关键字查询</span></span><br><span class="line">        <span class="keyword">if</span> (keyword != <span class="keyword">null</span> &amp;&amp; !<span class="string">""</span>.equals(keyword)) &#123;</span><br><span class="line">            criteria.contains(keyword);</span><br><span class="line">        &#125;</span><br><span class="line">        query.addCriteria(criteria);</span><br><span class="line"></span><br><span class="line"><span class="comment">//            //构建查询条件</span></span><br><span class="line"><span class="comment">//            FilterQuery filterQuery = new SimpleFilterQuery();</span></span><br><span class="line"><span class="comment">//            Criteria filterCriteria = new Criteria("field");</span></span><br><span class="line"><span class="comment">//            filterCriteria.contains(keywords);</span></span><br><span class="line"><span class="comment">//            filterQuery.addCriteria(filterCriteria);</span></span><br><span class="line"><span class="comment">//            query.addFilterQuery(filterQuery);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">            current = <span class="number">1</span>; <span class="comment">//默认第一页</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rows == <span class="keyword">null</span>) &#123;</span><br><span class="line">            rows = <span class="number">20</span>; <span class="comment">//默认每次查询20条记录</span></span><br><span class="line">        &#125;</span><br><span class="line">        query.setOffset((<span class="keyword">long</span>) ((current - <span class="number">1</span>) * rows)); <span class="comment">//从第几条记录开始查询：= 当前页 * 每页的记录数</span></span><br><span class="line">        query.setRows(rows);</span><br><span class="line"></span><br><span class="line">        HighlightPage&lt;Search&gt; page = solrTemplate.queryForHighlightPage(<span class="string">""</span>, query, Search.class);</span><br><span class="line">        <span class="comment">//循环高亮入口集合</span></span><br><span class="line">        <span class="keyword">for</span> (HighlightEntry&lt;Search&gt; h : page.getHighlighted()) &#123;</span><br><span class="line">            Search search = h.getEntity(); <span class="comment">//获取原实体类</span></span><br><span class="line">            <span class="keyword">if</span> (h.getHighlights().size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                h.getHighlights().forEach(light -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (search.getUsername().contains(keyword)) &#123;</span><br><span class="line">                        search.setUsername(light.getSnipplets().get(<span class="number">0</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (search.getEmail().contains(keyword)) &#123;</span><br><span class="line">                        search.setEmail(light.getSnipplets().get(<span class="number">0</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (search.getQq().contains(keyword)) &#123;</span><br><span class="line">                        search.setQq(light.getSnipplets().get(<span class="number">0</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseCode(page.getContent(), page.getTotalElements());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseCode(<span class="string">"查询失败"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SolrTemplate</code>中提供了很多封装好的类进行调用，快速获取查询数据，相比<code>SolrQuery</code>逻辑和代码量都要简化很多。</p>
<br>

<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <categories>
        <category>spring-boot</category>
      </categories>
      <tags>
        <tag>spring-boot</tag>
      </tags>
  </entry>
  <entry>
    <title>（十一）手摸手教你部署Solr-7.7.1</title>
    <url>/2019/03/05/other/solr-server/</url>
    <content><![CDATA[<h1 id="Solr最新版安装部署教程"><a href="#Solr最新版安装部署教程" class="headerlink" title="Solr最新版安装部署教程"></a>Solr最新版安装部署教程</h1><p>:tada: :tada: :tada: <strong>这里有丰富的 Spring 框架学习案例</strong></p>
<p><strong>仓库地址：<a href="https://github.com/TyCoding/spring-learn" target="_blank" rel="noopener">spring-learn</a></strong><br><strong>欢迎star、fork，给作者一些鼓励</strong></p>
<p><strong>写在前面</strong></p>
<p>本案例使用Solr默认提供的Jetty容器运行Solr，如果你想将Solr部署到Tomcat容器中，过程稍微复杂些，请看我的这篇文档：</p>
<p><a href="https://tycoding.cn/2018/09/24/other/solr/" target="_blank" rel="noopener">Solr及Spring-Data-Solr入门</a></p>
<a id="more"></a>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote>
<p>首先去官方下载最新版的solr</p>
</blockquote>
<p><a href="http://www.apache.org/dyn/closer.lua/lucene/solr/7.7.1" target="_blank" rel="noopener">http://www.apache.org/dyn/closer.lua/lucene/solr/7.7.1</a></p>
<blockquote>
<p>解压文件</p>
</blockquote>
<p><img src="/2019/03/05/other/solr-server/1.png" alt></p>
<p>其中有如上文件，展开<code>/bin</code>文件夹，其中就是直接可运行的脚本程序：</p>
<p><img src="/2019/03/05/other/solr-server/2.png" alt></p>
<blockquote>
<p>运行Solr</p>
</blockquote>
<p>上面基本下载完成，由于作者使用的是MacOS系统，所以使用命令行在<code>/bin</code>目录下执行<code>./solr start</code>命令:</p>
<p><img src="/2019/03/05/other/solr-server/3.png" alt></p>
<p>如图就启动了Solr服务器（警告信息忽略，我本地电脑原因）。如果是WIN系统，就双击<code>solr.cmd</code>。</p>
<blockquote>
<p>测试</p>
</blockquote>
<p>上面启动了Solr服务器，可以在浏览器上访问：<code>localhost:8983</code>：</p>
<p><img src="/2019/03/05/other/solr-server/4.png" alt></p>
<p>进入到Solr-Admin管理界面，在这里可以对Solr数据进行CRUD。</p>
<blockquote>
<p>命令</p>
</blockquote>
<p>了解几个常用命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./solr start  --启动Solr</span><br><span class="line">$ ./solr restart –p 8983  --重启Solr</span><br><span class="line">$ ./solr stop –all  --停止Solr</span><br></pre></td></tr></table></figure>

<h2 id="新建core"><a href="#新建core" class="headerlink" title="新建core"></a>新建core</h2><p>在Solr中有一个core的概念，可以将core理解为一个数据库，我们的数据需要存入到core(数据库)中，然后对core(数据库)进行CRUD。</p>
<blockquote>
<p>1.在<code>solr-7.7.1/server/solr/</code>目录下创建<code>new_core</code>文件夹</p>
</blockquote>
<p>其中<code>new_core</code>就相当于数据库名：</p>
<p><img src="/2019/03/05/other/solr-server/5.png" alt></p>
<blockquote>
<p>2.将<code>solr-7.7.1/example/example-DIH/solr/db</code>下的<code>conf</code>文件夹copy到<code>new_core</code>文件夹下</p>
</blockquote>
<p>copy了<code>conf</code>文件夹，再手动创建<code>data</code>文件夹：</p>
<p><img src="/2019/03/05/other/solr-server/6.png" alt></p>
<blockquote>
<p>3.新建core</p>
</blockquote>
<p>重启Solr服务器，刷新页面，点击Core Admin，选择Add Core，名称默认就是<code>new_core</code>无需修改：</p>
<p><img src="/2019/03/05/other/solr-server/7.png" alt></p>
<p>出现如上页面就证明你新建core成功！</p>
<h2 id="配置IK分词器"><a href="#配置IK分词器" class="headerlink" title="配置IK分词器"></a>配置IK分词器</h2><p>Solr新版本默认提供了分词器，但是没有IK分词器好使，所以可以配置IK分词器：</p>
<ul>
<li>GitHub仓库地址：<a href="https://github.com/magese/ik-analyzer-solr7" target="_blank" rel="noopener">传送门</a></li>
<li>jar下载地址： <a href="https://search.maven.org/search?q=com.github.magese" target="_blank" rel="noopener">IK-Analyzer-Solr7</a></li>
</ul>
<ol>
<li><p>将下载的<code>ik-analyzer-solr7-7.x.jar</code>文件copy到<code>solr-7.7.1/server/solr-webapp/webapp/WEB-INF/lib</code>文件夹下。</p>
</li>
<li><p>修改<code>solr-7.7.1/server/solr/new_core/conf/managed-schema</code>，在<code>&lt;schema&gt;</code>节点下copy如下内容：</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ik分词器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fieldType</span> <span class="attr">name</span>=<span class="string">"text_ik"</span> <span class="attr">class</span>=<span class="string">"solr.TextField"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">analyzer</span> <span class="attr">type</span>=<span class="string">"index"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tokenizer</span> <span class="attr">class</span>=<span class="string">"org.wltea.analyzer.lucene.IKTokenizerFactory"</span> <span class="attr">useSmart</span>=<span class="string">"false"</span> <span class="attr">conf</span>=<span class="string">"ik.conf"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"solr.LowerCaseFilterFactory"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">analyzer</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">analyzer</span> <span class="attr">type</span>=<span class="string">"query"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tokenizer</span> <span class="attr">class</span>=<span class="string">"org.wltea.analyzer.lucene.IKTokenizerFactory"</span> <span class="attr">useSmart</span>=<span class="string">"true"</span> <span class="attr">conf</span>=<span class="string">"ik.conf"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"solr.LowerCaseFilterFactory"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">analyzer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fieldType</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>重启Solr服务器</li>
</ol>
<p><img src="/2019/03/05/other/solr-server/9.png" alt></p>
<p>在<code>new_core</code>的<code>Analysis</code>选项中输入<code>text_ik</code>如果下拉菜单中显示了就证明IK分词器安装成功。</p>
<h2 id="导入数据库数据"><a href="#导入数据库数据" class="headerlink" title="导入数据库数据"></a>导入数据库数据</h2><p>Solr提供了一个功能实现将Mysql数据库中的数据一键导入到Solr数据库中。</p>
<blockquote>
<p>1.新建数据库（或表）</p>
</blockquote>
<p>开始之前我们新建一个数据库用于测试：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> springboot_solr <span class="keyword">charset</span> utf8;</span><br><span class="line"><span class="keyword">use</span> springboot_solr;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`info`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`info`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`username`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`email`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`qq`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`password`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">33324</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`info`</span> <span class="keyword">values</span> (<span class="number">1</span>, <span class="string">'tycoding'</span>, <span class="string">'123@qq.com'</span>, <span class="string">'8989723'</span>, <span class="string">'sdhsh90'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`info`</span> <span class="keyword">values</span> (<span class="number">2</span>, <span class="string">'tumo'</span>, <span class="string">'tycoding@163.com'</span>, <span class="string">'8989723'</span>, <span class="string">'tumo'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`info`</span> <span class="keyword">values</span> (<span class="number">3</span>, <span class="string">'涂陌'</span>, <span class="string">'123@163.com'</span>, <span class="string">'8989723'</span>, <span class="string">'tycodingss'</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>2.修改<code>solr-7.7.1/server/solr/new_core/conf/db-data-config.xml</code></p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dataConfig</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">name</span>=<span class="string">"springboot_solr"</span> <span class="attr">type</span>=<span class="string">"JdbcDataSource"</span> <span class="attr">driver</span>=<span class="string">"com.mysql.jdbc.Driver"</span> <span class="attr">url</span>=<span class="string">"jdbc:mysql://127.0.0.1:3306/springboot_solr"</span> <span class="attr">user</span>=<span class="string">"root"</span> <span class="attr">password</span>=<span class="string">"password"</span> <span class="attr">batchSize</span>=<span class="string">"-1"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">document</span> <span class="attr">name</span>=<span class="string">"springboot_solr"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">entity</span> <span class="attr">name</span>=<span class="string">"info"</span> <span class="attr">pk</span>=<span class="string">"id"</span> <span class="attr">query</span>=<span class="string">"select * from info"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">name</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">column</span>=<span class="string">"username"</span> <span class="attr">name</span>=<span class="string">"username"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">column</span>=<span class="string">"email"</span> <span class="attr">name</span>=<span class="string">"email"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">column</span>=<span class="string">"qq"</span> <span class="attr">name</span>=<span class="string">"qq"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">column</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">entity</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">document</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataConfig</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如上，很熟悉，应该是连接数据库的一段配置，其中<code>&lt;field&gt;</code>和数据库表字段一一对应即可。注意修改为本机的数据库用户名密码。</p>
<blockquote>
<p>3.修改<code>solr-7.7.1/server/solr/new_core/conf/managed-schema</code></p>
</blockquote>
<p><code>managed-schema</code>其实就是XML文档，在solr5之前的老版本中用<code>schema.xml</code>来管理，其实也就是<code>managed-schema</code>文件，所以我们直接编辑<code>managed-schema</code>文件：</p>
<p>定位到<code>managed-schema</code>文件的124行，看到<code>managed-schema</code>中默认定义了很多字段信息，为了避免字段重复冲突，可以将其删除：</p>
<p><img src="/2019/03/05/other/solr-server/8.png" alt></p>
<p>注意，不要乱删，一些常见的名词，比如：name, age, title, author 这些一看就是示例的字段可以删除，特殊的不要删。当然可以都不删除，报错了再删除也不迟。</p>
<p>并在其中添加如下内容：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">type</span>=<span class="string">"string"</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">stored</span>=<span class="string">"true"</span> <span class="attr">required</span>=<span class="string">"true"</span> <span class="attr">multiValued</span>=<span class="string">"false"</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">type</span>=<span class="string">"string"</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">stored</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"email"</span> <span class="attr">type</span>=<span class="string">"string"</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">stored</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"qq"</span> <span class="attr">type</span>=<span class="string">"string"</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">stored</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">type</span>=<span class="string">"string"</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">stored</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"keyword"</span> <span class="attr">type</span>=<span class="string">"text_ik"</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">stored</span>=<span class="string">"false"</span> <span class="attr">multiValued</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">copyField</span> <span class="attr">source</span>=<span class="string">"username"</span> <span class="attr">dest</span>=<span class="string">"keyword"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">copyField</span> <span class="attr">source</span>=<span class="string">"email"</span> <span class="attr">dest</span>=<span class="string">"keyword"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uniqueKey</span>&gt;</span>id<span class="tag">&lt;/<span class="name">uniqueKey</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li><code>text_ik</code>指IK分词器的类型。</li>
<li><code>&lt;copyField&gt;</code>的<code>dest</code>指向了<code>&lt;field&gt;</code>的<code>name</code>选项。为复制域，目的是实现同时查询复制域中的匹配记录。</li>
<li><code>&lt;field&gt;</code>的<code>type</code>分别代表不同的数据类型，你会发现定义为不同的类型，查询匹配的数据会受影响。</li>
</ol>
<blockquote>
<p>4.copy依赖</p>
</blockquote>
<p>去maven仓库找一个<code>mysql-connector-java-xx.jar</code>依赖并且将<code>solr-7.7.1/dist</code>下的<code>solr-dataimporthandler-7.7.1.jar</code>,<code>solr-dataimporthandler-extras-7.7.1.jar</code>这三个jar文件全部copy到<code>solr-7.7.1/server/solr-webapp/webapp/WEB-INF/lib</code>文件夹下。</p>
<blockquote>
<p>4.重启服务</p>
</blockquote>
<p><img src="/2019/03/05/other/solr-server/10.png" alt></p>
<p>在<code>new_core</code>的<code>Dataimport</code>选项中可以看到连接数据库的配置，它的功能就是通过连接本地的MySQL数据库，依据配置的<code>db-data-config.xml</code>查询数据库表中的数据，并根据<code>managed-schema</code>中的<code>&lt;field&gt;</code>将匹配的字段数据存入到solr中。</p>
<p>执行<code>Execute</code>导入数据，可以<code>Refresh Status</code>刷新状态。</p>
<p>然后点击Query，如果数据库连接成功、jar文件都导入了且Solr配置正确，那么查询当前<code>new_core</code>中的数据：</p>
<p><img src="/2019/03/05/other/solr-server/11.png" alt></p>
<p>点击Query查询：</p>
<p><img src="/2019/03/05/other/solr-server/12.png" alt></p>
<p>即为数据库中新增的数据，现在导入到了solr数据库中。</p>
<h2 id="多core配置"><a href="#多core配置" class="headerlink" title="多core配置"></a>多core配置</h2><p>我们可以吧core认为是solr数据库的一个数据库，那么必然可以配置多个数据库，步骤请按照上面创建<code>new_core</code>的过程进行重复即可。</p>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>官网下载的Solr内置了Jetty服务器，所以操作都比较简单了，如果想把Solr部署到Tomcat服务器中，需要配置的地方比较多，请看我的这篇文档：<a href="https://tycoding.cn/2018/09/24/other/solr/" target="_blank" rel="noopener">Solr及Spring-Data-Solr入门</a></p>
<p>我在文章中已经把配置好的solr-tomcat上传到了 <a href="https://github.com/TyCoding/solr-tomcat" target="_blank" rel="noopener">Github</a> 仓库，建议直接使用我配置好的。</p>
<br>

<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <categories>
        <category>solr</category>
      </categories>
      <tags>
        <tag>solr</tag>
      </tags>
  </entry>
  <entry>
    <title>（十）Spring Boot2整合Swagger2.9.2</title>
    <url>/2019/02/27/boot/spring-boot-swagger/</url>
    <content><![CDATA[<h1 id="Spring-Boot2整合Swagger2-9-2"><a href="#Spring-Boot2整合Swagger2-9-2" class="headerlink" title="Spring Boot2整合Swagger2.9.2"></a>Spring Boot2整合Swagger2.9.2</h1><p>:tada: :tada: :tada: <strong>这里有丰富的 Spring 框架学习案例</strong></p>
<p><strong>仓库地址：<a href="https://github.com/TyCoding/spring-learn" target="_blank" rel="noopener">spring-learn</a></strong><br><strong>欢迎star、fork，给作者一些鼓励</strong></p>
<p>在学习或开发一些项目时，常会遇到前端需要一份详细的后端API说明文档，因此Swagger的诞生就是为了实现这个需求的。Swagger提供了非常好看的界面，并且提供了API测试工具，类似Postman工具的功能。</p>
<p>所以，这次我们就学习一下如何在SpringBoot项目中部署Swagger2</p>
<a id="more"></a>

<h1 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h1><h2 id="依赖导入"><a href="#依赖导入" class="headerlink" title="依赖导入"></a>依赖导入</h2><p>相信你注意到了，这里我为什么特意强调Swagger的版本，截止2019-2-27，Swagger的最新版是2.9.2，而很多教程中Swagger还是老版本，就造成了很多注解报错或和图片中的不一样。</p>
<p>在这里，我采用了如下版本：</p>
<ul>
<li>Spring Boot 2.1.3.RELEASE</li>
<li>Swagger 2.9.2</li>
</ul>
<p>导入Swagger2依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果你用过Swagger2高版本就知道总会出现错误：<code>java.lang.NumberFormatException: For input string: &quot;&quot;</code>，说是<code>example</code>设置问题，但是最有效的解决办法是添加如下依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用Swagger2最新版本2.9.2避免NumberFormatException错误要引入下列两个依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.swagger<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>swagger-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.swagger<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>swagger-models<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>新建<code>/config/SwaggerConfig.java</code>配置类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger</span>2</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">createRestApi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">"cn.tycoding.controller"</span>))</span><br><span class="line">                .paths(PathSelectors.regex(<span class="string">"/.*"</span>))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">apiInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">                .title(<span class="string">"Spring Boot中使用使用Swagger2构建RESTful API"</span>)</span><br><span class="line">                .description(<span class="string">"文档地址：https://github.com/TyCoding/spring-boot-learn"</span>)</span><br><span class="line">                .termsOfServiceUrl(<span class="string">"http://tycoding.cn/"</span>)</span><br><span class="line">                .contact(<span class="keyword">new</span> Contact(<span class="string">"tycoding"</span>, <span class="string">"https://tycoding.cn"</span>, <span class="string">""</span>))</span><br><span class="line">                .version(<span class="string">"v1.0"</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些都是Swagger全局配置信息，其中最需要注意的有以下几点：</p>
<ul>
<li><p>Swagger生成API文档方式是通过扫描指定package下的请求映射类，根据映射接口生成API文档接口，所以关键是配置好扫描的接口类地址。</p>
</li>
<li><p><code>.apis(RequestHandlerSelectors.basePackage(&quot;cn.tycoding.controller&quot;))</code>扫描请求映射类package地址。一般用SpringMVC时，我们常把请求应映射类放在<code>/controller/</code>package下。</p>
</li>
<li><p><code>.paths(PathSelectors.regex(&quot;/.*&quot;))</code>扫描请求的路径，比如你想在Swagger中显示所有以<code>/rest</code>开头的接口地址（比如<code>rest/save</code>），就设置<code>regex(&quot;/rest/.*&quot;)</code>，这个<code>.*</code>就是匹配所有子级请求。这里我们配置的扫描所有请求。</p>
</li>
</ul>
<p>看<code>PathSelectors</code>类源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathSelectors</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">PathSelectors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Predicate&lt;String&gt; <span class="title">any</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Predicates.alwaysTrue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Predicate&lt;String&gt; <span class="title">none</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Predicates.alwaysFalse();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Predicate&lt;String&gt; <span class="title">regex</span><span class="params">(<span class="keyword">final</span> String pathRegex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Predicate&lt;String&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> input.matches(pathRegex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Predicate&lt;String&gt; <span class="title">ant</span><span class="params">(<span class="keyword">final</span> String antPattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Predicate&lt;String&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">                AntPathMatcher matcher = <span class="keyword">new</span> AntPathMatcher();</span><br><span class="line">                <span class="keyword">return</span> matcher.match(antPattern, input);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现它能支持4中方式按照路径生成API文档：1.任何路径都生成；2.任何路径都不生成；3.正则匹配路径；4.ant模式匹配。</p>
<p>上面我们就是配置的正则匹配路径，按照正则标准，Swagger扫描对应的API接口并生成文档。</p>
<p>如果你还有疑惑，可以先看一下项目整体结构：</p>
<p><img src="/2019/02/27/boot/spring-boot-swagger/1.png" alt></p>
<h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><p>既然都用到了Swagger，那就必然要遵循Restful接口规范，最基本的规范：</p>
<table>
<thead>
<tr>
<th align="left">前端请求方法</th>
<th align="left">对应后端操作</th>
</tr>
</thead>
<tbody><tr>
<td align="left">POST</td>
<td align="left">新增</td>
</tr>
<tr>
<td align="left">PUT</td>
<td align="left">更新</td>
</tr>
<tr>
<td align="left">GET</td>
<td align="left">查询</td>
</tr>
<tr>
<td align="left">DELETE</td>
<td align="left">删除</td>
</tr>
</tbody></table>
<p>更多的Restful接口规范请自行百度。</p>
<p>通常在前后端分离项目中，后端仅负责接收和传递JSON数据，所以，我们这样创建一个Controller：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/article"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleController</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>@RestController</code>是<code>@ResponseBody</code>+<code>@Controller</code>，其控制器类下的所有方法的返回值都将被Spring转换成JSON格式。</p>
</li>
<li><p><code>@RequestMapping</code>是这个控制器类的父级映射地址，旗下接口方法映射地址就为：<code>/article/aa</code>, <code>/article/bb</code></p>
</li>
</ul>
<h2 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h2><h3 id="Article"><a href="#Article" class="headerlink" title="Article"></a>Article</h3><p>为了模拟实际中业务，这里创建一个实体类<code>Article.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Article</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id; <span class="comment">//文章ID</span></span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">//文章名称</span></span><br><span class="line">    <span class="keyword">private</span> String title; <span class="comment">//文章标题</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime; <span class="comment">//创建时间</span></span><br><span class="line">    </span><br><span class="line">    ...<span class="comment">//省略getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>通常，Controller返回的数据都应该被封装在一个结果类中，目的是保证所有请求返回结果都有固定的响应格式，比如：状态码、状态信息、返回结果。所以我们简单封装一个结果类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseCode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long code;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResponseCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResponseCode</span><span class="params">(Long code, String msg, Object data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ResponseCode <span class="title">ok</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseCode(<span class="number">200L</span>, msg, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ResponseCode <span class="title">ok</span><span class="params">(String msg, Object data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseCode(<span class="number">200L</span>, msg, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...<span class="comment">//省略getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ArticleController"><a href="#ArticleController" class="headerlink" title="ArticleController"></a>ArticleController</h3><p>完善控制器类，模拟常见的CRUD业务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/article"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(value = <span class="string">"/&#123;id&#125;"</span>, produces = <span class="string">"application/json"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseCode <span class="title">findById</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"查询文章信息，查询的文章ID是==&gt; &#123;&#125;"</span>, id);</span><br><span class="line">        Article article = <span class="keyword">new</span> Article(<span class="number">1L</span>, <span class="string">"Swagger"</span>, <span class="string">"SpringBoot整合Swagger2"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">        <span class="keyword">return</span> ResponseCode.ok(<span class="string">"查询成功"</span>, article);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping</span>(value = <span class="string">"/&#123;id&#125;"</span>, produces = <span class="string">"application/json"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseCode <span class="title">delete</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"删除文章信息，删除的文章ID是==&gt; &#123;&#125;"</span>, id);</span><br><span class="line">        <span class="keyword">return</span> ResponseCode.ok(<span class="string">"删除成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(value = <span class="string">"/"</span>, produces = <span class="string">"application/json"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseCode <span class="title">save</span><span class="params">(@RequestBody Article article)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"保存文章信息，文章内容==&gt; &#123;&#125;"</span>, article);</span><br><span class="line">        <span class="keyword">return</span> ResponseCode.ok(<span class="string">"保存成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping</span>(value = <span class="string">"/"</span>, produces = <span class="string">"application/json"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseCode <span class="title">update</span><span class="params">(@RequestBody Article article)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"更新文章信息，更新内容==&gt; &#123;&#125;"</span>, article);</span><br><span class="line">        <span class="keyword">return</span> ResponseCode.ok(<span class="string">"更新成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，我们完成了基础操作。</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>启动项目，访问<code>localhost:8080/swagger-ui.html</code>：</p>
<p><img src="/2019/02/27/boot/spring-boot-swagger/2.png" alt></p>
<p>是不是很神奇呢，这么炫酷漂亮的界面Swagger已经帮我们写好了，根据刚才配置的<code>.apis(RequestHandlerSelectors.basePackage(&quot;cn.tycoding.controller&quot;))</code>Swagger扫描到了<code>ArticleController</code>这个控制器类，根据刚才配置的<code>.paths(PathSelectors.regex(&quot;/.*&quot;))</code>Swagger扫描了这个控制器的所有请求映射路径，并且生成API文档。</p>
<p>更神奇的在这里：</p>
<p>任意点开一个接口，点击左侧的Try it out，可以直接测试这个接口，就像Postman工具一样，并且旗下有丰富的接口文档信息</p>
<p><img src="/2019/02/27/boot/spring-boot-swagger/3.png" alt></p>
<p>可以看到我们模拟的接口请求成功，并且返回了响应数据。</p>
<h2 id="进阶配置"><a href="#进阶配置" class="headerlink" title="进阶配置"></a>进阶配置</h2><blockquote>
<p>修改<code>ArticleController</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/article"</span>)</span><br><span class="line"><span class="meta">@Api</span>(value = <span class="string">"ArticleController"</span>, tags = &#123;<span class="string">"文章管理接口"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(value = <span class="string">"/&#123;id&#125;"</span>, produces = <span class="string">"application/json"</span>)</span><br><span class="line">    <span class="meta">@ApiOperation</span>(value = <span class="string">"查询文章详情"</span>, notes = <span class="string">"文章ID大于0"</span>)</span><br><span class="line">    <span class="meta">@ApiImplicitParam</span>(name = <span class="string">"id"</span>, value = <span class="string">"文章编号"</span>, required = <span class="keyword">true</span>, dataType = <span class="string">"Long"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseCode <span class="title">findById</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"查询文章信息，查询的文章ID是==&gt; &#123;&#125;"</span>, id);</span><br><span class="line">        Article article = <span class="keyword">new</span> Article(<span class="number">1L</span>, <span class="string">"Swagger"</span>, <span class="string">"SpringBoot整合Swagger2"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">        <span class="keyword">return</span> ResponseCode.ok(<span class="string">"查询成功"</span>, article);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping</span>(value = <span class="string">"/&#123;id&#125;"</span>, produces = <span class="string">"application/json"</span>)</span><br><span class="line">    <span class="meta">@ApiOperation</span>(value = <span class="string">"删除文章"</span>)</span><br><span class="line">    <span class="meta">@ApiImplicitParam</span>(name = <span class="string">"id"</span>, value = <span class="string">"文章编号"</span>, required = <span class="keyword">true</span>, dataType = <span class="string">"Long"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseCode <span class="title">delete</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"删除文章信息，删除的文章ID是==&gt; &#123;&#125;"</span>, id);</span><br><span class="line">        <span class="keyword">return</span> ResponseCode.ok(<span class="string">"删除成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(value = <span class="string">"/"</span>, produces = <span class="string">"application/json"</span>)</span><br><span class="line">    <span class="meta">@ApiOperation</span>(value = <span class="string">"保存文章"</span>)</span><br><span class="line">    <span class="meta">@ApiImplicitParam</span>(name = <span class="string">"article"</span>, value = <span class="string">"文章信息实体"</span>, required = <span class="keyword">true</span>, dataType = <span class="string">"Article"</span>, paramType = <span class="string">"body"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseCode <span class="title">save</span><span class="params">(@RequestBody Article article)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"保存文章信息，文章内容==&gt; &#123;&#125;"</span>, article);</span><br><span class="line">        <span class="keyword">return</span> ResponseCode.ok(<span class="string">"保存成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping</span>(value = <span class="string">"/"</span>, produces = <span class="string">"application/json"</span>)</span><br><span class="line">    <span class="meta">@ApiOperation</span>(value = <span class="string">"更新文章"</span>)</span><br><span class="line">    <span class="meta">@ApiImplicitParam</span>(name = <span class="string">"article"</span>, value = <span class="string">"文章信息实体"</span>, required = <span class="keyword">true</span>, dataType = <span class="string">"Article"</span>, paramType = <span class="string">"body"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseCode <span class="title">update</span><span class="params">(@RequestBody Article article)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"更新文章信息，更新内容==&gt; &#123;&#125;"</span>, article);</span><br><span class="line">        <span class="keyword">return</span> ResponseCode.ok(<span class="string">"更新成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>修改<code>Article.java</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiModel</span>(value = <span class="string">"Article"</span>, description = <span class="string">"文章实体对象"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Article</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@ApiModelProperty</span> 用于描述实体字段</span></span><br><span class="line"><span class="comment">     *      value: 字段说明</span></span><br><span class="line"><span class="comment">     *      name: 重写字段名称</span></span><br><span class="line"><span class="comment">     *      dataType: 重写字段类型</span></span><br><span class="line"><span class="comment">     *      required: 字段是否必填</span></span><br><span class="line"><span class="comment">     *      example: 举例说明</span></span><br><span class="line"><span class="comment">     *      hidden: 是否隐藏显示</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"id"</span>, example = <span class="string">"1"</span>, required = <span class="keyword">true</span>)</span><br><span class="line">    <span class="keyword">private</span> Long id; <span class="comment">//文章ID</span></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(name = <span class="string">"name"</span>, value = <span class="string">"文章名称"</span>, example = <span class="string">"Swagger"</span>, required = <span class="keyword">true</span>)</span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">//文章名称</span></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(name = <span class="string">"title"</span> ,value = <span class="string">"文章标题"</span>, example = <span class="string">"SpringBoot中使用Swagger"</span>, required = <span class="keyword">true</span>)</span><br><span class="line">    <span class="keyword">private</span> String title; <span class="comment">//文章标题</span></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(name = <span class="string">"createTime"</span>, value = <span class="string">"创建时间"</span>, required = <span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">private</span> Date createTime; <span class="comment">//创建时间   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看配置效果</p>
</blockquote>
<p><img src="/2019/02/27/boot/spring-boot-swagger/4.png" alt></p>
<p>如上图所示，我在图中标记了Swagger注解对应的配置效果</p>
<h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><blockquote>
<p>在控制器类</p>
</blockquote>
<ul>
<li><p>@Api: 标记在控制器类上</p>
<ul>
<li>value: 控制器类名称</li>
<li>tags: 控制器类标签</li>
</ul>
</li>
<li><p>@ApiOperation: 标记在映射方法上</p>
<ul>
<li>value: 接口说明，展示在接口列表</li>
<li>notes：接口详细说明，展示在接口的详情页。</li>
<li>tags：接口的标签，相同标签的接口会在一个标签页下展示。</li>
<li>httpMethod：支持的HTTP的方法。</li>
</ul>
</li>
<li><p>@ApiImplicitParam: 请求参数属性配置</p>
<ul>
<li>name：参数名称</li>
<li>value：参数说明</li>
<li>required：是否必须</li>
<li>dataType：数据类型　　</li>
</ul>
</li>
</ul>
<p>注意<code>@ApiImplicitParams</code>是<code>@ApiImplicitParam</code>的容器，通过<code>@ApiImplicitParam</code>可以配置请求参数个各自的属性，但是若请求参数是一个实体对象，<code>@ApiImplicitParam</code>也可以直接指向对象(<code>dataType</code>=<code>@ApiModel</code>的<code>value</code>值)，然后在实体对象中对字段进行限定。</p>
<blockquote>
<p>在实体类上</p>
</blockquote>
<ul>
<li><p>@ApiModel是对整个类的属性的配置：</p>
<ul>
<li>value：类的说明</li>
<li>description：详细描述</li>
</ul>
</li>
<li><p>@ApiModelProperty是对具体每个字段的属性配置：</p>
<ul>
<li>name：字段名称</li>
<li>value：字段的说明</li>
<li>required：是否必须</li>
<li>example：示例值</li>
<li>hidden：是否显示</li>
</ul>
</li>
</ul>
<br>

<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <categories>
        <category>spring-boot</category>
      </categories>
      <tags>
        <tag>spring-boot</tag>
      </tags>
  </entry>
  <entry>
    <title>（九）Spring Boot整合Mail邮件服务</title>
    <url>/2019/02/27/boot/spring-boot-mail/</url>
    <content><![CDATA[<h1 id="Spring-Boot整合邮件服务"><a href="#Spring-Boot整合邮件服务" class="headerlink" title="Spring Boot整合邮件服务"></a>Spring Boot整合邮件服务</h1><p>:tada: :tada: :tada: <strong>这里有丰富的 Spring 框架学习案例</strong></p>
<p><strong>仓库地址：<a href="https://github.com/TyCoding/spring-learn" target="_blank" rel="noopener">spring-learn</a></strong><br><strong>欢迎star、fork，给作者一些鼓励</strong></p>
<p>Spring Boot也对<code>JavaMail</code>进行了封装简化。以前学JavaWeb的时候学习过调用JavaMail进行邮件，那时候需要配置的选项还是蛮多的，今天看到 <a href="http://www.ityouknow.com/springboot/2017/05/06/springboot-mail.html" target="_blank" rel="noopener">纯洁的微笑</a> 大佬关于SpringBoot邮件服务的文章，如今也可以愉快的玩一下邮件发送。</p>
<a id="more"></a>

<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><h2 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="修改application-yml"><a href="#修改application-yml" class="headerlink" title="修改application.yml"></a>修改<code>application.yml</code></h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  mail:</span></span><br><span class="line">    <span class="comment">#邮件服务器地址</span></span><br><span class="line"><span class="attr">    host:</span> <span class="string">smtp.163.com</span></span><br><span class="line">    <span class="comment">#用户名</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">tycoding_tumo@163.com</span></span><br><span class="line">    <span class="comment">#密码</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">客户端授权密码</span></span><br><span class="line"><span class="attr">    default-encoding:</span> <span class="string">UTF-8</span></span><br><span class="line"><span class="attr">    properties:</span></span><br><span class="line"><span class="attr">      mail:</span></span><br><span class="line">        <span class="string">smtp.auth:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  thymeleaf:</span></span><br><span class="line"><span class="attr">    mode:</span> <span class="string">LEGACYHTML5</span></span><br><span class="line"><span class="attr">    cache:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#发件人邮箱</span></span><br><span class="line"><span class="string">mail.from:</span> <span class="string">tycoding_tumo@163.com</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<blockquote>
<p>spring.mail.host是邮件服务器的地址</p>
</blockquote>
<p>可以登录自己的163邮箱查看（其他邮箱雷同）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">服务器地址:</span><br><span class="line">POP3服务器: pop.163.com</span><br><span class="line">SMTP服务器: smtp.163.com</span><br><span class="line">IMAP服务器: imap.163.com</span><br></pre></td></tr></table></figure>

<blockquote>
<p>username是邮箱登录名</p>
</blockquote>
<p>这里我全以163邮箱为例</p>
<blockquote>
<p>password是客户端授权密码不是登录密码</p>
</blockquote>
<p>因为需要使用smtp服务，需要在163邮箱设置中开启smtp服务（其他邮箱也是），而在163邮箱中开启smtp服务需要设置客户端授权码，这个密码就是我们第三方API请求163服务的验证密码</p>
<blockquote>
<p>mail.from是发件人邮箱</p>
</blockquote>
<p>名字是自定义的。一般情况下，<code>spring.mail.username</code>和<code>mail.from</code>是一样的</p>
<h1 id="邮件服务"><a href="#邮件服务" class="headerlink" title="邮件服务"></a>邮件服务</h1><h2 id="基础邮件"><a href="#基础邮件" class="headerlink" title="基础邮件"></a>基础邮件</h2><p>创建一个服务层方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JavaMailSender mailSender;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;mail.from&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String from;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送普通邮件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> to      收件人邮箱</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subject 邮件主题</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content 邮件内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMail</span><span class="params">(String to, String subject, String content)</span> </span>&#123;</span><br><span class="line">        SimpleMailMessage mailMessage = <span class="keyword">new</span> SimpleMailMessage();</span><br><span class="line">        mailMessage.setFrom(from);</span><br><span class="line">        mailMessage.setTo(to);</span><br><span class="line">        mailMessage.setSubject(subject);</span><br><span class="line">        mailMessage.setText(content);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mailSender.send(mailMessage);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailServiceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MailService mailService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mailService.sendMail(<span class="string">"tycoding_tumo@163.com"</span>, <span class="string">"测试邮件"</span>, <span class="string">"hello this test email"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HTML格式邮件"><a href="#HTML格式邮件" class="headerlink" title="HTML格式邮件"></a>HTML格式邮件</h2><p>Service服务层方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送HTML格式的邮件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> to      收件人邮箱</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> subject 邮件主题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> content 邮件内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendHtmlMail</span><span class="params">(String to, String subject, String content)</span> </span>&#123;</span><br><span class="line">    MimeMessage mimeMessage = mailSender.createMimeMessage();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MimeMessageHelper helper = <span class="keyword">new</span> MimeMessageHelper(mimeMessage, <span class="keyword">true</span>);</span><br><span class="line">        helper.setFrom(from);</span><br><span class="line">        helper.setTo(to);</span><br><span class="line">        helper.setSubject(subject);</span><br><span class="line">        helper.setText(content, <span class="keyword">true</span>);</span><br><span class="line">        mailSender.send(mimeMessage);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MessagingException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendHtmlMail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String html = <span class="string">"&lt;html&gt;\n"</span> +</span><br><span class="line">            <span class="string">"&lt;body&gt;\n"</span> +</span><br><span class="line">            <span class="string">"&lt;h2&gt;this a html email&lt;/h2&gt;\n"</span> +</span><br><span class="line">            <span class="string">"&lt;/body&gt;\n"</span> +</span><br><span class="line">            <span class="string">"&lt;/html&gt;"</span>;</span><br><span class="line">    mailService.sendHtmlMail(<span class="string">"tycoding_tumo@163.com"</span>, <span class="string">"测试HTML邮件"</span>, html);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="携带附件的邮件"><a href="#携带附件的邮件" class="headerlink" title="携带附件的邮件"></a>携带附件的邮件</h2><p>Service服务层方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送携带附件的邮件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> to       收件人邮箱</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> subject  邮件主题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> content  邮件内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> filePath 文件地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendAttachmentsMail</span><span class="params">(String to, String subject, String content, String filePath)</span> </span>&#123;</span><br><span class="line">    MimeMessage mimeMessage = mailSender.createMimeMessage();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MimeMessageHelper helper = <span class="keyword">new</span> MimeMessageHelper(mimeMessage, <span class="keyword">true</span>);</span><br><span class="line">        helper.setFrom(from);</span><br><span class="line">        helper.setTo(to);</span><br><span class="line">        helper.setSubject(subject);</span><br><span class="line">        helper.setText(content, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        FileSystemResource file = <span class="keyword">new</span> FileSystemResource(<span class="keyword">new</span> File(filePath));</span><br><span class="line">        String fileName = filePath.substring(filePath.lastIndexOf(File.separator));</span><br><span class="line">        helper.addAttachment(fileName, file);</span><br><span class="line"></span><br><span class="line">        mailSender.send(mimeMessage);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MessagingException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendAttachmentsMail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String filePath = <span class="string">"/tycoding/learn-plan.md"</span>;</span><br><span class="line">    mailService.sendAttachmentsMail(<span class="string">"tycoding_tumo@163.com"</span>, <span class="string">"测试携带附件的邮件"</span>, <span class="string">"这是携带附件的邮件，请注意查收"</span>, filePath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HTML内联资源邮件"><a href="#HTML内联资源邮件" class="headerlink" title="HTML内联资源邮件"></a>HTML内联资源邮件</h2><p>Service服务层方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送HTML标签内携带资源的邮件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> to      收件人邮箱</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> subject 邮件主题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> content 邮件内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resPath 资源路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resId   资源ID</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendInlineResourceMail</span><span class="params">(String to, String subject, String content, String resPath, String resId)</span> </span>&#123;</span><br><span class="line">    MimeMessage mimeMessage = mailSender.createMimeMessage();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MimeMessageHelper helper = <span class="keyword">new</span> MimeMessageHelper(mimeMessage, <span class="keyword">true</span>);</span><br><span class="line">        helper.setFrom(from);</span><br><span class="line">        helper.setTo(to);</span><br><span class="line">        helper.setSubject(subject);</span><br><span class="line">        helper.setText(content, <span class="keyword">true</span>);</span><br><span class="line">        FileSystemResource resource = <span class="keyword">new</span> FileSystemResource(<span class="keyword">new</span> File(resPath));</span><br><span class="line">        helper.addInline(resId, resource);</span><br><span class="line">        mailSender.send(mimeMessage);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendInlineResourceMail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String to = <span class="string">"tycoding_tumo@163.com"</span>;</span><br><span class="line">    String subject = <span class="string">"这是携带内联资源的邮件"</span>;</span><br><span class="line">    String resId = <span class="string">"001"</span>;</span><br><span class="line">    String resPath = <span class="string">"/tycoding/totoro.png"</span>;</span><br><span class="line">    String content = <span class="string">"&lt;html&gt;\n"</span> +</span><br><span class="line">            <span class="string">"&lt;body&gt;\n"</span> +</span><br><span class="line">            <span class="string">"这是带图片的邮件&lt;img src=\'resId:"</span> + resId + <span class="string">"\'&gt;"</span> +</span><br><span class="line">            <span class="string">"&lt;/body&gt;\n"</span> +</span><br><span class="line">            <span class="string">"&lt;/html&gt;"</span>;</span><br><span class="line">    mailService.sendInlineResourceMail(to, subject, content, resPath, resId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模板邮件"><a href="#模板邮件" class="headerlink" title="模板邮件"></a>模板邮件</h2><p>比如一些网站常用发送发送验证码到邮箱，通常这是用一个模板的，比如这样：</p>
<p>在<code>resources/</code>下创建模板<code>emailTemplate.html</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>邮件模板<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">您好，欢迎注册本系统，您的验证码是： <span class="tag">&lt;<span class="name">b</span> <span class="attr">th:text</span>=<span class="string">"$&#123;code&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line"></span><br><span class="line">-- TyCoding</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Service层方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> TemplateEngine templateEngine;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送模板邮件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> to      收件人邮箱</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> subject 邮件主题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> code    邮件验证码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendTemplateMail</span><span class="params">(String to, String subject, String code)</span> </span>&#123;</span><br><span class="line">    Context context = <span class="keyword">new</span> Context();</span><br><span class="line">    context.setVariable(<span class="string">"code"</span>, code);</span><br><span class="line">    String emailContent = templateEngine.process(<span class="string">"emailTemplate"</span>, context);</span><br><span class="line">    sendHtmlMail(to, subject, emailContent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendTemplateMail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> code = (<span class="keyword">int</span>) (Math.random() * <span class="number">9</span> + <span class="number">1</span>) * <span class="number">100000</span>;</span><br><span class="line">    mailService.sendTemplateMail(<span class="string">"tycoding_tumo@163.com"</span>, <span class="string">"这是模板邮件"</span>, String.valueOf(code));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h1><p>在实际测试中遇到了很多错误，比如：</p>
<h2 id="550-User-has-no-permission"><a href="#550-User-has-no-permission" class="headerlink" title="550 User has no permission"></a>550 User has no permission</h2><blockquote>
<p>解释</p>
</blockquote>
<p>一般是因为你的163邮箱没有开启<code>客户端授权</code>，导致第三方API调用163服务被拒绝</p>
<blockquote>
<p>解决办法</p>
</blockquote>
<p>登录163邮箱，配置<code>客户端授权</code>，并且开启<code>设置POP3/SMTP/IMAP</code>服务</p>
<h2 id="535-Error-authentication-failed"><a href="#535-Error-authentication-failed" class="headerlink" title="535 Error: authentication failed"></a>535 Error: authentication failed</h2><blockquote>
<p>解释</p>
</blockquote>
<p>显然是说身份验证失败，一般是因为在<code>application.yml</code>中配置的<code>spring.mail.password</code>是你的邮箱登录密码</p>
<blockquote>
<p>解决办法</p>
</blockquote>
<p>这个<code>spring.mail.password</code>不能填写你的邮箱密码，要写<strong>客户端授权密码</strong>，具体要登录163邮箱查看并设置</p>
<h2 id="553-Mail-from-must-equal-authorized-user"><a href="#553-Mail-from-must-equal-authorized-user" class="headerlink" title="553 Mail from must equal authorized user"></a>553 Mail from must equal authorized user</h2><blockquote>
<p>解释</p>
</blockquote>
<p>一般是因为<code>application.yml</code>中配置的<code>spring.mail.password</code>和<code>mail.from</code>(发件人邮箱)不一致导致的</p>
<blockquote>
<p>解决办法</p>
</blockquote>
<p>对比<code>application.yml</code>中配置的<code>spring.mail.password</code>和<code>mail.from</code></p>
<h2 id="DT-SPM-163-smtp11-D8CowADX"><a href="#DT-SPM-163-smtp11-D8CowADX" class="headerlink" title="DT:SPM 163 smtp11,D8CowADX"></a>DT:SPM 163 smtp11,D8CowADX</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.sun.mail.smtp.SMTPSendFailedException: <span class="number">554</span> DT:SPM <span class="number">163</span> smtp14,EsCowAB3K92VD3ZcPZPeHQ--.<span class="number">26803</span>S2 <span class="number">1551241110</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>解释</p>
</blockquote>
<p>出现这一串代码，一般是说明，你的配置中 发件人邮箱是163邮箱，收件人邮箱是其他邮箱（比如QQ邮箱）。</p>
<blockquote>
<p>解决办法</p>
</blockquote>
<p>经过查百度，163官方是说其不允许发送垃圾邮件，但是这种错误是时不时出现的。在我的测试中，之前几封邮件是从163发送给QQ邮箱是可以的，但是莫名后几次就开始报这个错误了。暂时也不清楚如何解决。只要是163邮箱发送给163邮箱（比如自己发送给自己）就不会报这个错。</p>
<br>

<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <categories>
        <category>spring-boot</category>
      </categories>
      <tags>
        <tag>spring-boot</tag>
      </tags>
  </entry>
  <entry>
    <title>（八）Spring Boot整合Redis</title>
    <url>/2019/02/26/boot/spring-boot-redis/</url>
    <content><![CDATA[<h1 id="Spring-Boot整合Redis"><a href="#Spring-Boot整合Redis" class="headerlink" title="Spring Boot整合Redis"></a>Spring Boot整合Redis</h1><p>:tada: :tada: :tada: <strong>这里有丰富的 Spring 框架学习案例</strong></p>
<p><strong>仓库地址：<a href="https://github.com/TyCoding/spring-learn" target="_blank" rel="noopener">spring-learn</a></strong><br><strong>欢迎star、fork，给作者一些鼓励</strong></p>
<p>万能的<code>spring-boot</code>也对nosql数据库进行了封装，比如这里要讲的<code>spring-boot-redis</code>。</p>
<p><strong>致谢</strong></p>
<ul>
<li><p><a href="https://github.com/wuyouzhuguli/" target="_blank" rel="noopener">mrbird</a></p>
</li>
<li><p><a href="http://www.ityouknow.com/" target="_blank" rel="noopener">纯洁的微笑</a></p>
</li>
</ul>
<a id="more"></a>

<h1 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h1><p>首先我们需要在本地或者自己的服务器上安装Redis程序，基础教程我推荐阅读我的这篇文章：</p>
<p><a href="https://tycoding.cn/2018/09/24/other/redis/" target="_blank" rel="noopener">Redis及spring-data-redis入门案例</a></p>
<p>这里我们要用Spring Boot整合Redis，首先</p>
<h2 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--redis--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以看到，这也是<code>spring-boot</code>官方对redis进行了封装自动化。</p>
<h2 id="修改application-yml"><a href="#修改application-yml" class="headerlink" title="修改application.yml"></a>修改<code>application.yml</code></h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  redis:</span></span><br><span class="line">    <span class="comment">#redis数据库，默认是0</span></span><br><span class="line"><span class="attr">    database:</span> <span class="number">1</span></span><br><span class="line">    <span class="comment">#redis服务器地址</span></span><br><span class="line"><span class="attr">    host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="comment">#redis服务端口，默认6379</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="comment">#redis密码，默认为空</span></span><br><span class="line"><span class="attr">    password:</span></span><br></pre></td></tr></table></figure>

<p>如上是本地的redis数据库地址。注意，<code>database</code>选项若不配置默认就是<code>db0</code>，如上就是<code>db1</code>数据库.</p>
<h2 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h2><p>关于如何安装Redis，请阅读我的这篇文章: <a href="https://tycoding.cn/2018/09/24/other/redis/" target="_blank" rel="noopener">Redis及spring-data-redis入门案例</a></p>
<p>本地Redis启动后，可以下载可视化工具：<code>Redis Desktop Manager</code>工具查看本地Redis数据库信息：</p>
<p><img src="/2019/02/26/boot/spring-boot-redis/1.png" alt></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>完成了以上步骤，可以在测试类中测试是否配置成功:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootRedisApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        redisTemplate.boundValueOps(<span class="string">"new_key"</span>).set(<span class="string">"new_value"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动上面测试方法，再次回到<code>Redis Desktop Manager</code>可视化工具查看，出现了一条新的记录：</p>
<p><img src="/2019/02/26/boot/spring-boot-redis/2.png" alt></p>
<p><strong>注</strong></p>
<p>可以看到，存入到本地Redis数据库中的数据是乱码的（但是，尽管存入Redis数据库中数据是乱码的，但只要用<code>RedisTemplate</code>获取数据就还是正常不乱码的数据），其实就是序列化的原因，所以我们要了解<code>RedisTemplate</code>的序列化策略：</p>
<table>
<thead>
<tr>
<th align="left">name</th>
<th align="left">tips</th>
</tr>
</thead>
<tbody><tr>
<td align="left">RedisTemplate</td>
<td align="left">默认采用JDK的序列化策略，key和value都是用这种序列化策略保存的</td>
</tr>
<tr>
<td align="left">StringRedisTemplate</td>
<td align="left">默认采用String的序列化策略，key和value都是用这种序列化策略保存的</td>
</tr>
</tbody></table>
<p>而翻看源码，发现<code>StringRedisTemplate</code>其实是<code>RedisTemplate</code>的一个子类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringRedisTemplate</span> <span class="keyword">extends</span> <span class="title">RedisTemplate</span>&lt;<span class="title">String</span>, <span class="title">String</span>&gt; </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>那么我们可以这样测试添加数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootRedisApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, String&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        redisTemplate.boundValueOps(<span class="string">"new_key4"</span>).set(<span class="string">"new_value4"</span>);</span><br><span class="line">        stringRedisTemplate.boundValueOps(<span class="string">"new_key3"</span>).set(<span class="string">"new_value3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2019/02/26/boot/spring-boot-redis/3.png" alt></p>
<p>可以看到无论是使用<code>RedisTemplate&lt;String, String&gt;</code>还是<code>StringRedisTemplate</code>，新增的数据都没有乱码。</p>
<p>但是这种方式就必须保证存入的<code>key</code>和<code>value</code>都是String类型，通过<code>toString</code>或<code>String.valueOf(xx)</code>转换即可。</p>
<h1 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h1><p>经过上面的配置学习，我们可以通过<code>RedisTemplate</code>实现一些操作Redis数据库的基本Shell命令。</p>
<h2 id="RedisService"><a href="#RedisService" class="headerlink" title="RedisService"></a>RedisService</h2><p>封装一个<code>RedisService.java</code>接口:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RedisService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取Redis基础info列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;RedisInfo&gt; <span class="title">getRedisInfo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取Redis内存占用信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Map&lt;String, Object&gt; <span class="title">getRedisMemory</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取Redis key的数量 --dbsize</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Map&lt;String, Object&gt; <span class="title">getRedisDbSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过pattern正则匹配模糊查询Keys列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pattern</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Set&lt;String&gt; <span class="title">getKeys</span><span class="params">(String pattern)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取key的value</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> key-value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">get</span><span class="params">(String arg)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加key-value</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否添加成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Boolean <span class="title">set</span><span class="params">(String key, String value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除key</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keys keys数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成功删除key的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Long <span class="title">del</span><span class="params">(String... keys)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断key是否存在</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keys keys数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 存在key的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Long <span class="title">exists</span><span class="params">(String... keys)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取key的剩余过期时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 若key不存在返回-2；若key存在但没有设置过期时间返回-1；否则返回该key的剩余过期时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Long <span class="title">pttl</span><span class="params">(String key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以毫秒为单位设置key的生成时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 毫秒值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 设置成功的key个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Long <span class="title">pexpire</span><span class="params">(String key, Long time)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，封装了一些操作Redis常用的命令，看名称就大概能猜到其对应的shell命令是什么（可以通过<code>redis-cli</code>工具测试）。</p>
<h2 id="RedisServiceImpl"><a href="#RedisServiceImpl" class="headerlink" title="RedisServiceImpl"></a>RedisServiceImpl</h2><h3 id="getRedisMemory"><a href="#getRedisMemory" class="headerlink" title="getRedisMemory"></a>getRedisMemory</h3><p><code>redis memory</code>其实就是Redis <code>info</code>命令中的Redis内存占用信息，通过<code>redis-cli</code>工具查看：</p>
<p><img src="/2019/02/26/boot/spring-boot-redis/4.png" alt></p>
<p><code>info</code>命令能获取到指定数据库的完整信息（默认是<code>db0</code>），其中就有很多<code>memory</code>，这里我们直接获取<code>used_memory</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getRedisMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> redisTemplate.execute(<span class="keyword">new</span> RedisCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">doInRedis</span><span class="params">(RedisConnection redisConnection)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line">            Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            map.put(<span class="string">"memory"</span>, redisConnection.info(<span class="string">"memory"</span>).get(<span class="string">"used_memory"</span>))</span><br><span class="line">            <span class="keyword">return</span> map;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然<code>spring-data-redis</code>提供了<code>RedisTemplate</code>和<code>StringRedisTemplate</code>模板类，但还是不能满足我们的需求。因此可以调用<code>redisTemplate.execute</code>方法，通过<code>CallBack</code>回调机制可以获取到更多redis信息。</p>
<p>因为，可能要多次调用<code>RedisCallback</code>，这里就进行简单的封装：（并且对返回值进行简单的封装）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RedisConnection <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (RedisConnection) redisTemplate.execute(<span class="keyword">new</span> RedisCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">doInRedis</span><span class="params">(RedisConnection redisConnection)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> redisConnection;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getRedisMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getData(<span class="string">"memory"</span>, execute().info(<span class="string">"memory"</span>).get(<span class="string">"used_memory"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Map&lt;String, Object&gt; <span class="title">getData</span><span class="params">(String name, Object data)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">"create_time"</span>, (<span class="keyword">new</span> Date()).getTime());</span><br><span class="line">    map.put(name, data);</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试这个方法，可以获取到当前Redis的内存占用信息，如：<code>memory: 1056696</code></p>
<h2 id="getDbSize"><a href="#getDbSize" class="headerlink" title="getDbSize"></a>getDbSize</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getRedisDbSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getData(<span class="string">"dbsize"</span>, execute().dbSize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>dbSize()</code>方法也可以获取到当前Redis服务的Keys数量。其对应shell命令的<code>dbsize</code>命令。</p>
<h2 id="getRedisInfo"><a href="#getRedisInfo" class="headerlink" title="getRedisInfo"></a>getRedisInfo</h2><p>也可以调用<code>.info()</code>命令获取到Redis数据库信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;RedisInfo&gt; <span class="title">getRedisInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        List&lt;RedisInfo&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Properties info = execute().info();</span><br><span class="line">        <span class="keyword">for</span> (String key : info.stringPropertyNames()) &#123;</span><br><span class="line">            RedisInfo redisInfo = <span class="keyword">new</span> RedisInfo();</span><br><span class="line">            redisInfo.setKey(key);</span><br><span class="line">            redisInfo.setValue(info.getProperty(key));</span><br><span class="line">            list.add(redisInfo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>redisConnection().info()</code>返回的是<code>Properties</code>对象，它其实实现了<code>Map&lt;&gt;</code>接口，因此储存的数据是<code>key-value</code>形式。那么下面看一下<code>RedisInfo</code>封装的属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisInfo</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">            map.put(<span class="string">"redis_version"</span>, <span class="string">"Redis 服务器版本"</span>);</span><br><span class="line">            map.put(<span class="string">"redis_git_sha1"</span>, <span class="string">"Git SHA1"</span>);</span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKey</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.description = map.get(<span class="keyword">this</span>.key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDescription</span><span class="params">(String description)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.description = description;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上，获取到Redis的info信息，并按照key-value的形式储存到List集合中。同时我们可以向Map中储存<code>map.put(&quot;key&quot;, &quot;value&quot;)</code>，匹配Redis info中对应的key-value就可以将每个key对应的中文解释封装进实体类中。</p>
<p>最终，在前端渲染出来的数据就是：</p>
<p><img src="/2019/02/26/boot/spring-boot-redis/5.png" alt></p>
<h2 id="getKeys"><a href="#getKeys" class="headerlink" title="getKeys"></a>getKeys</h2><p>在<code>redis-cli</code>中我们常用<code>keys pattern</code>获取当前数据库中的keys信息，其中的<code>pattern</code>是类似正则匹配的值，比如<code>keys *</code>就是获取当前Redis数据库中的所有key。</p>
<p>于是，我这样封装一个方法获取keys信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getKeys</span><span class="params">(String pattern)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.keys(pattern);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是可以的，通过<code>redisTemplate.keys(pattern)</code>模糊查询keys信息，但是之前我这样注入<code>redisTemplate</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate redisTemplate;</span><br></pre></td></tr></table></figure>

<p>而这样写调用<code>getKeys(&quot;*&quot;)</code>却获取不到任何数据，这就回到了之前我们说的序列化原因了，于是可以改为这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate&lt;String, String&gt; redisTemplate;</span><br></pre></td></tr></table></figure>

<p>就能正确的查询Redis数据库的数据了。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>操纵Redis还有很多shell命令，因此<code>RedisTemplate</code>模板类中也就封装了很多方法用于操作Redis，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = execute().get(key.getBytes());</span><br><span class="line">            <span class="keyword">if</span> (bytes != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> String(bytes, redisCode);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">set</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> execute().set(key.getBytes(), value.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">del</span><span class="params">(String... keys)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;keys.length;i++) &#123;</span><br><span class="line">            result += execute().del(keys[i].getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">exists</span><span class="params">(String... keys)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;keys.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (execute().exists(keys[i].getBytes())) &#123;</span><br><span class="line">                result ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">pttl</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> execute().pTtl(key.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">pexpire</span><span class="params">(String key, Long time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (execute().pExpire(key.getBytes(), time)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1L</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line">    &#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>

<p>其中</p>
<table>
<thead>
<tr>
<th align="left">method</th>
<th align="left">means</th>
</tr>
</thead>
<tbody><tr>
<td align="left">del</td>
<td align="left">删除key-value</td>
</tr>
<tr>
<td align="left">exists</td>
<td align="left">判断该key是否存在</td>
</tr>
<tr>
<td align="left">pttl</td>
<td align="left">获取该key的剩余过期时间，若key不存在返回-2；若key存在但没有设置过期时间返回-1；否则返回该key的剩余过期时间</td>
</tr>
<tr>
<td align="left">pexpire</td>
<td align="left">为key设置过期时间</td>
</tr>
</tbody></table>
<h2 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h2><p>创建<code>RedisServiceImpl.java</code>的测试类<code>RedisServiceImplTest.java</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisServiceImplTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, String&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisService redisService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getKeys</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//        Set&lt;String&gt; keys = stringRedisTemplate.keys("*");</span></span><br><span class="line"><span class="comment">//        logger.info("keys=&#123;&#125;", keys);</span></span><br><span class="line"><span class="comment">//        Set&lt;String&gt; keys1 = redisTemplate.keys("*");</span></span><br><span class="line"><span class="comment">//        logger.info("keys1=&#123;&#125;", keys1);</span></span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; keys = redisService.getKeys(<span class="string">"*"</span>);</span><br><span class="line">        logger.info(<span class="string">"keys=&#123;&#125;"</span>, keys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Boolean set = redisService.set(<span class="string">"new_key"</span>, <span class="string">"new_value"</span>);</span><br><span class="line">        logger.info(<span class="string">"是否新增=&#123;&#125;"</span>, set);</span><br><span class="line">        getKeys();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String key = redisService.get(<span class="string">"new_key"</span>);</span><br><span class="line">        logger.info(<span class="string">"key=&#123;&#125;"</span>, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        redisService.set(<span class="string">"new_key2"</span>, <span class="string">"new_value2"</span>);</span><br><span class="line">        redisService.set(<span class="string">"new_key3"</span>, <span class="string">"new_value3"</span>);</span><br><span class="line">        String[] keys = &#123;<span class="string">"new_key2"</span>, <span class="string">"new_key3"</span>&#125;;</span><br><span class="line">        Long count = redisService.del(keys);</span><br><span class="line">        logger.info(<span class="string">"删除的个数=&#123;&#125;"</span>, count);</span><br><span class="line">        getKeys();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exists</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String[] keys = &#123;<span class="string">"new_key"</span>&#125;;</span><br><span class="line">        Long exists = redisService.exists(keys);</span><br><span class="line">        logger.info(<span class="string">"是否存在=&#123;&#125;"</span>, exists);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pttl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Long time = redisService.pttl(<span class="string">"new_key"</span>);</span><br><span class="line">        logger.info(<span class="string">"剩余过期时间=&gt;&#123;&#125;"</span>, time);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pexpire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Long result = redisService.pexpire(<span class="string">"new_key"</span>, <span class="number">10000000000L</span>);</span><br><span class="line">        logger.info(<span class="string">"是否设置成功=&#123;&#125;"</span>, result);</span><br><span class="line">        pttl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h1><p><img src="/2019/02/26/boot/spring-boot-redis/6.gif" alt></p>
<p><img src="/2019/02/26/boot/spring-boot-redis/7.png" alt></p>
<p><img src="/2019/02/26/boot/spring-boot-redis/8.png" alt></p>
<br>

<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <categories>
        <category>spring-boot</category>
      </categories>
      <tags>
        <tag>spring-boot</tag>
      </tags>
  </entry>
  <entry>
    <title>（十六）SpringSecurity实现图形验证码校验</title>
    <url>/2019/02/26/boot/spring-boot-security-validate/</url>
    <content><![CDATA[<h1 id="SpringSecurity图形验证码校验"><a href="#SpringSecurity图形验证码校验" class="headerlink" title="SpringSecurity图形验证码校验"></a>SpringSecurity图形验证码校验</h1><p>:tada: :tada: :tada: <strong>这里有丰富的 Spring 框架学习案例</strong></p>
<p><strong>仓库地址：<a href="https://github.com/TyCoding/spring-learn" target="_blank" rel="noopener">spring-learn</a></strong><br><strong>欢迎star、fork，给作者一些鼓励</strong></p>
<p>接着上一篇文章：<a href="https://tycoding.cn/2019/04/11/boot/spring-boot-security/" target="_blank" rel="noopener">SpringBoot整合SpringSecurity</a>，这次我们学习Spring Security如何实现图形验证码校验。</p>
<a id="more"></a>

<blockquote>
<p>依赖引入</p>
</blockquote>
<p>实现验证码登录，后台除了负责生成验证码，还应该维护验证码的生命周期，而为了给验证码赋予一个生命周期，通常，我们会将验证码数据保存在Session中。比如页面长时间未刷新，此时的验证码就应该失效并重新刷新验证码的值。那么我们可以通过<code>HttpSession</code>实现，像之前学习Shiro一样。而在Spring Secuirty中，提供了<code>spring-social</code>类库，他提供了一些方法实现系统的第三方登录，比如QQ、微信等，为了配合后面学习<code>Security-OAuth</code>，这里我们导入<code>spring-social</code>的依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.social<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-social-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>SessionStrategy</code>的使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SessionStrategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(RequestAttributes var1, String var2, Object var3)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">getAttribute</span><span class="params">(RequestAttributes var1, String var2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeAttribute</span><span class="params">(RequestAttributes var1, String var2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="工具类封装"><a href="#工具类封装" class="headerlink" title="工具类封装"></a>工具类封装</h2><blockquote>
<p> 1.创建<code>ImageCode.java</code>，封装验证码对象属性</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageCode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证码BufferedImage对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> BufferedImage image;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证码String值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证码过期时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime expireTime;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImageCode</span><span class="params">(BufferedImage image, String code, <span class="keyword">int</span> expireIn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.image = image;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.expireTime = LocalDateTime.now().plusSeconds(expireIn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isExpire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.now().isAfter(expireTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>2.创建<code>ImageCodeGenerator.java</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageCodeGenerator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ImageCode <span class="title">createImageCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> width = ImageConstants.CODE_WIDTH;</span><br><span class="line">        <span class="keyword">int</span> height = ImageConstants.CODE_HEIGHT;</span><br><span class="line">        <span class="keyword">int</span> length = ImageConstants.CODE_LENGTH;</span><br><span class="line">        <span class="keyword">int</span> fontSize = ImageConstants.CODE_FONT_SIZE;</span><br><span class="line">        <span class="keyword">int</span> expireIn = ImageConstants.CODE_EXPIREIN;</span><br><span class="line">        BufferedImage image = <span class="keyword">new</span> BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);</span><br><span class="line">        Graphics g = image.getGraphics();</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">        g.setColor(getRandColor(<span class="number">200</span>, <span class="number">250</span>));</span><br><span class="line">        g.fillRect(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">        g.setFont(<span class="keyword">new</span> Font(<span class="string">"Times New Roman"</span>, Font.ITALIC, fontSize));</span><br><span class="line">        g.setColor(getRandColor(<span class="number">160</span>, <span class="number">200</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">155</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = random.nextInt(width);</span><br><span class="line">            <span class="keyword">int</span> y = random.nextInt(height);</span><br><span class="line">            <span class="keyword">int</span> xl = random.nextInt(<span class="number">12</span>);</span><br><span class="line">            <span class="keyword">int</span> yl = random.nextInt(<span class="number">12</span>);</span><br><span class="line">            g.drawLine(x, y, x + xl, y + yl);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuilder sRand = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            String rand = String.valueOf(random.nextInt(<span class="number">10</span>));</span><br><span class="line">            sRand.append(rand);</span><br><span class="line">            g.setColor(<span class="keyword">new</span> Color(<span class="number">20</span> + random.nextInt(<span class="number">110</span>), <span class="number">20</span> + random.nextInt(<span class="number">110</span>), <span class="number">20</span> + random.nextInt(<span class="number">110</span>)));</span><br><span class="line">            g.drawString(rand, <span class="number">13</span> * i + <span class="number">6</span>, <span class="number">16</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        g.dispose();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ImageCode(image, sRand.toString(), expireIn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Color <span class="title">getRandColor</span><span class="params">(<span class="keyword">int</span> fc, <span class="keyword">int</span> bc)</span> </span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">if</span> (fc &gt; <span class="number">255</span>) &#123;</span><br><span class="line">            fc = <span class="number">255</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bc &gt; <span class="number">255</span>) &#123;</span><br><span class="line">            bc = <span class="number">255</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> r = fc + random.nextInt(bc - fc);</span><br><span class="line">        <span class="keyword">int</span> g = fc + random.nextInt(bc - fc);</span><br><span class="line">        <span class="keyword">int</span> b = fc + random.nextInt(bc - fc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Color(r, g, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面都是Java生成图片的一些方法，不是重点不再说。其中上面都用到了一个类：<code>ImageConstants</code>，这个是我简单封装的储存图片验证码相关常量的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImageConstants</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证码宽度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> CODE_WIDTH = <span class="number">67</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证码高度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> CODE_HEIGHT = <span class="number">23</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证码的过期时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> CODE_EXPIREIN = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证码的位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> CODE_LENGTH = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证码字体大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> CODE_FONT_SIZE = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证码格式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String CODE_TYPE = <span class="string">"JPEG"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Session中存验证码的key值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String SESSION_KEY_CODE = <span class="string">"SESSION_KEY_IMAGE_CODE"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录表单验证码name值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String LOGIN_FORM_CODE = <span class="string">"code"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比起写一个class存放一些final变量，感觉用接口更加方便。</p>
<h2 id="获取验证码的接口"><a href="#获取验证码的接口" class="headerlink" title="获取验证码的接口"></a>获取验证码的接口</h2><p>上面创建了工具类，此时可以提供一个专门用于获取验证码的Controller:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidateCodeController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SessionStrategy sessionStrategy = <span class="keyword">new</span> HttpSessionSessionStrategy();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取验证码</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/code/image"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCode</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ImageCode imageCode = ImageCodeGenerator.createImageCode();</span><br><span class="line">        sessionStrategy.setAttribute(<span class="keyword">new</span> ServletWebRequest(request), ImageConstants.SESSION_KEY_CODE, imageCode);</span><br><span class="line">        ImageIO.write(imageCode.getImage(), ImageConstants.CODE_TYPE, response.getOutputStream());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>首先调用<code>ImageGenerator</code>工具类的<code>createImageCode</code>方法生成一个验证码对象<code>ImageCode</code>。</li>
<li>调用<code>SessionStrategy</code>把当前的<code>ImageCode</code>对象储存在Session中。</li>
<li>调用<code>ImageIO.write()</code>方法将<code>BufferedImage</code>对象转换为一个图片格式的文件并写入到response响应流中。</li>
</ol>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>上面通过一个接口可以向前端返回一个验证码图片，但需要配置此接口在未登录情况时不拦截：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.antMatchers(<span class="string">"/login"</span>, <span class="string">"/code/image"</span>).permitAll()</span><br></pre></td></tr></table></figure>

<p>同时，在前端登录表单上加上验证码选项：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/auth/login"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"Username"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">placeholder</span>=<span class="string">"Password"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"code"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"Code"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/code/image"</span> <span class="attr">style</span>=<span class="string">"margin-bottom: -12px;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Login"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>启动项目：</p>
<p><img src="/2019/02/26/boot/spring-boot-security-validate/1.png" alt></p>
<p>至此，我们仅仅完成了图形验证码的绘制即展示，即使在Controller层将验证码对象储存在Session中，但是，并没有任何地方使用了这个Session。</p>
<h2 id="验证码过滤器"><a href="#验证码过滤器" class="headerlink" title="验证码过滤器"></a>验证码过滤器</h2><p><img src="/2019/02/26/boot/spring-boot-security-validate/19.png" alt></p>
<p>在之前学习的Spring Security过滤器链中，我们说<code>SecurityContextPersistenceFilter</code>是直接与请求交互的最前端的过滤器，<code>UsernamePasswordAuthenticationFilter</code>用于处理这个请求，而因为加了验证码校验，应该在<code>UsernamePasswordAuthenticationFilter</code>过滤器前面再判断如果验证码校验通过再校验用户名和密码，否者就直接抛出异常。</p>
<p>所以，我们需要创建一个验证码过滤器用于专门校验输入的验证码值；并且，这个验证码过滤器应该放在<code>UsernamePasswordAuthenticationFilter</code>过滤器前面执行。</p>
<p>在<code>cn/tycoding/filter/</code>下创建<code>ValidateCodeFilter</code>并继承<code>OncePerRequestFilter</code>(表示这个过滤器只执行一次，避免了每次请求都会执行这个过滤器)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidateCodeFilter</span> <span class="keyword">extends</span> <span class="title">OncePerRequestFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationFailureHandler authenticationFailureHandler;</span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="keyword">private</span> SessionStrategy sessionStrategy = <span class="keyword">new</span> HttpSessionSessionStrategy();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.equals(<span class="string">"/auth/login"</span>, request.getRequestURI()) &amp;&amp; StringUtils.equalsIgnoreCase(request.getMethod(), <span class="string">"POST"</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                validate(<span class="keyword">new</span> ServletWebRequest(request));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ValidateCodeException e) &#123;</span><br><span class="line">                authenticationFailureHandler.onAuthenticationFailure(request, response, e);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        filterChain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">(ServletWebRequest request)</span> <span class="keyword">throws</span> ServletRequestBindingException </span>&#123;</span><br><span class="line">        ImageCode codeInSession = (ImageCode) sessionStrategy.getAttribute(request, ImageConstants.SESSION_KEY_CODE);</span><br><span class="line">        String codeInRequest = ServletRequestUtils.getStringParameter(request.getRequest(), ImageConstants.LOGIN_FORM_CODE);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(codeInRequest)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ValidateCodeException(<span class="string">"验证码的值不能为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (codeInSession == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ValidateCodeException(<span class="string">"验证码不存在"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (codeInSession.isExpire()) &#123;</span><br><span class="line">            sessionStrategy.removeAttribute(request, ImageConstants.SESSION_KEY_CODE);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ValidateCodeException(<span class="string">"验证码已过期"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.equals(codeInSession.getCode(), codeInRequest)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ValidateCodeException(<span class="string">"验证码不匹配"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sessionStrategy.removeAttribute(request, ImageConstants.SESSION_KEY_CODE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>过滤器首先判断请求的URL是不是登录的URL，其次还要符合是POST请求方法，然后才视为登录的验证码校验</li>
<li>调用<code>SessionStrategy</code>获取在验证码接口<code>/code/image</code>中设置进Session中的验证码对象<code>ImageCode</code>。</li>
<li>调用<code>ServletRequestUtils</code>获取到表单提交时指定<code>name</code>文本框的值，也就是表单中输入的验证码值。因为整个登录请求都是由Spring Security内部的过滤器实现的，所以登录请求携带的参数可以直接通过Spring的方法获取到。</li>
<li>判断表单中输入的值和Session中储存的值是否存在、是否相符，判断验证码是否过期(根据本地当前时间和验证码过期时间比较)；如果条件不符合就直接抛出异常。</li>
</ol>
<blockquote>
<p>创建<code>ValidateCodeException</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidateCodeException</span> <span class="keyword">extends</span> <span class="title">AuthenticationException</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ValidateCodeException</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这个自定义异常处理器还是继承的<code>AuthenticationException</code>异常处理器。所以这个自定义异常并不是必须的，但为了更加规范的表示这是验证码校验时出现的错误就写上。</p>
<ol start="5">
<li>如果验证码校验失败就清除Session中存在的验证码值。</li>
<li>如果在以上整个过程任意地方出现错误就直接<code>return;</code>不再往下执行过滤器链。</li>
</ol>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>将当前的<code>ValidateCodeFilter</code>过滤器配置到<code>UsernamePasswordFilter</code>过滤器前面执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">http</span><br><span class="line">        .addFilterBefore(validateCodeFilter, UsernamePasswordAuthenticationFilter.class)</span><br><span class="line">        .formLogin()</span><br><span class="line">        .loginPage(<span class="string">"/login"</span>)</span><br><span class="line">        .loginProcessingUrl(<span class="string">"/auth/login"</span>)</span><br><span class="line">        .successHandler(authenticationSuccessHandler)</span><br><span class="line">        .failureHandler(authenticationFailureHandler)</span><br></pre></td></tr></table></figure>

<h2 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h2><p>启动项目，在页面输入用户名密码、验证码登录，在<code>ValidateCodeFilter</code>过滤器处打断点：</p>
<p><img src="/2019/02/26/boot/spring-boot-security-validate/2.png" alt></p>
<h1 id="SpringSecurity记住我"><a href="#SpringSecurity记住我" class="headerlink" title="SpringSecurity记住我"></a>SpringSecurity记住我</h1><p>记住我，顾名思义，即系统能在一段时间内记住当前登录的用户信息，避免用户频繁的输入用户名密码登录系统。在Shiro学习中，记住我功能需要配置<code>RememberCookie</code>，将其注入到<code>RememberMeManager</code>，最终由Shiro内部对这个rememberMe数据管理。</p>
<p>而在Spring Security中，Spring Security内部提供了对rememberMe数据的JDBC工具封装，也就是说如果需要记住我，那么Spring Security会将用户信息都持久化到数据库中。再次请求时会根据请求中携带的Cookie信息和数据库中储存的信息比对来判断当前用户是否已登录。</p>
<p><img src="/2019/02/26/boot/spring-boot-security-validate/3.png" alt></p>
<p>并且，我们再回顾之前的Spring Security过滤器链：</p>
<p><img src="/2019/02/26/boot/spring-boot-security-validate/19.png" alt></p>
<p>这个记住我相关的过滤器配置应该放在<code>UsernamePasswordAuthenticationFilter</code>过滤器的后面。当用户登录后，再次发送请求，此时并不是一个认证请求，Spring Security就不再执行<code>UsernamePasswordAuthenticationFilter</code>，而是直接调用<code>RememberMeAuthenticationFilter</code>过滤器，查询数据库中储存的Token，和浏览器携带的Cookie信息比对。</p>
<h2 id="创建一个Repository"><a href="#创建一个Repository" class="headerlink" title="创建一个Repository"></a>创建一个Repository</h2><p>创建一个<code>PersistentTokenRepository</code>对象用于配置JDBC相关信息，实现Token数据保存到数据库中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PersistentTokenRepository <span class="title">persistentTokenRepository</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    JdbcTokenRepositoryImpl tokenRepository = <span class="keyword">new</span> JdbcTokenRepositoryImpl();</span><br><span class="line">    tokenRepository.setDataSource(dataSource);</span><br><span class="line">    tokenRepository.setCreateTableOnStartup(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> tokenRepository;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>setCreateTableOnStartup</code>如果数据库中不存在<code>persistent_logins</code>这张表，就设为true，下次执行会在数据库中创建该表，如果存在，就将该配置去掉。</p>
<p>添加数据库相关的配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  datasource:</span></span><br><span class="line"><span class="attr">    url:</span> <span class="attr">jdbc:mysql://127.0.0.1:3306/springboot_security?useUnicode=true&amp;characterEncoding=UTF-8</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">    driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure>

<p>注入RememberMe的相关配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line">http</span><br><span class="line">    .and()</span><br><span class="line">    .rememberMe()</span><br><span class="line">    .tokenRepository(persistentTokenRepository())</span><br><span class="line">    .tokenValiditySeconds(<span class="number">60</span>) <span class="comment">//60s</span></span><br><span class="line">    .userDetailsService(userDetailsService)</span><br></pre></td></tr></table></figure>

<p>在前端表单中添加记住我选项：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/auth/login"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"Username"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">placeholder</span>=<span class="string">"Password"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"code"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"Code"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/code/image"</span> <span class="attr">style</span>=<span class="string">"margin-bottom: -12px;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"remember-me"</span> <span class="attr">value</span>=<span class="string">"true"</span>&gt;</span>记住我</span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Login"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h2><blockquote>
<p>1.启动项目</p>
</blockquote>
<p>在登录界面勾选记住我并输入用户名密码进入系统。</p>
<p>可以看到数据库<code>springboot_security</code>中生成了一张表：</p>
<p><img src="/2019/02/26/boot/spring-boot-security-validate/4.png" alt></p>
<blockquote>
<p>2.关闭浏览器，重新打开并访问系统</p>
</blockquote>
<p>在<code>RememberMeAuthenticationFilter</code>中打断点：</p>
<p><img src="/2019/02/26/boot/spring-boot-security-validate/5.png" alt></p>
<p>可以看到此时过滤器得到了RememberMe记住的数据，那么这次访问就不需要登录直接可进入系统了。</p>
<br>

<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <categories>
        <category>spring-boot</category>
      </categories>
      <tags>
        <tag>spring-boot</tag>
      </tags>
  </entry>
  <entry>
    <title>（六）Spring Boot整合Shiro</title>
    <url>/2019/02/26/boot/spring-boot-shiro/</url>
    <content><![CDATA[<h1 id="Spring-Boot整合Shiro"><a href="#Spring-Boot整合Shiro" class="headerlink" title="Spring Boot整合Shiro"></a>Spring Boot整合Shiro</h1><p>:tada: :tada: :tada: <strong>这里有丰富的 Spring 框架学习案例</strong></p>
<p><strong>仓库地址：<a href="https://github.com/TyCoding/spring-learn" target="_blank" rel="noopener">spring-learn</a></strong><br><strong>欢迎star、fork，给作者一些鼓励</strong></p>
<p><strong>写在前面</strong></p>
<p>之前有写过SSM整合Shiro的示例：<a href="https://github.com/TyCoding/shiro" target="_blank" rel="noopener">SSM权限管理示例</a></p>
<p>而在Spring Boot中使用Shiro，就是需要把之前SSM的XML配置转换成Java代码配置，下面我举例用Spring Boot2.x + Shiro实现登录认证。</p>
<a id="more"></a>

<h2 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- shiro --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>由于Shiro本身并没有提供缓存实现，这里使用Shiro官方支持的<code>ehcache</code>缓存：</p>
<p><strong>Ehcache</strong>:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ehcache缓存 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果你想用<code>Redis</code>缓存，可以用这个封装好的插件：</p>
<p><strong>Shiro-redis</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.crazycake<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.2.1-RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="修改application-yml"><a href="#修改application-yml" class="headerlink" title="修改application.yml"></a>修改<code>application.yml</code></h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">datasource:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">springboot</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">  <span class="comment">#druid相关配置</span></span><br><span class="line"><span class="attr">  druid:</span></span><br><span class="line">    <span class="comment">#mysql驱动</span></span><br><span class="line"><span class="attr">    driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="comment">#基本属性</span></span><br><span class="line"><span class="attr">    url:</span> <span class="attr">jdbc:mysql://127.0.0.1:3306/springboot_shiro?useUnicode=true&amp;characterEncoding=UTF-8</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">root</span></span><br></pre></td></tr></table></figure>

<p>更多的配置请看该项目下<code>src/main/resources/application.yml</code></p>
<h2 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- create database springboot_shiro charset utf8;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`user`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line">  <span class="string">`username`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户名'</span>,</span><br><span class="line">  <span class="string">`password`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'密码'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">2</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>

<h2 id="创建ShiroConfig-java"><a href="#创建ShiroConfig-java" class="headerlink" title="创建ShiroConfig.java"></a>创建<code>ShiroConfig.java</code></h2><p>如之前在SSM整合Shiro框架时，Shiro的基础配置一般有如下：</p>
<ul>
<li><p><code>SecurityManager</code>： 安全管理器，Shiro的核心</p>
</li>
<li><p><code>Realm</code>: Shiro从Realm中获取验证数据</p>
</li>
<li><p><code>SessionManager</code>: 会话管理</p>
</li>
<li><p>…</p>
</li>
</ul>
<p>于是，我们就大概知道<code>ShiroConfig.java</code>中大概需要配置什么信息了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShiroConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ShiroFilterFactoryBean <span class="title">shiroFilterFactoryBean</span><span class="params">(SecurityManager securityManager)</span> </span>&#123;</span><br><span class="line">        ShiroFilterFactoryBean filterFactoryBean = <span class="keyword">new</span> ShiroFilterFactoryBean();</span><br><span class="line">        filterFactoryBean.setSecurityManager(securityManager);</span><br><span class="line">        filterFactoryBean.setLoginUrl(<span class="string">"/login"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//自定义拦截器链</span></span><br><span class="line">        Map&lt;String, String&gt; filterChainDefinitionMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">"/logout"</span>, <span class="string">"logout"</span>);</span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">"/login"</span>, <span class="string">"anon"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//静态资源，对应`/resources/static`文件夹下的资源</span></span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">"/css/**"</span>, <span class="string">"anon"</span>);</span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">"/js/**"</span>, <span class="string">"anon"</span>);</span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">"/lib/**"</span>, <span class="string">"anon"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//其他请求一律拦截，一般放在拦截器链的最后</span></span><br><span class="line">        <span class="comment">//区分`user`和`authc`拦截器区别：`user`拦截器允许登录用户和RememberMe的用户访问</span></span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">"/**"</span>, <span class="string">"user"</span>);</span><br><span class="line"></span><br><span class="line">        filterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);</span><br><span class="line">        <span class="keyword">return</span> filterFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Realm <span class="title">realm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AuthRealm();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SecurityManager <span class="title">securityManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultWebSecurityManager securityManager = <span class="keyword">new</span> DefaultWebSecurityManager();</span><br><span class="line">        securityManager.setRealm(realm());</span><br><span class="line">        securityManager.setSessionManager(sessionManager());</span><br><span class="line">        <span class="keyword">return</span> securityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SessionManager <span class="title">sessionManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultWebSessionManager sessionManager = <span class="keyword">new</span> DefaultWebSessionManager();</span><br><span class="line">        sessionManager.setGlobalSessionTimeout(<span class="number">60</span> * <span class="number">60</span> * <span class="number">10</span>); <span class="comment">//10分钟</span></span><br><span class="line">        sessionManager.setSessionDAO(<span class="keyword">new</span> EnterpriseCacheSessionDAO());</span><br><span class="line">        <span class="keyword">return</span> sessionManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义Realm实现"><a href="#自定义Realm实现" class="headerlink" title="自定义Realm实现"></a>自定义Realm实现</h2><p>上面是一个最基本的Shiro环境配置，其实这个XML中配置基本雷同的，相信你也发现了。</p>
<p>下面进行第二部：自定义Realm实现，创建<code>AuthRealm.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 权限校验相关</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> principalCollection</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principalCollection)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 身份认证相关</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> authenticationToken</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> AuthenticationException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken authenticationToken)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1. 从Token中获取输入的用户名密码</span></span><br><span class="line"><span class="comment">         * 2. 通过输入的用户名查询数据库得到密码</span></span><br><span class="line"><span class="comment">         * 3. 调用Authentication进行密码校验</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取用户名密码</span></span><br><span class="line">        String username = (String) authenticationToken.getPrincipal();</span><br><span class="line">        String password = <span class="keyword">new</span> String((<span class="keyword">char</span>[]) authenticationToken.getCredentials());</span><br><span class="line"></span><br><span class="line">        User user = userService.findByUsername(username);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnknownAccountException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!password.equals(user.getPassword())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IncorrectCredentialsException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleAuthenticationInfo(user, password, getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于自定义<code>Realm</code>实现，我们仅需要继承<code>AuthorizingRealm</code>，看源码发现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizingRealm</span> <span class="keyword">extends</span> <span class="title">AuthenticatingRealm</span> <span class="keyword">implements</span> <span class="title">Authorizer</span>, <span class="title">Initializable</span>, <span class="title">PermissionResolverAware</span>, <span class="title">RolePermissionResolverAware</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>继承了一个抽象类，就应该实现重写它的抽象方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection var1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken var1)</span> <span class="keyword">throws</span> AuthenticationException</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>AuthorizationInfo</code>用于权限校验</li>
<li><code>AuthenticationInfo</code>用于身份验证</li>
</ul>
<h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><p>上面配置好了Shiro环境，下面我们实践一下。</p>
<blockquote>
<p>创建<code>index.html</code>和<code>login.html</code>两个页面：</p>
</blockquote>
<p><img src="/2019/02/26/boot/spring-boot-shiro/1.png" alt></p>
<blockquote>
<p>创建<code>LoginController.java</code>，编写路由导航地址</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 首页地址</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(value = &#123;<span class="string">"/"</span>, <span class="string">"/index"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录地址</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/login"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"login"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>几点：</p>
<ul>
<li><code>@Controller</code>用来告诉Spring这是个处理HTTP请求的控制器。</li>
<li><code>@RestController</code>是<code>@ResponseBody</code>和<code>@Controller</code>的组合，被标记的控制器类所有<code>return</code>数据都自动封装为JSON格式。</li>
<li><code>@GetMapping</code>标记该请求是Get请求，如果用Post请求则会报错no support</li>
</ul>
<p>启动项目，在浏览器上访问<code>localhost:8080</code>或者<code>localhost:8080/index</code>发现页面均会跳转到<code>/login</code>这个请求上：</p>
<p><img src="/2019/02/26/boot/spring-boot-shiro/2.png" alt></p>
<p>细心地你会发现请求地址中可能会拼接一个<code>JSESSIONID</code>，并且所有的的请求中均会携带一个<code>Cookie= JSESSIONID</code>。这其实是Shiro用于身份验证用的，Shiro默认生成一个会话ID，并储存在Cookie中，这样浏览器每次的请求头中都将携带这个Cookie数据，Shiro拦截请求，发现这个Cookie值是有效的会话(Session) ID，就判定这个请求是合法的请求，然后再根据自定义拦截器链决定是否对该请求放行。</p>
<h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><blockquote>
<p>编写一个form表单</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>登录页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">th:href</span>=<span class="string">"@&#123;/css/login.css&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>登录页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">action</span>=<span class="string">"/login"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"登录"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"info"</span> <span class="attr">th:text</span>=<span class="string">"$&#123;info&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>编写后台接口 post <code>/login</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 登录接口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> username 用户名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> password 密码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 状态信息或成功页面视图地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/login"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(String username, String password, Model model)</span> </span>&#123;</span><br><span class="line">    String info = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//封装Token信息=用户名+密码</span></span><br><span class="line">    UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(username, password);</span><br><span class="line">    <span class="comment">//获取Shiro Subject实例</span></span><br><span class="line">    Subject subject = SecurityUtils.getSubject();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        subject.login(token);</span><br><span class="line">        info = String.valueOf(subject.isAuthenticated());</span><br><span class="line">        model.addAttribute(<span class="string">"info"</span>, <span class="string">"登录状态 ==&gt; "</span> + info);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"/index"</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnknownAccountException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        info = <span class="string">"未知账户异常"</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        info = <span class="string">"账户名或密码错误"</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        info = <span class="string">"其他异常"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    model.addAttribute(<span class="string">"info"</span>, <span class="string">"登录状态 ==&gt; "</span> + info);</span><br><span class="line">    logger.info(<span class="string">"登录状态 ==&gt; &#123;&#125;"</span>, info);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"/login"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，前台form表单中的<code>action=&quot;/login&quot;</code>和<code>method=&quot;post&quot;</code>决定了请求走这个地址，通过调用<code>subject.login(token)</code>，Shiro自动查询Realm实现，于是找到我们自定义的Realm实现：<code>AuthRealm</code>，进而通过<code>SimpleAuthenticationInfo</code>方法验证了登录用户的身份，如果身份认证成功，就<code>return &quot;/index&quot;</code>，否则就<code>return &quot;/login&quot;</code>。</p>
<p><strong>注</strong></p>
<p>上面出现了两个<code>/login</code>接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/login"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"login"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/login"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(String username, String password, Model model)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这里就提现出了<code>@GetMapping</code>和<code>@PostMapping</code>的优势，利用Java的方法重载创建了两个名称相同的接口，但是根据HTTP请求方法的不同（Get还是Post）会自动寻找对应的映射方法。</p>
<h2 id="结"><a href="#结" class="headerlink" title="结"></a>结</h2><p>更多的Shiro特性可以参看我的这个项目：<a href="https://github.com/TyCoding/shiro" target="_blank" rel="noopener">SSM权限管理示例</a></p>
<p>同时推荐大家阅读张开涛老师的：<a href="https://jinnianshilongnian.iteye.com/blog/2018398" target="_blank" rel="noopener">跟我学Shiro</a></p>
<br>

<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <categories>
        <category>spring-boot</category>
      </categories>
      <tags>
        <tag>spring-boot</tag>
      </tags>
  </entry>
  <entry>
    <title>（五）SpringBoot整合Mybatis通用Mapper</title>
    <url>/2019/02/26/boot/spring-boot-thymeleaf-mybatis/</url>
    <content><![CDATA[<h1 id="SpringBoot整合Thymeleaf、Mybatis"><a href="#SpringBoot整合Thymeleaf、Mybatis" class="headerlink" title="SpringBoot整合Thymeleaf、Mybatis"></a>SpringBoot整合Thymeleaf、Mybatis</h1><p>:tada: :tada: :tada: <strong>这里有丰富的 Spring 框架学习案例</strong></p>
<p><strong>仓库地址：<a href="https://github.com/TyCoding/spring-learn" target="_blank" rel="noopener">spring-learn</a></strong><br><strong>欢迎star、fork，给作者一些鼓励</strong></p>
<h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>前面我们学习了 <a href="https://github.com/TyCoding/spring-boot-learn/tree/master/spring-boot-mybatis" target="_blank" rel="noopener">SpringBoot整合Mybatis</a> 基础CRUD，这里我们结合上一篇文章实战CRUD业务。</p>
<p>其实之前我已经写过一个SpringBoot整合Mybatis的案例：<a href="https://github.com/TyCoding/spring-boot" target="_blank" rel="noopener">传送门</a></p>
<a id="more"></a>

<h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><ul>
<li><p>基础框架：Spring Boot 2.1.3.RELEASE</p>
</li>
<li><p>持久层框架：Mybatis 1.3.1</p>
</li>
<li><p>模板引擎：Thymeleaf 3.0.11.RELEASE</p>
</li>
<li><p>其他：Druid、PageHelper、通用Mapper</p>
</li>
</ul>
<h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><ul>
<li><p>基础框架：ElementUI</p>
</li>
<li><p>JavaScript框架：Vue.js</p>
</li>
</ul>
<h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><ul>
<li><p>语言： JDK1.8</p>
</li>
<li><p>IDE： IDEA 2018.3</p>
</li>
<li><p>依赖管理： Maven</p>
</li>
<li><p>数据库： Mysql 5.7.24</p>
</li>
</ul>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>如上，前端完全依赖Vue.js，这和传统依赖Jquery的前端区别还是蛮大的，使用Vue即要用基于Node.js的前后端分离的开发模式，而本项目中仅仅是在HTML中引入了vue.js，虽然不是完全的前后端分离开发，但项目中我尽量使用Vue.js渲染数据，涉及后端的也仅是用到Thymeleaf的<code>th:replace</code>拼接页面。看下图：</p>
<p><img src="/2019/02/26/boot/spring-boot-thymeleaf-mybatis/3.png" alt></p>
<p><strong>截图</strong></p>
<p><img src="/2019/02/26/boot/spring-boot-thymeleaf-mybatis/4.png" alt></p>
<h1 id="通用Mapper"><a href="#通用Mapper" class="headerlink" title="通用Mapper"></a>通用Mapper</h1><p>开源地址：<a href="https://github.com/abel533/MyBatis-Spring-Boot" target="_blank" rel="noopener">https://github.com/abel533/MyBatis-Spring-Boot</a></p>
<p>之前学习了 <a href="https://github.com/TyCoding/spring-boot-learn/tree/master/spring-boot-mybatis" target="_blank" rel="noopener">SpringBoot整合Mybatis</a> 和 <a href="https://github.com/TyCoding/spring-boot-learn/tree/master/spring-boot-jpa" target="_blank" rel="noopener">SpringBoot整合JPA</a> 发现两者各有优缺点，个人而言还是喜欢用Mybatis。</p>
<p>那么虽然Mybatis目前提供了一些注解来简化XML的编写，但是仍需要手动写SQL，相比JPA仍麻烦很多，有没有可以像JPA那样调用Java方法自动生成SQL的办法呢？于是就有了框架：<a href="https://github.com/abel533/Mapper" target="_blank" rel="noopener">通用Mapper</a></p>
<p><a href="https://github.com/abel533/Mapper" target="_blank" rel="noopener">通用Mapper</a>内置了很多API供开发者调用，目的是简化SQL编写。</p>
<h2 id="mapper-generator代码生成器"><a href="#mapper-generator代码生成器" class="headerlink" title="mapper generator代码生成器"></a>mapper generator代码生成器</h2><p>官方文档：<a href="https://gitee.com/free/Mapper/wikis/4.1.mappergenerator?sort_id=236560" target="_blank" rel="noopener">传送门</a></p>
<p>使用该插件可以方便的生成Entity、Mapper interface、XML</p>
<blockquote>
<p>初始化表结构</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- create database springboot_thymeleaf_mybatis charset utf8;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`user`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line">  <span class="string">`username`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户名'</span>,</span><br><span class="line">  <span class="string">`password`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'密码'</span>,</span><br><span class="line">  <span class="string">`age`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'年龄'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`role`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`role`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'名称'</span>,</span><br><span class="line">  <span class="string">`description`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'描述'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`user_role`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user_role`</span> (</span><br><span class="line">  <span class="string">`user_id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`role_id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>按照官方文档首先引入依赖：</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--mybatis--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mapper--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>tk.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--pagehelper--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- mapper生成依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>创建<code>MyMapper.java</code>用于继承<code>tk.mapper</code>（通用Mapper）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyMapper</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">T</span>&gt;, <span class="title">MySqlMapper</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>创建配置文件: <code>/resources/generator/generatorConfig.xml</code></p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE generatorConfiguration</span></span><br><span class="line"><span class="meta">        PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">"Mysql"</span> <span class="attr">targetRuntime</span>=<span class="string">"MyBatis3Simple"</span> <span class="attr">defaultModelType</span>=<span class="string">"flat"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"beginningDelimiter"</span> <span class="attr">value</span>=<span class="string">"`"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"endingDelimiter"</span> <span class="attr">value</span>=<span class="string">"`"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">type</span>=<span class="string">"tk.mybatis.mapper.generator.MapperPlugin"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mappers"</span> <span class="attr">value</span>=<span class="string">"cn.tycoding.utils.MyMapper"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">"com.mysql.cj.jdbc.Driver"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">connectionURL</span>=<span class="string">"jdbc:mysql://localhost:3306/springboot_thymeleaf_mybatis"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">userId</span>=<span class="string">"root"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">password</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"nullCatalogMeansCurrent"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 生成的entity --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"cn.tycoding.entity"</span> <span class="attr">targetProject</span>=<span class="string">"spring-boot-thymeleaf-mybatis/src/main/java"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 生成的Mapper XML--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"mapper"</span> <span class="attr">targetProject</span>=<span class="string">"spring-boot-thymeleaf-mybatis/src/main/resources"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 生成的Mapper映射类 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"cn.tycoding.mapper"</span> <span class="attr">targetProject</span>=<span class="string">"spring-boot-thymeleaf-mybatis/src/main/java"</span></span></span><br><span class="line"><span class="tag">                             <span class="attr">type</span>=<span class="string">"XMLMAPPER"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">"user"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<ul>
<li><p>按照官方文档会遇到：<code>Table Configuration scheme.table matched more than one table</code>的错误，因此需要配置<code>&lt;property name=&quot;nullCatalogMeansCurrent&quot; value=&quot;true&quot;/&gt;</code>。 <a href="https://blog.csdn.net/qq_40233736/article/details/83314596" target="_blank" rel="noopener">博文</a></p>
</li>
<li><p>按照官方文档配置遇到：<code>The specified target project directory src/main/resources does not exist</code>，要修改所有的<code>targetProject</code>地址加上项目名即可。</p>
</li>
</ul>
<blockquote>
<p>生成代码，创建<code>GeneratorDisplay.java</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GeneratorDisplay</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generator</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        List&lt;String&gt; warnings = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">boolean</span> overwrite = <span class="keyword">true</span>;</span><br><span class="line">        ConfigurationParser cp = <span class="keyword">new</span> ConfigurationParser(warnings);</span><br><span class="line">        File configFile = ResourceUtils.getFile(<span class="string">"classpath:generator/generatorConfig.xml"</span>);</span><br><span class="line">        Configuration config = cp.parseConfiguration(configFile);</span><br><span class="line">        DefaultShellCallback callback = <span class="keyword">new</span> DefaultShellCallback(overwrite);</span><br><span class="line">        MyBatisGenerator myBatisGenerator = <span class="keyword">new</span> MyBatisGenerator(config, callback, warnings);</span><br><span class="line">        myBatisGenerator.generate(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">for</span> (String warning : warnings) &#123;</span><br><span class="line">            System.out.println(warning);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            GeneratorDisplay display = <span class="keyword">new</span> GeneratorDisplay();</span><br><span class="line">            display.generator();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<p>使用<code>new File(&quot;/path&quot;)</code>获取到的仅是项目的根路径地址，用其获取<code>new File(&quot;generator/generatorConfig&quot;)</code>是not found的，要使用Spring提供的<code>ResourceUtils</code>工具类获取项目静态文件路径。</p>
<h3 id="结"><a href="#结" class="headerlink" title="结"></a>结</h3><p>修改<code>generatorConfig.xml</code>中<code>&lt;table&gt;</code>的名称，执行<code>GeneratorDisplay.java</code>就能生成不同的文件：</p>
<p><img src="/2019/02/26/boot/spring-boot-thymeleaf-mybatis/1.png" alt></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><blockquote>
<p>首先需要配置Spring扫描Mapper接口</p>
</blockquote>
<p>方式一： 在Mapper接口上添加<code>@Mapper</code>注解</p>
<p>方式二： 在<code>Application.java</code>启动类上添加<code>@MapperScan()</code>注解扫描所有Mapper接口。注意这里的<code>@MapperScan</code>注解来自<code>tk.mybatis.spring.annotation.MapperScan</code>，用spring的会报错。</p>
<p>在<code>user</code>表中新增一条记录：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> <span class="keyword">values</span> (<span class="number">1</span>, <span class="string">'tycoding'</span>, <span class="string">'123'</span>, <span class="string">'19'</span>);</span><br></pre></td></tr></table></figure>

<p>创建<code>UserMapper.java</code>的测试类<code>UserMapperTest.java</code>:</p>
<p><img src="/2019/02/26/boot/spring-boot-thymeleaf-mybatis/2.png" alt></p>
<p>可以看到，因为<code>UserMapper</code>继承了<code>MyMapper&lt;User&gt;</code>，而<code>MyMapper</code>又继承了<code>Mapper&lt;T&gt;, MySqlMapper&lt;T&gt;</code>。类似Jap中继承<code>JpaRepository</code>，<code>Mapper</code>接口中提供了很多API用于生成SQL，简化SQL编写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMapperTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;User&gt; list = userMapper.selectAll();</span><br><span class="line">        list.forEach(user -&gt; &#123;</span><br><span class="line">            logger.info(<span class="string">"user=&#123;&#125;"</span>, user);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findById</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = userMapper.selectByPrimaryKey(<span class="number">1L</span>);</span><br><span class="line">        logger.info(<span class="string">"user=&#123;&#125;"</span>, user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUsername(<span class="string">"涂陌"</span>);</span><br><span class="line">        user.setPassword(<span class="string">"123"</span>);</span><br><span class="line">        user.setAge(<span class="number">20</span>);</span><br><span class="line">        userMapper.insert(user);</span><br><span class="line">        findAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(<span class="number">2L</span>);</span><br><span class="line">        user.setUsername(<span class="string">"小涂陌"</span>);</span><br><span class="line">        userMapper.updateByPrimaryKey(user);</span><br><span class="line">        findAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userMapper.deleteByPrimaryKey(<span class="number">2L</span>);</span><br><span class="line">        findAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，看到这里，感觉和JPA调用接口的方式很像吧，<code>tk.Mapper</code>能帮我们简化很多SQL的编写，但是复杂的SQL还是需要手动写，这点和JPA一样的。</p>
<p>这里我也只是测试了几个常用的CRUD操作，<code>tk.Mapper</code>提供了很多方法，我们通过方法名就能大概猜到，所以这里不再做更多的测试。</p>
<br>

<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <categories>
        <category>spring-boot</category>
      </categories>
      <tags>
        <tag>spring-boot</tag>
      </tags>
  </entry>
  <entry>
    <title>（四）Spring Boot整合Mybatis</title>
    <url>/2019/02/26/boot/spring-boot-mybatis/</url>
    <content><![CDATA[<h1 id="Spring-Boot整合Mybatis"><a href="#Spring-Boot整合Mybatis" class="headerlink" title="Spring Boot整合Mybatis"></a>Spring Boot整合Mybatis</h1><p>:tada: :tada: :tada: <strong>这里有丰富的 Spring 框架学习案例</strong></p>
<p><strong>仓库地址：<a href="https://github.com/TyCoding/spring-learn" target="_blank" rel="noopener">spring-learn</a></strong><br><strong>欢迎star、fork，给作者一些鼓励</strong></p>
<p>之前讲到 <a href="https://github.com/TyCoding/spring-boot-learn/tree/master/spring-boot-jpa" target="_blank" rel="noopener">Spring Boot整合JPA</a> ，其实对我个人而言还是不够熟悉JPA、hibernate，所以觉得这两种框架使用起来好麻烦啊。一直用的Mybatis作为持久层框架，JPA(Hibernate)主张所有的SQL都用Java代码生成，而Mybatis则更主张用原生SQL。</p>
<p>我也觉得Mybatis这种用XML的方式学习成本更低一些吧，但是熟悉JPA能很大程度简化项目开发。</p>
<p>之前已经用Spring Boot整合Thymeleaf、Mybatis实现了基础的CRUD，并且前端使用Vue.js开发，这里先送上仓库地址：<a href="https://github.com/TyCoding/spring-boot" target="_blank" rel="noopener">传送门</a></p>
<a id="more"></a>

<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h2><p>修改<code>application.yml</code>:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  datasource:</span></span><br><span class="line"><span class="attr">    url:</span> <span class="attr">jdbc:mysql://localhost:3306/springboot_mybatis?characterEncoding=utf-8</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">    driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure>

<h2 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- create database springboot_mybatis charset utf8;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`user`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line">  <span class="string">`username`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户名'</span>,</span><br><span class="line">  <span class="string">`password`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'密码'</span>,</span><br><span class="line">  <span class="string">`create_time`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'创建日期'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">5</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>

<h1 id="注解版"><a href="#注解版" class="headerlink" title="注解版"></a>注解版</h1><p>Mybatis提供了一些注解实现快速CRUD，比如：<code>@Select</code>,<code>@Update</code>,<code>@Insert</code>,<code>@Delete</code></p>
<p>相信你在看这篇文章之前已经用过Mybatis了（比如之前的SSM开发），所以呢，使用注解方式按照XML方式的SQL写法就好。</p>
<p><strong>写在前面</strong></p>
<p>之前在SSM开发时，会在<code>MapperScannerConfigurer</code>中配置：<code>&lt;property name=&quot;basePackage&quot; value=&quot;xxx.mapper&quot;/&gt;</code>用于使用Mybatis的接口代理开发模式（且接口和XML需要名称相同）。那么在SpringBoot整合Mybatis中也要有对应的配置：</p>
<ul>
<li>方式一：在每个interface Mapper前添加<code>@Mapper</code>注解</li>
<li>方式二：在<code>Application.java</code>启动类前添加<code>@MapperScan(&quot;cn.tycoding.mapper&quot;)</code>注解</li>
</ul>
<h2 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h2><p>创建Entity <code>/entity/User.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建interface <code>/mapper/UserMapperAno.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapperAno</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from user"</span>)</span><br><span class="line">    <span class="meta">@Results</span>(&#123;</span><br><span class="line">            <span class="meta">@Result</span>(property = <span class="string">"createTime"</span>, column = <span class="string">"create_time"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from user where id = #&#123;id&#125;"</span>)</span><br><span class="line">    <span class="meta">@Results</span>(&#123;</span><br><span class="line">            <span class="meta">@Result</span>(property = <span class="string">"createTime"</span>, column = <span class="string">"create_time"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function">User <span class="title">findById</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert</span>(<span class="string">"insert into user(username,password,create_time) values(#&#123;username&#125;,#&#123;password&#125;,#&#123;createTime&#125;)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update</span>(<span class="string">"update user set username=#&#123;username&#125;,password=#&#123;password&#125; where id=#&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Delete</span>(<span class="string">"delete from user where id=#&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>@Result</code>注解用于修饰返回结果集，若Entity和数据表字段不一致可以用其修饰</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>创建测试类 <code>/mapper/UserMapperAnoTest.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMapperAnoTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;User&gt; list = userMapper.findAll();</span><br><span class="line">        list.forEach(user -&gt; &#123;</span><br><span class="line">            logger.info(<span class="string">"user=&#123;&#125;"</span>, user);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindById</span><span class="params">()</span></span>&#123;</span><br><span class="line">        logger.info(<span class="string">"user=&#123;&#125;"</span>, userMapper.findById(<span class="number">1L</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSave</span><span class="params">()</span></span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUsername(<span class="string">"测试"</span>);</span><br><span class="line">        user.setPassword(<span class="string">"123"</span>);</span><br><span class="line">        user.setCreateTime(<span class="keyword">new</span> Date());</span><br><span class="line">        userMapper.save(user);</span><br><span class="line">        testFindAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(<span class="number">4L</span>);</span><br><span class="line">        user.setUsername(<span class="string">"测试呀"</span>);</span><br><span class="line">        userMapper.update(user);</span><br><span class="line">        testFindAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userMapper.delete(<span class="number">3L</span>);</span><br><span class="line">        testFindAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结"><a href="#结" class="headerlink" title="结"></a>结</h2><p>以上是常用CRUD操作的Mybatis注解版实现，对于基本的操作，使用注解确实比传统的XML简单好多，虽然也是SQL写在注解中，但是感觉比JPA的方式要简便一些（个人理解）。</p>
<h1 id="XML版"><a href="#XML版" class="headerlink" title="XML版"></a>XML版</h1><p>使用Mybatis的XML开发方式应该是我们比较熟悉的，和注解版最大的不同就是Dao层，XML版会自动根据Dao层接口的方法名自动映射到XML中同名<code>id</code>对应的SQL。</p>
<h2 id="修改application-yml"><a href="#修改application-yml" class="headerlink" title="修改application.yml"></a>修改application.yml</h2><p>添加如下Mybatis配置属性</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#mybatis配置</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line"><span class="attr">  mapper-locations:</span> <span class="attr">classpath:mapper/**/*.xml</span></span><br><span class="line"><span class="attr">  type-aliases-package:</span> <span class="string">cn.tycoding.entity</span></span><br><span class="line"><span class="attr">  configuration:</span></span><br><span class="line">    <span class="comment"># 使用jdbc的getGeneratedKeys 可以获取数据库自增主键值</span></span><br><span class="line"><span class="attr">    use-generated-keys:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 开启驼峰命名转换，如：Table(create_time) -&gt; Entity(createTime)。不需要我们关心怎么进行字段匹配，mybatis会自动识别`大写字母与下划线`</span></span><br><span class="line"><span class="attr">    map-underscore-to-camel-case:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="CRUD-1"><a href="#CRUD-1" class="headerlink" title="CRUD"></a>CRUD</h2><p>创建interface <code>UserMapperXML.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapperXML</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">User <span class="title">findById</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>resources/</code>下创建<code>/mapper/UserMapperXML.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"cn.tycoding.mapper.UserMapperXML"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAll"</span> <span class="attr">resultType</span>=<span class="string">"cn.tycoding.entity.User"</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findById"</span> <span class="attr">resultType</span>=<span class="string">"cn.tycoding.entity.User"</span>&gt;</span></span><br><span class="line">        select * from user where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"save"</span> <span class="attr">parameterType</span>=<span class="string">"cn.tycoding.entity.User"</span>&gt;</span></span><br><span class="line">        insert into user(username,password,create_time) values(#&#123;username&#125;,#&#123;password&#125;,#&#123;createTime&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"update"</span> <span class="attr">parameterType</span>=<span class="string">"cn.tycoding.entity.User"</span>&gt;</span></span><br><span class="line">        update user set username=#&#123;username&#125;,password=#&#123;password&#125; where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"delete"</span> <span class="attr">parameterType</span>=<span class="string">"long"</span>&gt;</span></span><br><span class="line">        delete from user where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h2><p>创建测试类<code>UserMapperXMLTest.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMapperXMLTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapperXML userMapperXML;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;User&gt; list = userMapperXML.findAll();</span><br><span class="line">        list.forEach(user -&gt; &#123;</span><br><span class="line">            logger.info(<span class="string">"user=&#123;&#125;"</span>, user);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindById</span><span class="params">()</span></span>&#123;</span><br><span class="line">        logger.info(<span class="string">"user=&#123;&#125;"</span>, userMapperXML.findById(<span class="number">1L</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSave</span><span class="params">()</span></span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUsername(<span class="string">"测试"</span>);</span><br><span class="line">        user.setPassword(<span class="string">"123"</span>);</span><br><span class="line">        user.setCreateTime(<span class="keyword">new</span> Date());</span><br><span class="line">        userMapperXML.save(user);</span><br><span class="line">        testFindAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(<span class="number">4L</span>);</span><br><span class="line">        user.setUsername(<span class="string">"测试呀"</span>);</span><br><span class="line">        userMapperXML.update(user);</span><br><span class="line">        testFindAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userMapperXML.delete(<span class="number">3L</span>);</span><br><span class="line">        testFindAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="结-1"><a href="#结-1" class="headerlink" title="结"></a>结</h1><p>练习了Mybatis注解版和XML版开发模式，更觉得两者配合使用最好，简单的CRUD操作使用注解完全可以实现；复杂的查询，比如Mybatis的动态SQL特性在注解中应该很难体现，而在XML中就很容易实现了。</p>
<br>

<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <categories>
        <category>spring-boot</category>
      </categories>
      <tags>
        <tag>spring-boot</tag>
      </tags>
  </entry>
  <entry>
    <title>（三）Spring Boot 整合 JPA</title>
    <url>/2019/02/26/boot/spring-boot-jpa/</url>
    <content><![CDATA[<h1 id="spring-boot-整合-JPA"><a href="#spring-boot-整合-JPA" class="headerlink" title="spring-boot 整合 JPA"></a>spring-boot 整合 JPA</h1><p>:tada: :tada: :tada: <strong>这里有丰富的 Spring 框架学习案例</strong></p>
<p><strong>仓库地址：<a href="https://github.com/TyCoding/spring-learn" target="_blank" rel="noopener">spring-learn</a></strong><br><strong>欢迎star、fork，给作者一些鼓励</strong></p>
<blockquote>
<p>Jpa(Java Persistence API)是一套规范，而Hibernate是基于Jpa实现的一套产品</p>
</blockquote>
<a id="more"></a>

<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><p>首先你需要创建一个Maven项目，并且在<code>pom.xml</code>中引入JPA依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h2><p>由于使用了spring-boot开发，spring-boot能够减轻我们在XML文件中繁琐的配置，因此在spring-boot中配置JPA也格外简单</p>
<blockquote>
<p>修改<code>application.yml</code></p>
</blockquote>
<p>（注意：新创建的spring-boot项目（使用<code>start.spring.io</code>还是IDE），默认在<code>resources</code>目录下都会有<code>application.properties</code>这个文件，我这里只是把后缀名改了。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  datasource:</span></span><br><span class="line"><span class="attr">    url:</span> <span class="attr">jdbc:mysql://localhost:3306/springboot_jpa?characterEncoding=utf-8</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">    driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  jpa:</span></span><br><span class="line"><span class="attr">    show-sql:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    hibernate:</span></span><br><span class="line"><span class="attr">      dialect:</span> <span class="string">org.hibernate.dialect.MySQL5Dialect</span></span><br></pre></td></tr></table></figure>

<p>注意一点：<code>datasource</code>下的<code>url</code>数据库连接在<code>数据库名</code>后面一定要拼接<code>?characterEncoding=utf-8</code>，目的是避免调用JPA的方法存入数据库中的数据<strong>中文乱码</strong></p>
<h2 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h2><p>在上面已经说到，<code>jpa</code>是一套规范，而如<code>hibernate</code>仅是基于<code>jpa</code>的一套产品。可能大家在学习hibernate的时候就知道hibernate可以根据<code>Entity</code>属性自动创建数据库，当然JPA也是可以实现的。</p>
<blockquote>
<p>若要使用JPA自动生成表结构，修改<code>application.yml</code></p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  datasource:</span></span><br><span class="line"><span class="attr">    url:</span> <span class="attr">jdbc:mysql://127.0.0.1/springboot_jpa?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=UTC&amp;useSSL=true</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">    driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  jpa:</span></span><br><span class="line"><span class="attr">    show-sql:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    hibernate:</span></span><br><span class="line"><span class="attr">      dialect:</span> <span class="string">org.hibernate.dialect.MySQL5Dialect</span></span><br><span class="line"><span class="attr">      ddl-auto:</span> <span class="string">update</span></span><br></pre></td></tr></table></figure>

<p>注意区分<code>.properties</code>文件的配置，在<code>application.,properties</code>中应该如下配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.datasource.url=jdbc:mysql://127.0.0.1/springboot_jpa?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=UTC&amp;useSSL=true</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=root</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line"></span><br><span class="line">spring.jpa.properties.hibernate.hbm2ddl.auto=update</span><br><span class="line">spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialect</span><br><span class="line">spring.jpa.show-sql= true</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>，JPA不能自动帮你创建数据库，你要手动创建。</p>
<p>当然，如果你想手动创建表结构，就不要配置<code>auto=update</code>，并且下面有关的一些注解也就不用加了。</p>
<h3 id="自动生成表结构"><a href="#自动生成表结构" class="headerlink" title="自动生成表结构"></a>自动生成表结构</h3><p>若要使用Spring-data-jpa自动生成表结构，需要：</p>
<blockquote>
<p>1.修改配置文件（已完成了</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.jpa.properties.hibernate.hbm2ddl.auto=update</span><br></pre></td></tr></table></figure>

<p><code>update</code>: 如果修改了Entity，重启项目，表结构会自动更新</p>
<blockquote>
<p>2.创建Entity</p>
</blockquote>
<p>测试用例，我们创建<code>Demo.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"tb_demo"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"create_time"</span>)</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">annotation</th>
<th align="left">tips</th>
</tr>
</thead>
<tbody><tr>
<td align="left">@Data</td>
<td align="left">Lomback的注解，需要导入lomback依赖，用于自动生成getter/setter/toString</td>
</tr>
<tr>
<td align="left">@Entity</td>
<td align="left">来自<code>javax.persistence.*</code>，标记改类为Entity</td>
</tr>
<tr>
<td align="left">@Table</td>
<td align="left">来自<code>javax.persistence.*</code>，该Entity对应的表名，<code>name</code>指定了表名，默认为当前Entity名的小写</td>
</tr>
<tr>
<td align="left">@Id</td>
<td align="left">来自<code>javax.persistence.*</code>，标记该字段为数据表主键Id</td>
</tr>
<tr>
<td align="left">@GeneratedValue</td>
<td align="left">来自<code>javax.persistence.*</code>，标记该主键生成策略，默认递增，不配置该注解，insert数据必须手动指定id值</td>
</tr>
<tr>
<td align="left">@Column</td>
<td align="left">来自<code>javax.persistence.*</code>，标记该字段的具体数据库表字段名，<code>name</code>具体字段名</td>
</tr>
</tbody></table>
<p>如果你想要Entity中的某个属性不被识别为表字段，可以用<code>@Transient</code>注解标记。</p>
<p>如上已经完成了配置，下面直接启动项目的<code>main</code>方法，数据表<code>demo</code>会自动生成，</p>
<p><img src="/2019/02/26/boot/spring-boot-jpa/1.png" alt></p>
<p>发现莫名其妙的创建了一个表：<code>hibernate_sequence</code></p>
<p><img src="/2019/02/26/boot/spring-boot-jpa/2.png" alt></p>
<p>避免自动创建<code>hibernate_sequence</code>表，修改之前的<code>Test.entity</code>主键自增策略:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line"><span class="keyword">private</span> Long id;</span><br></pre></td></tr></table></figure>

<h3 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h3><p><strong>But</strong>，细心的你会发现，Entity中定义的字段顺序和JPA生成的表字段顺序不同，JPA生成的表中按照字段首字母排序：</p>
<p><img src="/2019/02/26/boot/spring-boot-jpa/7.png" alt></p>
<p>所以，坑，暂时没有解决，应该是Hibernate自身问题。</p>
<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><h2 id="创建User-java"><a href="#创建User-java" class="headerlink" title="创建User.java"></a>创建User.java</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"create_time"</span>)</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"update_time"</span>)</span><br><span class="line">    <span class="keyword">private</span> Date updateTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Lob</span></span><br><span class="line">    <span class="meta">@Basic</span>(fetch = FetchType.LAZY)</span><br><span class="line">    <span class="meta">@Column</span>(columnDefinition = <span class="string">"text"</span>)</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">annotation</th>
<th align="left">tips</th>
</tr>
</thead>
<tbody><tr>
<td align="left">@Column(name = “create_time”)</td>
<td align="left">定义此字段的字段名是<code>create_time</code>，<code>java.util.Date</code>类型默认生成<code>datetime</code>类型(mysql)</td>
</tr>
<tr>
<td align="left">@Lob</td>
<td align="left">来自<code>javax.persistence.*</code>，被标记的字段根据<code>get</code>方法返回值不同，自动进行Clob和Blob类型转换，目的是生成<code>text</code>这种大数据</td>
</tr>
<tr>
<td align="left">@Basic(fetch = FetchType.LAZY)</td>
<td align="left">通常和<code>@Lob</code>一起使用，因为<code>@Lob</code>标记的字段数据量大，用<code>@Basic</code>规定懒加载，提高访问速度</td>
</tr>
<tr>
<td align="left">@Column(columnDefinition = “text”)</td>
<td align="left">规定具体生成的表字段类型为<code>text</code></td>
</tr>
</tbody></table>
<p>如果想要实现类似：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">`create_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>, </span><br><span class="line"><span class="string">`update_time`</span> <span class="built_in">timestamp</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br></pre></td></tr></table></figure>

<p>这种字段定义的实现：<code>create_time</code>根据自动封装创建时间、<code>update_time</code>自动更新为最新操作的时间。需要进行如下操作：</p>
<blockquote>
<p>1.修改Entity</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CreatedDate</span></span><br><span class="line"><span class="meta">@Column</span>(name = <span class="string">"create_time"</span>)</span><br><span class="line"><span class="keyword">private</span> Date createTime;</span><br><span class="line"></span><br><span class="line"><span class="meta">@LastModifiedDate</span></span><br><span class="line"><span class="meta">@Column</span>(name = <span class="string">"update_time"</span>)</span><br><span class="line"><span class="keyword">private</span> Date updateTime;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>2.在Entity类上添加注解</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EntityListeners</span>(AuditingEntityListener.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>3.在spring-boot启动类上添加注解：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableJpaAuditing</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootJpaApplication</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>以上3步，虽然生成的的<code>create_time</code>和<code>update_time</code>仍是简单的<code>datetime</code>限定，但是使用JPA进行create、update的时候该字段会自动添加、更新。</p>
<h2 id="创建UserDao-java"><a href="#创建UserDao-java" class="headerlink" title="创建UserDao.java"></a>创建UserDao.java</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;  &#125;</span><br></pre></td></tr></table></figure>

<p>可能你会见到有的案例中<code>extends CrudRepository&lt;T, ID&gt;</code>等，其实都是可以的，翻看源码就知道，继承<code>JpaRepository</code>也可以使用<code>CrudRepository</code>的方法：</p>
<p><img src="/2019/02/26/boot/spring-boot-jpa/3.png" alt></p>
<p><strong>注意</strong><code>JpaRepository&lt;T, ID&gt;</code>，要指定泛型类型，否则Spring注入这个Bean的时候发现该Bean泛型类型不定而注入失败。</p>
<p>下面我们看一下<code>JpaRepository</code>中提供的方法：</p>
<p><img src="/2019/02/26/boot/spring-boot-jpa/4.png" alt></p>
<p><code>CrudRepository</code>:</p>
<p><img src="/2019/02/26/boot/spring-boot-jpa/5.png" alt></p>
<p>顾名思义，看了方法名应该就知道这个方法的具体作用了。</p>
<h2 id="创建UserDaoTest-java"><a href="#创建UserDaoTest-java" class="headerlink" title="创建UserDaoTest.java"></a>创建UserDaoTest.java</h2><p>使用Idea的话，在<code>UserDao.java</code>接口名前按<code>Alt + Enter</code>键(mac)，快速生成测试类<code>UserDaoTest.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h1><h2 id="findAll"><a href="#findAll" class="headerlink" title="findAll"></a>findAll</h2><p>先插入一条记录：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`user`</span><span class="keyword">values</span>(<span class="number">1</span>, <span class="string">'2019-01-19 00:00:00'</span>, <span class="string">'测试用例'</span>, <span class="string">'123'</span>, <span class="string">'2019-01-18 00:00:00'</span>, <span class="string">'涂陌'</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询所有</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;User&gt; list = userDao.findAll();</span><br><span class="line">    list.forEach(user -&gt; &#123;</span><br><span class="line">        logger.info(<span class="string">"user=&#123;&#125;"</span>, user);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>list.forEach(i -&gt; {})</code>是JDK8新特性</p>
<p><img src="/2019/02/26/boot/spring-boot-jpa/8.png" alt></p>
<h2 id="findById"><a href="#findById" class="headerlink" title="findById"></a>findById</h2><p>根据<code>Id</code>主键查询：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据ID查询</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindById</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = userDao.findById(<span class="number">1L</span>).get();</span><br><span class="line">    logger.info(<span class="string">"user=&#123;&#125;"</span>, user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2019/02/26/boot/spring-boot-jpa/9.png" alt></p>
<p><code>findById</code>得到一个<code>Optional</code>对象，通过<code>.get()</code>可获取到其中封装的<code>User</code>对象。</p>
<p><strong>But</strong></p>
<p>还要一个方法：</p>
<p><img src="/2019/02/26/boot/spring-boot-jpa/10.png" alt></p>
<p>看似<code>getOne()</code>刚好返回一个<code>User</code>对象，但是查询<code>getOne()</code>方法的实现：</p>
<p><img src="/2019/02/26/boot/spring-boot-jpa/11.png" alt></p>
<p>可以看到这个方法其实返回一个<code>reference</code>代理对象，并不是真正的<code>User</code>对象，所以，如果你调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User user = userDao.getOne(<span class="number">1L</span>)</span><br></pre></td></tr></table></figure>

<p>会报错：<code>org.hibernate.LazyInitializationException - no Session</code></p>
<h2 id="动态查询"><a href="#动态查询" class="headerlink" title="动态查询"></a>动态查询</h2><p>很多时候需要动态拼接查询条件，实现条件查询，那么</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动态查询。根据某个字段查询</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindByExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    Example&lt;User&gt; example = Example.of(user);</span><br><span class="line">    user.setUsername(<span class="string">"tycoding"</span>);</span><br><span class="line">    List&lt;User&gt; list = userDao.findAll(example);</span><br><span class="line">    list.forEach(u -&gt; &#123;</span><br><span class="line">        logger.info(<span class="string">"user=&#123;&#125;"</span>, u);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可通过构建<code>Example</code>进行查询条件的限定</p>
<h2 id="Save"><a href="#Save" class="headerlink" title="Save"></a>Save</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSave</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setUsername(<span class="string">"测试"</span>);</span><br><span class="line">    user.setPassword(<span class="string">"测试"</span>);</span><br><span class="line">    userDao.save(user);</span><br><span class="line">    List&lt;User&gt; list = userDao.findAll();</span><br><span class="line">    list.forEach(u -&gt; &#123;</span><br><span class="line">        logger.info(<span class="string">"user=&#123;&#125;"</span>, u);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setId(<span class="number">1L</span>);</span><br><span class="line">    user.setUsername(<span class="string">"涂陌呀"</span>);</span><br><span class="line">    userDao.save(user);</span><br><span class="line">    logger.info(<span class="string">"user=&#123;&#125;"</span>, userDao.findById(user.getId()).get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，进行更新和保存的操作都可以调用<code>save()</code>操作，并且，如果<code>Id</code>字段有值，那么jpa就默认识别为更新操作，否则为新增操作。</p>
<h2 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setId(<span class="number">4L</span>);</span><br><span class="line">    userDao.delete(user);</span><br><span class="line">    <span class="comment">//userDao.deleteById(4L);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="自定义简单查询"><a href="#自定义简单查询" class="headerlink" title="自定义简单查询"></a>自定义简单查询</h1><p>自定义简单查询就是根据方法名自动生成SQL。前面是用JPA内置的方法进行简单的CRUD，下面可以自定义方法名实现自定义SQL：</p>
<p>主要语法是：<code>findByXX</code>,<code>readByXX</code>,<code>queryByXX</code>,<code>countByXX</code>。<code>XX</code>代表属性名，如：</p>
<p><img src="/2019/02/26/boot/spring-boot-jpa/12.png" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">User <span class="title">findByUsername</span><span class="params">(String username)</span></span>;</span><br></pre></td></tr></table></figure>

<p>或者加一些关键字：</p>
<p><img src="/2019/02/26/boot/spring-boot-jpa/13.png" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">User <span class="title">findByUsernameOrPassword</span><span class="params">(String username, String password)</span></span>;</span><br></pre></td></tr></table></figure>

<p>基本上SQL体系中的关键字在JPA上都有对应的，具体的关键字和使用方法生成的SQL如下表：</p>
<table>
<thead>
<tr>
<th align="left">Keyword</th>
<th align="left">Sample</th>
<th align="left">JPQL snippet</th>
</tr>
</thead>
<tbody><tr>
<td align="left">And</td>
<td align="left">findByLastnameAndFirstname</td>
<td align="left">… where x.lastname = ?1 and x.firstname = ?2</td>
</tr>
<tr>
<td align="left">Or</td>
<td align="left">findByLastnameOrFirstname</td>
<td align="left">… where x.lastname = ?1 or x.firstname = ?2</td>
</tr>
<tr>
<td align="left">Is,Equals</td>
<td align="left">findByFirstnameIs,findByFirstnameEquals</td>
<td align="left">… where x.firstname = ?1</td>
</tr>
<tr>
<td align="left">Between</td>
<td align="left">findByStartDateBetween</td>
<td align="left">… where x.startDate between ?1 and ?2</td>
</tr>
<tr>
<td align="left">LessThan</td>
<td align="left">findByAgeLessThan</td>
<td align="left">… where x.age &lt; ?1</td>
</tr>
<tr>
<td align="left">LessThanEqual</td>
<td align="left">findByAgeLessThanEqual</td>
<td align="left">… where x.age ⇐ ?1</td>
</tr>
<tr>
<td align="left">GreaterThan</td>
<td align="left">findByAgeGreaterThan</td>
<td align="left">… where x.age &gt; ?1</td>
</tr>
<tr>
<td align="left">GreaterThanEqual</td>
<td align="left">findByAgeGreaterThanEqual</td>
<td align="left">… where x.age &gt;= ?1</td>
</tr>
<tr>
<td align="left">After</td>
<td align="left">findByStartDateAfter</td>
<td align="left">… where x.startDate &gt; ?1</td>
</tr>
<tr>
<td align="left">Before</td>
<td align="left">findByStartDateBefore</td>
<td align="left">… where x.startDate &lt; ?1</td>
</tr>
<tr>
<td align="left">IsNull</td>
<td align="left">findByAgeIsNull</td>
<td align="left">… where x.age is null</td>
</tr>
<tr>
<td align="left">IsNotNull,NotNull</td>
<td align="left">findByAge(Is)NotNull</td>
<td align="left">… where x.age not null</td>
</tr>
<tr>
<td align="left">Like</td>
<td align="left">findByFirstnameLike</td>
<td align="left">… where x.firstname like ?1</td>
</tr>
<tr>
<td align="left">NotLike</td>
<td align="left">findByFirstnameNotLike</td>
<td align="left">… where x.firstname not like ?1</td>
</tr>
<tr>
<td align="left">StartingWith</td>
<td align="left">findByFirstnameStartingWith</td>
<td align="left">… where x.firstname like ?1 (parameter bound with appended %)</td>
</tr>
<tr>
<td align="left">EndingWith</td>
<td align="left">findByFirstnameEndingWith</td>
<td align="left">… where x.firstname like ?1 (parameter bound with prepended %)</td>
</tr>
<tr>
<td align="left">Containing</td>
<td align="left">findByFirstnameContaining</td>
<td align="left">… where x.firstname like ?1 (parameter bound wrapped in %)</td>
</tr>
<tr>
<td align="left">OrderBy</td>
<td align="left">findByAgeOrderByLastnameDesc</td>
<td align="left">… where x.age = ?1 order by x.lastname desc</td>
</tr>
<tr>
<td align="left">Not</td>
<td align="left">findByLastnameNot</td>
<td align="left">… where x.lastname &lt;&gt; ?1</td>
</tr>
<tr>
<td align="left">In</td>
<td align="left">findByAgeIn(Collection ages)</td>
<td align="left">… where x.age in ?1</td>
</tr>
<tr>
<td align="left">NotIn</td>
<td align="left">findByAgeNotIn(Collection age)</td>
<td align="left">… where x.age not in ?1</td>
</tr>
<tr>
<td align="left">TRUE</td>
<td align="left">findByActiveTrue()</td>
<td align="left">… where x.active = true</td>
</tr>
<tr>
<td align="left">FALSE</td>
<td align="left">findByActiveFalse()</td>
<td align="left">… where x.active = false</td>
</tr>
<tr>
<td align="left">IgnoreCase</td>
<td align="left">findByFirstnameIgnoreCase</td>
<td align="left">… where UPPER(x.firstame) = UPPER(?1)</td>
</tr>
</tbody></table>
<h1 id="复杂查询"><a href="#复杂查询" class="headerlink" title="复杂查询"></a>复杂查询</h1><h2 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h2><p>之前我们可能常用<code>Mybatis</code> + <code>PageHelper</code> 实现后端分页效果，而在JPA中，它本身提供了分页查询的方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindByPage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pageCode = <span class="number">1</span>; <span class="comment">//当前页</span></span><br><span class="line">    <span class="keyword">int</span> pageSize = <span class="number">3</span>; <span class="comment">//每页显示10条记录</span></span><br><span class="line">    Sort sort = <span class="keyword">new</span> Sort(Sort.Direction.ASC, <span class="string">"id"</span>);</span><br><span class="line">    Pageable pageable = <span class="keyword">new</span> PageRequest(pageCode, pageSize, sort);</span><br><span class="line">    Page&lt;User&gt; page = userDao.findAll(pageable);</span><br><span class="line">    logger.info(<span class="string">"总记录数=&#123;&#125;"</span>, page.getTotalElements());</span><br><span class="line">    logger.info(<span class="string">"总页数=&#123;&#125;"</span>, page.getTotalPages());</span><br><span class="line">    logger.info(<span class="string">"记录=&#123;&#125;"</span>, page.getContent());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>，之前在用<code>PageHelper</code>的时候，默认第一页是<code>1</code>，这样查询出来就是数据库第一页的内容。<strong>But</strong>，使用了JPA发现它的页码是从<code>0</code>开始的，也就是说0=第一页、1=第二页…</p>
<p>这和PageHelper差别还是蛮大的，若：数据库一共两条记录，你查询<code>new PageRequest(1,3)</code>得到的<code>content</code>是<code>[]</code></p>
<h2 id="自定义SQL查询"><a href="#自定义SQL查询" class="headerlink" title="自定义SQL查询"></a>自定义SQL查询</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindByPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = userDao.findByPassword(<span class="string">"123"</span>);</span><br><span class="line">    logger.info(<span class="string">"user=&#123;&#125;"</span>, user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>UserDao.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"select u from User u where u.password = ?1"</span>)</span><br><span class="line">    <span class="function">User <span class="title">findByPassword</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用自定义SQL查询用<code>@Query(sql)</code>即可，如果涉及更新、添加、删除（事务）操作需要再添加<code>@Modifying</code>注解。也可以根据需要添加<code>@Transactional</code>注解对事务的支持和、查询超时的设置等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDeleteByPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    userDao.deleteByPassword(<span class="string">"123"</span>);</span><br><span class="line">    User user = userDao.findByPassword(<span class="string">"123"</span>);</span><br><span class="line">    logger.info(<span class="string">"user=&#123;&#125;"</span>, user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>UserDao.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"select u from User u where u.password = ?1"</span>)</span><br><span class="line">    <span class="meta">@Transactional</span>(timeout = <span class="number">10</span>)</span><br><span class="line">    <span class="function">User <span class="title">findByPassword</span><span class="params">(String s)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"delete from User where password = ?1"</span>)</span><br><span class="line">    <span class="meta">@Modifying</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteByPassword</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><p>实在想吐槽，JPA这样对多表查询的支持太差了，<strong>多表查询</strong>就必须手动写SQL，然后放在<code>@Query</code>注解中，这样SQL真的很难看，而且需要额外遵循JPA的规范。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>JPA官方规定数据表必须有主键（id），而之前权限管理项目中一些关联表（用户角色关联表）是不需要主键的，但如果使用JPA就必须配置主键，不管你用不用。</p>
<p><a href="https://en.wikibooks.org/wiki/Java_Persistence/Identity_and_Sequencing#No_Primary_Key" target="_blank" rel="noopener"></a></p>
<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <categories>
        <category>spring-boot</category>
      </categories>
      <tags>
        <tag>spring-boot</tag>
      </tags>
  </entry>
  <entry>
    <title>（二）Spring Boot整合Thymeleaf</title>
    <url>/2019/02/26/boot/spring-boot-thymeleaf/</url>
    <content><![CDATA[<h1 id="Spring-Boot整合Thymeleaf"><a href="#Spring-Boot整合Thymeleaf" class="headerlink" title="Spring Boot整合Thymeleaf"></a>Spring Boot整合Thymeleaf</h1><p>:tada: :tada: :tada: <strong>这里有丰富的 Spring 框架学习案例</strong></p>
<p><strong>仓库地址：<a href="https://github.com/TyCoding/spring-learn" target="_blank" rel="noopener">spring-learn</a></strong><br><strong>欢迎star、fork，给作者一些鼓励</strong></p>
<p>Thymeleaf 是一个跟 Velocity、FreeMarker 类似的模板引擎，它可以完全替代 JSP 。也就是说JSP中的特性在Thymeleaf几乎都有对应的支持。Thymeleaf支持HTML原型，通过Thymeleaf特殊的标签可以基本实现JSP中动态数据的展示效果。</p>
<p><strong>写在前面</strong></p>
<p>如果你看过我仓库中的web项目应该会发现，基本前端都是完全依赖Vue.js+ElementUI，这和Jquery有很大区别，通常来讲使用Vue.js就应该用Vue的组件(.vue文件)开发，而在HTML页面直接引入Vue.js就要舍弃很多Vue的特性。而在今天学习的Thymeleaf中若使用了<code>&lt;iframe&gt;</code>布局就完全不能使用Vue.js了。</p>
<a id="more"></a>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><blockquote>
<p>使用Thymeleaf受限要引入其依赖</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Thymeleaf 支持渲染HTML，因此通常我们使用的页面模板也就是HTML，同时它需要遵循一定的规则：</p>
<ol>
<li><p>比如在spring boot项目中，通常我们将Thymeleaf渲染的页面放在<code>resources/templates</code>目录下，这样Thymeleaf会默认识别。</p>
</li>
<li><p>若想要在HTML页面中使用Thymeleaf，需要修改<code>&lt;html lang=&quot;en&quot;&gt;</code>为<code>&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;</code></p>
</li>
<li><p>在spring boot项目中<code>resources/static</code>目录下的文件可通过浏览器直接访问，而<code>resources/templates</code>下的HTML不能通过浏览器直接访问，而需要<code>Spring Mvc</code>这样的框架映射到那个页面地址。</p>
</li>
</ol>
<blockquote>
<p>修改<code>application.properties</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.thymeleaf.mode = LEGACYHTML5</span><br><span class="line">spring.thymeleaf.encoding=UTF-8</span><br><span class="line">spring.thymeleaf.content-type=text/html</span><br><span class="line">spring.thymeleaf.suffix=.html</span><br><span class="line">#开发时关闭缓存,不然没法看到实时页面</span><br><span class="line">spring.thymeleaf.cache=false</span><br></pre></td></tr></table></figure>

<p>其中<code>spring.thymeleaf.mode = LEGACYHTML5</code>配置thymeleaf的模式，不要使用<code>spring.thymeleaf.mode = HTML5</code>，因为严格遵循HTML5规范会对非严格的报错，例如<code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code>，<code>&lt;meta&gt;</code>标签没有结束<code>&lt;meta /&gt;</code>就会报错。</p>
<h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><blockquote>
<p>在<code>main/java</code>目录下新建<code>RouterController.java</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RouterController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/index"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个<code>return &quot;index&quot;</code>中<code>index</code>是<code>templates</code>根目录下的<code>index.html</code>，如果是<code>templates/common/main.html</code>页面，就应该<code>return &quot;/common/main.html&quot;</code></p>
<blockquote>
<p>在<code>main/resources/templates</code>目录下新建<code>index.html</code></p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Index<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2019/02/26/boot/spring-boot-thymeleaf/1.png" alt></p>
<blockquote>
<p>执行<code>main/java/ThymeleafApplication.java</code>启动类，用浏览器访问<code>localhost:8080/index</code></p>
</blockquote>
<p><img src="/2019/02/26/boot/spring-boot-thymeleaf/2.png" alt></p>
<h1 id="常用表达式"><a href="#常用表达式" class="headerlink" title="常用表达式"></a>常用表达式</h1><h2 id="变量表达式"><a href="#变量表达式" class="headerlink" title="变量表达式"></a>变量表达式</h2><p>变量表达式级即OGNL表达式或Spring EL表达式（在Spring术语中也叫做model attributes），例如:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$&#123;user.username&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1.修改<code>RouterController.java</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RouterController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/index"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">"demo"</span>, <span class="string">"测试"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>2.修改<code>index.html</code></p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Index<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line">`$&#123;...&#125;`表达式：<span class="tag">&lt;<span class="name">b</span> <span class="attr">th:text</span>=<span class="string">"$&#123;demo&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2019/02/26/boot/spring-boot-thymeleaf/3.png" alt></p>
<h2 id="选择-号表达式"><a href="#选择-号表达式" class="headerlink" title="选择*号表达式"></a>选择*号表达式</h2><p>如果<code>model.addAttribute()</code>的是一个对象而不是字符串，就可以用<code>*</code>表达式分别获取<code>model</code>对象中的元素，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RouterController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/index"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">"demo"</span>, <span class="string">"测试"</span>);</span><br><span class="line">        </span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUsername(<span class="string">"tycoding"</span>);</span><br><span class="line">        user.setPassword(<span class="string">"123"</span>);</span><br><span class="line">        model.addAttribute(<span class="string">"user"</span>, user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HTML页面获取<code>user</code>对象中的元素：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">`*&#123;...&#125;`表达式：</span><br><span class="line"><span class="tag">&lt;<span class="name">b</span> <span class="attr">th:object</span>=<span class="string">"$&#123;user&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"*&#123;username&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"*&#123;password&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<p>使用<code>*{...}</code>表达式必须保证<code>*{}</code>在<code>th:object=&quot;${...}</code>标签的包裹下，且<code>*{...}</code>必须是<code>${...}</code>下的一个元素，否则报错。例如这样写是获取不到元素的：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">`*&#123;...&#125;`表达式：</span><br><span class="line"><span class="tag">&lt;<span class="name">b</span> <span class="attr">th:object</span>=<span class="string">"$&#123;user&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"*&#123;username&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"*&#123;password&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line">错误实例：<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"*&#123;username&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>另外</strong></p>
<p>如果页面需要不在<code>th:object</code>包裹下获取对象中的元素，可以使用如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.username&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="URL表达式"><a href="#URL表达式" class="headerlink" title="URL表达式"></a>URL表达式</h2><p>例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">th:src</span>=<span class="string">"@&#123;/css/base.css&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>会自动引入<code>resources/statis/css/</code>下的<code>base.css</code>文件，这和JSP页面中使用:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"$&#123;pageContext.request.contextPath&#125;/css/base.css"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>是一个道理。</p>
<p>同理：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">th:href</span>=<span class="string">"@&#123;/css/base.css&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="表达式支持的语法"><a href="#表达式支持的语法" class="headerlink" title="表达式支持的语法"></a>表达式支持的语法</h2><p><strong>字面（Literals）</strong></p>
<ul>
<li>文本文字（Text literals）: ‘one text’, ‘Another one!’,…</li>
<li>数字文本（Number literals）: 0, 34, 3.0, 12.3,…</li>
<li>布尔文本（Boolean literals）: true, false</li>
<li>空（Null literal）: null</li>
<li>文字标记（Literal tokens）: one, sometext, main,…</li>
</ul>
<p><strong>文本操作（Text operations）</strong></p>
<ul>
<li>字符串连接(String concatenation): +</li>
<li>文本替换（Literal substitutions）: |The name is ${name}|</li>
</ul>
<p><strong>算术运算（Arithmetic operations）</strong></p>
<ul>
<li>二元运算符（Binary operators）: +, -, *, /, %</li>
<li>减号（单目运算符）Minus sign (unary operator): -</li>
</ul>
<p><strong>布尔操作（Boolean operations）</strong></p>
<ul>
<li>二元运算符（Binary operators）:and, or</li>
<li>布尔否定（一元运算符）Boolean negation (unary operator):!, not</li>
</ul>
<p><strong>比较和等价(Comparisons and equality)</strong></p>
<ul>
<li>比较（Comparators）: &gt;, &lt;, &gt;=, &lt;= (gt, lt, ge, le)</li>
<li>等值运算符（Equality operators）:==, != (eq, ne)</li>
</ul>
<p><strong>条件运算符（Conditional operators）</strong></p>
<ul>
<li>If-then: (if) ? (then)</li>
<li>If-then-else: (if) ? (then) : (else)</li>
<li>Default: (value) ?: (defaultvalue)</li>
</ul>
<p>所有这些特征可以被组合并嵌套：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;User is of type &apos; + ($&#123;user.isAdmin()&#125; ? &apos;Administrator&apos; : ($&#123;user.type&#125; ?: &apos;Unknown&apos;))</span><br></pre></td></tr></table></figure>

<h2 id="常用的th标签"><a href="#常用的th标签" class="headerlink" title="常用的th标签"></a>常用的th标签</h2><p><img src="/2019/02/26/boot/spring-boot-thymeleaf/4.png" alt></p>
<h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><h2 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>字符串拼接<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"'hello ' + $&#123;user.username&#125; + '!'"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">简洁用法：<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"|hello $&#123;user.username&#125;!|"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="if-unless条件判断"><a href="#if-unless条件判断" class="headerlink" title="if/unless条件判断"></a>if/unless条件判断</h2><p><code>th:if</code> 条件成立时显示</p>
<p><code>th:unless</code> 条件不成立时显示</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>if/unless条件判断<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">th:if</span>=<span class="string">"$&#123;user.username == 'tycoding'&#125;"</span>&gt;</span>tycoding<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">th:unless</span>=<span class="string">"$&#123;user.username == 'admin'&#125;"</span>&gt;</span>tycoding<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">"循环1"</span>);</span><br><span class="line">list.add(<span class="string">"循环2"</span>);</span><br><span class="line">list.add(<span class="string">"循环3"</span>);</span><br><span class="line">model.addAttribute(<span class="string">"list"</span>, list);</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>for循环<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">th:each</span>=<span class="string">"item,property : $&#123;list&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">th:text</span>=<span class="string">"$&#123;property.index&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">th:text</span>=<span class="string">"$&#123;item&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>property</code>称作状态变量，属性有：</p>
<ul>
<li>index:当前迭代对象的index（从0开始计算）</li>
<li>count: 当前迭代对象的index(从1开始计算)</li>
<li>size:被迭代对象的大小</li>
<li>current:当前迭代变量</li>
<li>even/odd:布尔值，当前循环是否是偶数/奇数（从0开始计算）</li>
<li>first:布尔值，当前循环是否是第一个</li>
<li>last:布尔值，当前循环是否是最后一个</li>
</ul>
<h2 id="内联JS"><a href="#内联JS" class="headerlink" title="内联JS"></a>内联JS</h2><p>有时，我们需要在<code>javascript</code>中使用<code>model</code>中的元素，而在<code>javascript</code>中无法用<code>th</code>标签，那么就可以这样使用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>内联JS<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">th:inline</span>=<span class="string">"javascript"</span>&gt;</span></span><br><span class="line">    var username = [[$&#123;user.username&#125;]];</span><br><span class="line">    console.log(username);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用内联JS，要在<code>&lt;script&gt;</code>标签中使用<code>th:inline=&quot;javascript&quot;</code>。并且内联JS仅可以在当前HTML页面中获取到，在外置JS文件中是无法获取的。</p>
<h2 id="内嵌变量"><a href="#内嵌变量" class="headerlink" title="内嵌变量"></a>内嵌变量</h2><p>为了模板更加易用，Thymeleaf还提供了一系列Utility对象（内置于Context中），可以通过#直接访问：</p>
<pre><code>dates ： java.util.Date的功能方法类。
calendars : 类似#dates，面向java.util.Calendar
numbers : 格式化数字的功能方法类
strings : 字符串对象的功能类，contains,startWiths,prepending/appending等等。
objects: 对objects的功能类操作。
bools: 对布尔值求值的功能方法。
arrays：对数组的功能类方法。
lists: 对lists功能类方法
sets
maps
…</code></pre><p>下面用一段代码来举例一些常用的方法：</p>
<p><strong>dates</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Format date with the specified pattern</span><br><span class="line"> * Also works with arrays, lists or sets</span><br><span class="line"> */</span><br><span class="line">$&#123;#dates.format(date, &apos;dd/MMM/yyyy HH:mm&apos;)&#125;</span><br><span class="line">$&#123;#dates.arrayFormat(datesArray, &apos;dd/MMM/yyyy HH:mm&apos;)&#125;</span><br><span class="line">$&#123;#dates.listFormat(datesList, &apos;dd/MMM/yyyy HH:mm&apos;)&#125;</span><br><span class="line">$&#123;#dates.setFormat(datesSet, &apos;dd/MMM/yyyy HH:mm&apos;)&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Create a date (java.util.Date) object for the current date and time</span><br><span class="line"> */</span><br><span class="line">$&#123;#dates.createNow()&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Create a date (java.util.Date) object for the current date (time set to 00:00)</span><br><span class="line"> */</span><br><span class="line">$&#123;#dates.createToday()&#125;</span><br></pre></td></tr></table></figure>

<p><strong>strings</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Check whether a String is empty (or null). Performs a trim() operation before check</span><br><span class="line"> * Also works with arrays, lists or sets</span><br><span class="line"> */</span><br><span class="line">$&#123;#strings.isEmpty(name)&#125;</span><br><span class="line">$&#123;#strings.arrayIsEmpty(nameArr)&#125;</span><br><span class="line">$&#123;#strings.listIsEmpty(nameList)&#125;</span><br><span class="line">$&#123;#strings.setIsEmpty(nameSet)&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Check whether a String starts or ends with a fragment</span><br><span class="line"> * Also works with arrays, lists or sets</span><br><span class="line"> */</span><br><span class="line">$&#123;#strings.startsWith(name,&apos;Don&apos;)&#125;                  // also array*, list* and set*</span><br><span class="line">$&#123;#strings.endsWith(name,endingFragment)&#125;           // also array*, list* and set*</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Compute length</span><br><span class="line"> * Also works with arrays, lists or sets</span><br><span class="line"> */</span><br><span class="line">$&#123;#strings.length(str)&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Null-safe comparison and concatenation</span><br><span class="line"> */</span><br><span class="line">$&#123;#strings.equals(str)&#125;</span><br><span class="line">$&#123;#strings.equalsIgnoreCase(str)&#125;</span><br><span class="line">$&#123;#strings.concat(str)&#125;</span><br><span class="line">$&#123;#strings.concatReplaceNulls(str)&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Random</span><br><span class="line"> */</span><br><span class="line">$&#123;#strings.randomAlphanumeric(count)&#125;</span><br></pre></td></tr></table></figure>

<h1 id="使用Thymeleaf布局"><a href="#使用Thymeleaf布局" class="headerlink" title="使用Thymeleaf布局"></a>使用Thymeleaf布局</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>一个网页通常可以分为几部分：1.头部 2.侧边栏 3.主要区域 4.尾部</p>
<p>那么为了每个页面的代码不那么臃肿，我们可以将这些不同的区域分别提取出来，然后通过Thymeleaf的<code>th</code>标签将这些页面再重新组合在一起。</p>
<p>因此，我们划分了以下几个部分：</p>
<p><img src="/2019/02/26/boot/spring-boot-thymeleaf/5.png" alt></p>
<p>其中<code>common-css.html</code>和<code>common-js.html</code>分别存放页面公共的css/js引入标签。</p>
<h2 id="关于子页面"><a href="#关于子页面" class="headerlink" title="关于子页面"></a>关于子页面</h2><p>上面说到将页面划分了几部分，其实换分的几部分仅仅是将不同的<code>&lt;div&gt;</code>标签存放在不同的html中，如下：</p>
<p><img src="/2019/02/26/boot/spring-boot-thymeleaf/6.png" alt></p>
<p>所以，看<code>header.html</code>代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">"header"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header-logo"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>后台模板<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>无需<code>&lt;html&gt;</code>的基础结构。</p>
<p><strong>关于子页面使用<code>th</code>标签</strong></p>
<p>因为子页面无需<code>&lt;html&gt;</code>的结构，也就没有<code>&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;</code>这个标签库，直接在子页面中用<code>th:text=&quot;&quot;</code>可能IDE会报错，但是实际上是语法正确，因为在<code>main.html</code>中使用了这个标签库。</p>
<p>另外，也可以这样使用避免IDE的报错：</p>
<p><code>common-css.html</code>:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">data-th-href</span>=<span class="string">"@&#123;/css/base.css&#125;"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="常见布局"><a href="#常见布局" class="headerlink" title="常见布局"></a>常见布局</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:replace</span>=<span class="string">"common/common-css"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:replace</span>=<span class="string">"common/header"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:replace</span>=<span class="string">"common/side"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">"content-title"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ol</span> <span class="attr">class</span>=<span class="string">"breadcrumb"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"breadcrumb-item"</span>&gt;</span>主页<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main-content"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是main.html<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>那么，这就是一个基础布局，通过在主页面（main.html）中引入其他子页面（header,side,css）：</p>
<p><img src="/2019/02/26/boot/spring-boot-thymeleaf/7.png" alt></p>
<h2 id="使用iframe布局"><a href="#使用iframe布局" class="headerlink" title="使用iframe布局"></a>使用iframe布局</h2><p>在以往的开发中，我们很经常遇到这样的问题（需求）：</p>
<p><img src="/2019/02/26/boot/spring-boot-thymeleaf/8.png" alt></p>
<p>这里就用到了<code>&lt;frameset&gt;</code>、<code>&lt;iframe&gt;</code>了，他就是实现将B页面嵌套到A页面的指定区域内。</p>
<blockquote>
<p>修改<code>main.html</code></p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:replace</span>=<span class="string">"common/common-css"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:replace</span>=<span class="string">"common/header"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:replace</span>=<span class="string">"common/side"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">"content-title"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ol</span> <span class="attr">class</span>=<span class="string">"breadcrumb"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"breadcrumb-item"</span>&gt;</span>主页<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main-content"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"/index"</span> <span class="attr">width</span>=<span class="string">"100%"</span> <span class="attr">height</span>=<span class="string">"100%"</span> <span class="attr">name</span>=<span class="string">"iframe"</span> <span class="attr">frameborder</span>=<span class="string">"0"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>修改<code>index.html</code></p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Index<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line">`$&#123;...&#125;`表达式：<span class="tag">&lt;<span class="name">b</span> <span class="attr">th:text</span>=<span class="string">"$&#123;demo&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">`*&#123;...&#125;`表达式：</span><br><span class="line"><span class="tag">&lt;<span class="name">b</span> <span class="attr">th:object</span>=<span class="string">"$&#123;user&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"*&#123;username&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"*&#123;password&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line">错误实例：<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"*&#123;username&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">另一种获取方式：<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.username&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>字符串拼接<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"'hello ' + $&#123;user.username&#125; + '!'"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">简洁用法：<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"|hello $&#123;user.username&#125;!|"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>if/unless条件判断<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">th:if</span>=<span class="string">"$&#123;user.username == 'tycoding'&#125;"</span>&gt;</span>tycoding<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">th:unless</span>=<span class="string">"$&#123;user.username == 'admin'&#125;"</span>&gt;</span>tycoding<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>for循环<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">th:each</span>=<span class="string">"item,property : $&#123;list&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">th:text</span>=<span class="string">"$&#123;property.index&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">th:text</span>=<span class="string">"$&#123;item&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>内联JS<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">th:inline</span>=<span class="string">"javascript"</span>&gt;</span></span><br><span class="line">    var username = [[$&#123;user.username&#125;]];</span><br><span class="line">    console.log(username);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>修改<code>RouterController.java</code></p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">@GetMapping("/")</span><br><span class="line">public String main() &#123;</span><br><span class="line">    return "/common/main";</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2019/02/26/boot/spring-boot-thymeleaf/9.png" alt></p>
<p>如果想要点击左侧菜单，在<code>content</code>区域显示菜单对应页面内容，还需要修改<code>side.html</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aside</span> <span class="attr">class</span>=<span class="string">"side"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"scrollbar-inner"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"navigation"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/index"</span> <span class="attr">target</span>=<span class="string">"iframe"</span>&gt;</span>系统管理<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span>&gt;</span>用户管理<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span>&gt;</span>任务调度<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>&lt;a&gt;</code>标签中的<code>target</code>指向<code>&lt;iframe&gt;</code>中的<code>name</code>值。</p>
<br>

<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <categories>
        <category>spring-boot</category>
      </categories>
      <tags>
        <tag>spring-boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Shiro在线会话管理</title>
    <url>/2019/02/16/ssm/shiro/54-shiro-session/</url>
    <content><![CDATA[<h1 id="Shiro在线会话管理"><a href="#Shiro在线会话管理" class="headerlink" title="Shiro在线会话管理"></a>Shiro在线会话管理</h1><p>参考文章：</p>
<ul>
<li><p><a href="https://zm10.sm-tc.cn/?src=l4uLj4zF0NCVlpGRlp6RjJeWk5CRmJGWnpHRlouahprRnJCS0J2TkJjQzc%2FLyMnLzA%3D%3D&from=derive&depth=3&link_type=60&wap=false&v=1&uid=03200e6c3a76bced6b1828a8cf8d6404&restype=1" target="_blank" rel="noopener">跟我学Shiro-在线会话</a></p>
</li>
<li><p><a href="https://mrbird.cc/Spring-Boot-Shiro%20session.html" target="_blank" rel="noopener">Spring Boot Shiro在线会话管理</a></p>
</li>
</ul>
<p>实现效果预览：</p>
<p><img src="/2019/02/16/ssm/shiro/54-shiro-session/1.png" alt></p>
<a id="more"></a>

<p>Shiro提供一个对象<code>org.apache.shiro.session.mgt.eis.SessionDAO</code>，通过此对象可以获取到Shiro的Session中有效的Session对象，通过此对象，我们可以获取到用户登录的数据，比如：用户名、密码、ID、SessionID、登录时间、最后访问时间、IP地址等等。</p>
<p><img src="/2019/02/16/ssm/shiro/54-shiro-session/2.png" alt></p>
<p><img src="/2019/02/16/ssm/shiro/54-shiro-session/3.png" alt></p>
<p>下面我们实现两个功能：</p>
<ul>
<li><p>获取在线会话列表</p>
</li>
<li><p>实现强制下线功能</p>
</li>
</ul>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><h3 id="ShiroConfig"><a href="#ShiroConfig" class="headerlink" title="ShiroConfig"></a>ShiroConfig</h3><p>这里我使用的是Redis来储存Shiro的Session信息，修改<code>SessionDAO</code>配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisSessionDAO <span class="title">redisSessionDAO</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RedisSessionDAO redisSessionDAO = <span class="keyword">new</span> RedisSessionDAO();</span><br><span class="line">    redisSessionDAO.setRedisManager(redisManager());</span><br><span class="line">    <span class="keyword">return</span> redisSessionDAO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"redis.shiro"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisManager <span class="title">redisManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RedisManager();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还需要将<code>SessionDAO</code>注入到<code>SessionManager</code>中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SessionManager <span class="title">sessionManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DefaultWebSessionManager defaultWebSessionManager = <span class="keyword">new</span> DefaultWebSessionManager();</span><br><span class="line">    defaultWebSessionManager.setCacheManager(cacheManager());</span><br><span class="line">    defaultWebSessionManager.setSessionDAO(sessionDAO());</span><br><span class="line">    <span class="keyword">return</span> sessionManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后将<code>SessionManager</code>注入到<code>SecurityManager</code>中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SecurityManager <span class="title">securityManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DefaultWebSecurityManager securityManager = <span class="keyword">new</span> DefaultWebSecurityManager();</span><br><span class="line">    securityManager.setRealm(realm());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义sessionManager</span></span><br><span class="line">    securityManager.setSessionManager(sessionManager());</span><br><span class="line">    <span class="comment">//自定义缓存实现</span></span><br><span class="line">    securityManager.setCacheManager(cacheManager());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> securityManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取在线会话列表"><a href="#获取在线会话列表" class="headerlink" title="获取在线会话列表"></a>获取在线会话列表</h2><h3 id="OnlineUser-java"><a href="#OnlineUser-java" class="headerlink" title="OnlineUser.java"></a>OnlineUser.java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OnlineUser</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String id; <span class="comment">//sessionId</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String uid; <span class="comment">//用户ID</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username; <span class="comment">//用户名</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String host; <span class="comment">//主机地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String address; <span class="comment">//地理位置</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@DateTimeFormat</span>(pattern = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>)</span><br><span class="line">    <span class="meta">@JsonFormat</span>(pattern = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>, timezone = <span class="string">"GMT+8"</span>)</span><br><span class="line">    <span class="keyword">private</span> Date startTime; <span class="comment">//用户开始访问时间</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@DateTimeFormat</span>(pattern = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>)</span><br><span class="line">    <span class="meta">@JsonFormat</span>(pattern = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>, timezone = <span class="string">"GMT+8"</span>)</span><br><span class="line">    <span class="keyword">private</span> Date endTime; <span class="comment">//用户最后访问时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long timeout; <span class="comment">//超时时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String status; <span class="comment">//状态</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHost</span><span class="params">(String host)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host.equals(<span class="string">"0:0:0:0:0:0:0:1"</span>) ? <span class="string">"127.0.0.1"</span> : host;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>编写获取在线会话列表的service层实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;OnlineUser&gt; <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;OnlineUser&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Collection&lt;Session&gt; sessions = sessionDAO.getActiveSessions(); <span class="comment">//获取在线会话的集合</span></span><br><span class="line">    <span class="keyword">for</span> (Session session : sessions) &#123;</span><br><span class="line">        <span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">            OnlineUser onlineUser = <span class="keyword">new</span> OnlineUser();</span><br><span class="line">            SimplePrincipalCollection principalCollection;</span><br><span class="line">            User user;</span><br><span class="line">            <span class="comment">//判断此session是否还在登录状态</span></span><br><span class="line">            <span class="keyword">if</span> (session.getAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果此session正在登录，将此session的数据放入principalCollection集合中，从而可获取登录用户对象数据</span></span><br><span class="line">                principalCollection = (SimplePrincipalCollection) session.getAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY);</span><br><span class="line">                user = (User) principalCollection.getPrimaryPrincipal();</span><br><span class="line">                onlineUser.setUid(user.getId().toString());</span><br><span class="line">                onlineUser.setUsername(user.getUsername());</span><br><span class="line">            &#125;</span><br><span class="line">            onlineUser.setId(session.getId().toString());</span><br><span class="line">            onlineUser.setHost(session.getHost());</span><br><span class="line">            onlineUser.setAddress(AddressUtil.getAddress(session.getHost()));</span><br><span class="line">            onlineUser.setStartTime(session.getStartTimestamp());</span><br><span class="line">            onlineUser.setEndTime(session.getLastAccessTime());</span><br><span class="line">            <span class="keyword">long</span> timeout = session.getTimeout();</span><br><span class="line">            onlineUser.setTimeout(timeout);</span><br><span class="line">            onlineUser.setStatus(timeout == <span class="number">0L</span> ? <span class="string">"0"</span> : <span class="string">"1"</span>); <span class="comment">//0在线 1下线</span></span><br><span class="line">            list.add(onlineUser);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getActiveSessions()</code>将获取到所有有效的Session集合，通过<code>DefaultSubjectContext.PRINCIPALS_SESSION_KEY</code>可以判断当前系统<code>Subject</code>中的<code>session key</code>和<code>sessions</code>列表中的session是否匹配，不匹配则session无效。</p>
<p><code>session.getHost()</code>顾名思义就是获取Host主机地址即IP地址。</p>
<p><code>AddressUtil.getAddress(session.getHost())</code>是通过IP地址查询其详细的地理位置，使用了<code>ip2region</code>开源库。</p>
<h3 id="根据IP查询地址位置"><a href="#根据IP查询地址位置" class="headerlink" title="根据IP查询地址位置"></a>根据IP查询地址位置</h3><p>开源地址：<a href="https://github.com/lionsoul2014/ip2region" target="_blank" rel="noopener">https://github.com/lionsoul2014/ip2region</a></p>
<p>引入<code>ip2region</code>的依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.lionsoul<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ip2region<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>拷贝<code>ip2region.db</code>文件（开源仓库中找）到项目的<code>resources/config/</code>下</p>
<p>参考官方实例代码写工具类<code>AddressUtil.java</code></p>
<p>官方实例：<a href="https://github.com/lionsoul2014/ip2region/blob/master/binding/java/src/main/java/org/lionsoul/ip2region/test/TestSearcher.java" target="_blank" rel="noopener">https://github.com/lionsoul2014/ip2region/blob/master/binding/java/src/main/java/org/lionsoul/ip2region/test/TestSearcher.java</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddressUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getAddress</span><span class="params">(String ip)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//db</span></span><br><span class="line">        String dbPath = AddressUtil.class.getResource(<span class="string">"/config/ip2region.db"</span>).getPath();</span><br><span class="line"></span><br><span class="line">        File file = <span class="keyword">new</span> File(dbPath);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> GlobalException(<span class="string">"缺少 ip2region.db库"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> algorithm = DbSearcher.BTREE_ALGORITHM; <span class="comment">//B-tree</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DbConfig config = <span class="keyword">new</span> DbConfig();</span><br><span class="line">            DbSearcher searcher = <span class="keyword">new</span> DbSearcher(config, file.getPath());</span><br><span class="line">            BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//define the method</span></span><br><span class="line">            Method method = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">switch</span> (algorithm) &#123;</span><br><span class="line">                <span class="keyword">case</span> DbSearcher.BTREE_ALGORITHM:</span><br><span class="line">                    method = searcher.getClass().getMethod(<span class="string">"btreeSearch"</span>, String.class);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> DbSearcher.BINARY_ALGORITHM:</span><br><span class="line">                    method = searcher.getClass().getMethod(<span class="string">"binarySearch"</span>, String.class);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> DbSearcher.MEMORY_ALGORITYM:</span><br><span class="line">                    method = searcher.getClass().getMethod(<span class="string">"memorySearch"</span>, String.class);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            DataBlock dataBlock = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (!Util.isIpAddress(ip)) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Error: Invalid ip address"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            dataBlock = (DataBlock) method.invoke(searcher, ip);</span><br><span class="line">            reader.close();</span><br><span class="line">            searcher.close();</span><br><span class="line">            <span class="keyword">return</span> dataBlock.getRegion();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结"><a href="#结" class="headerlink" title="结"></a>结</h3><p>当前端请求<code>/online/list</code>接口时，将<code>List&lt;OnlineUser&gt;</code>结合数据返回给前端渲染即可。</p>
<h2 id="实现强制下线功能"><a href="#实现强制下线功能" class="headerlink" title="实现强制下线功能"></a>实现强制下线功能</h2><h3 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/forceLogout"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseCode <span class="title">forceLogout</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        sessionService.forceLogout(id);</span><br><span class="line">        <span class="keyword">return</span> ResponseCode.SUCCESS();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> ResponseCode.ERROR();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这个<code>id</code>是sessionID</p>
<h3 id="service实现"><a href="#service实现" class="headerlink" title="service实现"></a>service实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forceLogout</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">    Session session = sessionDAO.readSession(id);</span><br><span class="line">    session.setTimeout(<span class="number">0L</span>);</span><br><span class="line">    session.stop();</span><br><span class="line">    sessionDAO.delete(session);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <categories>
        <category>shiro</category>
      </categories>
      <tags>
        <tag>shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>ElementUI+Shiro构建权限Tree</title>
    <url>/2019/02/16/ssm/shiro/53-shiro-tree2-md/</url>
    <content><![CDATA[<h1 id="ElementUI-Tree"><a href="#ElementUI-Tree" class="headerlink" title="ElementUI - Tree"></a>ElementUI - Tree</h1><p>在上一篇文章中我们介绍了Java后端如何构建一棵Tree树，并将数据返回给前端，前端Vue.js + ElementUI 又是如何渲染出来.</p>
<p>博文地址：<a href="https://tycoding.cn/2019/01/30/ssm/shiro/shiro-tree/" target="_blank" rel="noopener">Shiro权限管理项目中，如何构建权限菜单？</a></p>
<p>这次呢，我们谈如何使用ElementUI中的Tree组件，用于部门、角色、菜单的修改添加上，以’部门管理’举例，效果如下：</p>
<p><img src="/2019/02/16/ssm/shiro/53-shiro-tree2-md/1.png" alt></p>
<a id="more"></a>

<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul>
<li><p>首先请阅读ElementUI Tree组件官方文档：<a href="http://element-cn.eleme.io/#/zh-CN/component/tree" target="_blank" rel="noopener">传送门</a></p>
</li>
<li><p>其次请阅读我的上篇文章：<a href="https://tycoding.cn/2019/01/30/ssm/shiro/shiro-tree/" target="_blank" rel="noopener">Shiro权限管理项目中，如何构建权限菜单？</a></p>
</li>
</ul>
<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><h2 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h2><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><p>在写后端接口数据前（当然如何写在上篇文章也有提到），我们先绘出前端界面：</p>
<blockquote>
<p>首先是Tree组件</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-form</span> <span class="attr">ref</span>=<span class="string">"form"</span> <span class="attr">:model</span>=<span class="string">"form"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">prop</span>=<span class="string">"parentId"</span> <span class="attr">v-model</span>=<span class="string">"form.parentId"</span> <span class="attr">label</span>=<span class="string">"上级部门"</span> <span class="attr">label-width</span>=<span class="string">"120px"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-tree</span> <span class="attr">:data</span>=<span class="string">"roleTree"</span> <span class="attr">ref</span>=<span class="string">"tree"</span> <span class="attr">highlight-current</span> <span class="attr">show-checkbox</span> <span class="attr">check-strictly</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">:default-checked-keys</span>=<span class="string">"form.parentId"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">:default-expanded-keys</span>=<span class="string">"form.parentId"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">node-key</span>=<span class="string">"id"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">:props</span>=<span class="string">"treeProps"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-tree</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>解释</strong></p>
<table>
<thead>
<tr>
<th align="left">Attribute</th>
<th align="left">Tips</th>
</tr>
</thead>
<tbody><tr>
<td align="left">prop</td>
<td align="left">本例中用户表单校验</td>
</tr>
<tr>
<td align="left">v-model</td>
<td align="left">双向绑定，格式为数组</td>
</tr>
<tr>
<td align="left">:data</td>
<td align="left">封装tree数据的数组，用于渲染树形结构</td>
</tr>
<tr>
<td align="left">show-checkbox</td>
<td align="left">显示勾选框</td>
</tr>
<tr>
<td align="left">check-strictly</td>
<td align="left">严格模式，父子节点无关系，不联动勾选</td>
</tr>
<tr>
<td align="left">node-key</td>
<td align="left">指定每个节点的key，最好就为节点的id值</td>
</tr>
<tr>
<td align="left">:default-checked-keys</td>
<td align="left">默认选中的项，参数为封装了<code>node-key</code>的数组</td>
</tr>
<tr>
<td align="left">:default-expanded-keys</td>
<td align="left">默认展开的项，参数为封装了<code>node-key</code>的数组</td>
</tr>
<tr>
<td align="left">:props</td>
<td align="left">Tree树节点的配置选项</td>
</tr>
</tbody></table>
<blockquote>
<p>其次是Vue.js部分</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        <span class="comment">//模态框状态标识</span></span><br><span class="line">        dialogVisible: <span class="literal">false</span>,</span><br><span class="line">        dialogTitle: <span class="string">''</span>,</span><br><span class="line">        roleTree: [], <span class="comment">//部门Tree</span></span><br><span class="line">        treeProps: &#123;</span><br><span class="line">            children: <span class="string">'children'</span>,</span><br><span class="line">            label: <span class="string">'name'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//form表单对象</span></span><br><span class="line">        form: &#123;</span><br><span class="line">            id: <span class="string">''</span>,</span><br><span class="line">            name: <span class="string">''</span>,</span><br><span class="line">            parentId: [],</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        <span class="comment">//触发保存按钮：添加、更新</span></span><br><span class="line">        handleSave(id) &#123;</span><br><span class="line">            <span class="keyword">this</span>.clearForm();</span><br><span class="line">            <span class="comment">//获取Dept列表</span></span><br><span class="line">            <span class="keyword">this</span>.$http.get(api.system.dept.roleTree).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.roleTree = response.body.data;</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">if</span> (id == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.dialogTitle = <span class="string">'新增部门'</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.dialogTitle = <span class="string">'修改部门'</span></span><br><span class="line">                <span class="keyword">this</span>.$http.get(api.system.dept.findById(id)).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.form = response.body.data;</span><br><span class="line">                    <span class="keyword">if</span> (response.body.data.parentId == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.form.parentId = []</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">this</span>.form.parentId = [response.body.data.parentId]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.dialogVisible = <span class="literal">true</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        clearForm() &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.$refs.form != <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.$refs.form.resetFields();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.form.id = <span class="string">''</span></span><br><span class="line">            <span class="keyword">this</span>.form.name = <span class="string">''</span></span><br><span class="line">            <span class="keyword">this</span>.form.parentId = []</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong></p>
<p>代码基本如上了，需要注意以下几点：</p>
<ul>
<li><p><code>roleTree</code>是绑定tree数据的数组，通过调用后端接口将response的tree数据赋值给<code>roleTree</code></p>
</li>
<li><p><code>treeProps</code>是配置tree节点属性，比如上<code>children: &#39;children&#39;</code>就是规定Tree组件的子节点名称为<code>children</code>，方便tree组件去识别后端的tree结构，具体看后端返回的数据格式</p>
</li>
<li><p>本例中<code>form</code>中的<code>parentId</code>既是Tree组件双向绑定的参数，也是<code>default-xx-keys</code>Tree组件默认选中和展开的参数，格式为<code>node-key</code>中多个key的数组，比如[key1,key2]</p>
</li>
<li><p>我这里新增和修改公用了一个model，如果是新增就直接展示mode即可(先获取Tree数据)，如果是修改，还要调用<code>findById</code>查询当前行的数据。</p>
</li>
<li><p>注意在<code>findById</code>的<code>then</code>中还进行了<code>this.form.parentId = [response.body.data.parentId]</code>，目的是将后端的<code>parentId</code>字符串转换为<code>[key]</code>数组，具体视后端tree数据格式，因为这里规定一个部门自能有一个上级部门，所以后端的<code>parentId</code>为String</p>
</li>
</ul>
<h4 id="结"><a href="#结" class="headerlink" title="结"></a>结</h4><p>到这里前端的数据渲染部分已基本完成（注意我粘贴的代码中省略了一部分），下面看一下Tree组件的数据结构，即<code>roleTree</code>：</p>
<p><img src="/2019/02/16/ssm/shiro/53-shiro-tree2-md/2.png" alt></p>
<h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><p>上面可以看到Tree组件的数据格式，后端的任务就是获取数据库中的记录并封装为Tree树的结构返回给前端。</p>
<p>因为在 <a href="https://tycoding.cn/2019/01/30/ssm/shiro/shiro-tree/" target="_blank" rel="noopener">Shiro权限管理项目中，如何构建权限菜单？</a> 一文中已经介绍了如何将数据库中的记录封装为Tree树结构，这里不过多解释，直接上代码：</p>
<p><strong>service层实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeptServiceImpl</span> <span class="keyword">extends</span> <span class="title">BaseServiceImpl</span>&lt;<span class="title">Dept</span>&gt; <span class="keyword">implements</span> <span class="title">DeptService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DeptMapper deptMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Tree&lt;Dept&gt;&gt; tree() &#123;</span><br><span class="line">        List&lt;Dept&gt; list = queryList(<span class="keyword">new</span> Dept());</span><br><span class="line">        List&lt;Tree&lt;Dept&gt;&gt; treeList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.forEach(dept -&gt; &#123;</span><br><span class="line">            Tree&lt;Dept&gt; tree = <span class="keyword">new</span> Tree&lt;&gt;();</span><br><span class="line">            tree.setId(dept.getId());</span><br><span class="line">            tree.setParentId(dept.getParentId());</span><br><span class="line">            tree.setName(dept.getName());</span><br><span class="line">            treeList.add(tree);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> TreeUtils.build(treeList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Dept&gt; <span class="title">queryList</span><span class="params">(Dept dept)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Example example = <span class="keyword">new</span> Example(Dept.class);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotBlank(dept.getName())) &#123;</span><br><span class="line">                example.createCriteria().andCondition(<span class="string">"name"</span>, dept.getName());</span><br><span class="line">            &#125;</span><br><span class="line">            example.setOrderByClause(<span class="string">"create_time"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.selectByExample(example);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="结-1"><a href="#结-1" class="headerlink" title="结"></a>结</h4><p>后端的代码我们在 <a href="https://tycoding.cn/2019/01/30/ssm/shiro/shiro-tree/" target="_blank" rel="noopener">Shiro权限管理项目中，如何构建权限菜单？</a> 中解释过了，这里不再讲解</p>
<h2 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h2><h3 id="前端-1"><a href="#前端-1" class="headerlink" title="前端"></a>前端</h3><h4 id="实现Tree组件单选"><a href="#实现Tree组件单选" class="headerlink" title="实现Tree组件单选"></a>实现Tree组件单选</h4><blockquote>
<p>修改html</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-form</span> <span class="attr">ref</span>=<span class="string">"form"</span> <span class="attr">:model</span>=<span class="string">"form"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">prop</span>=<span class="string">"parentId"</span> <span class="attr">v-model</span>=<span class="string">"form.parentId"</span> <span class="attr">label</span>=<span class="string">"上级部门"</span> <span class="attr">label-width</span>=<span class="string">"120px"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-tree</span> <span class="attr">:data</span>=<span class="string">"roleTree"</span> <span class="attr">ref</span>=<span class="string">"tree"</span> <span class="attr">highlight-current</span> <span class="attr">show-checkbox</span> <span class="attr">check-strictly</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">:default-checked-keys</span>=<span class="string">"form.parentId"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">:default-expanded-keys</span>=<span class="string">"form.parentId"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">node-key</span>=<span class="string">"id"</span></span></span><br><span class="line"><span class="tag">                 @<span class="attr">check-change</span>=<span class="string">"checkChange"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">:props</span>=<span class="string">"treeProps"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-tree</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>修改Vue.js部分</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Tree控件节点选中状态改变触发的事件</span></span><br><span class="line">checkChange(data, node, self) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">        <span class="keyword">this</span>.form.parentId = [data.id];</span><br><span class="line">        <span class="keyword">this</span>.$refs.tree.setCheckedNodes([data.id])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.$refs.tree.getCheckedKeys().length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.form.parentId = [];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong></p>
<p><code>@check-change</code>是节点选中状态改变触发的事件。</p>
<p>因为这里我们讲编辑功能，必然涉及对节点的编辑（比如修改父级节点、修改关联权限节点）。在本例中主要是修改部门的上级节点，又因为我们规定一个节点最多有一个上级节点，那么Tree组件的勾选节点应该变为<strong>单选</strong>，而官方的Tree组件都是多选的，所以看到上面我们新增的<code>checkChange()</code>方法中的实现，目的就是实现单选。</p>
<p><code>checkChange(data, node, self)</code>方法中参数<code>data</code>是勾选（取消勾选）节点的tree数据（包含其所有子节点的数据）；<code>node</code>是当前触发节点是否被选中；<code>self</code>是当前节点本身是否被选中。</p>
<p><strong>坑</strong></p>
<p><code>setCheckNodes()</code>是设置Tree组件选中的节点，<code>getCheckedKeys()</code>是获取Tree组件当前选中的节点。实现单选，就是实现：A节点选中，再勾选B节点时，先清空已勾选节点，再用<code>setCheckNodes()</code>手动设置Tree组件勾选节点；这样就实现了单选（选中B，就取消A勾选状态）。<br>而<code>setCheckNodes()</code>方法会触发<code>checkChange()</code>方法，所以要判断<code>this.$refs.tree.getCheckedKeys().length</code>。</p>
<p>注意Tree组件中的<code>:default-checked-keys</code>的参数也是<code>form.parentId</code>所以我们要时刻保证<code>parentId</code>是一个数组（尽管后端需要的是String），所以仅需要在<code>save()</code>保存更改的时候再修改<code>parentId</code>为String，并且修改完成后要立即把<code>parentId</code>变为数组。</p>
<p><strong>But</strong></p>
<p>以上都是在努力把Tree组件改为单选，But，如果你业务需要多选就不需要上述<code>checkChange()</code>方法中的判断了。</p>
<h4 id="保存更改"><a href="#保存更改" class="headerlink" title="保存更改"></a>保存更改</h4><blockquote>
<p>HTML触发保存按钮</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">"primary"</span> @<span class="attr">click</span>=<span class="string">"save('form')"</span>&gt;</span>确 定<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>你可能会注意到<code>save(&#39;form&#39;)</code>中<code>&#39;form&#39;</code>是什么鬼？其实他是<code>&lt;el-form&gt;</code>中的<code>prop=&quot;form&quot;</code>，目的是为了实现表单校验功能，具体看官方文档：<a href="http://element-cn.eleme.io/#/zh-CN/component/form" target="_blank" rel="noopener">传送门</a></p>
<blockquote>
<p>Vue.js中新增<code>save</code>方法</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//保存</span></span><br><span class="line">save(form) &#123;</span><br><span class="line">    <span class="keyword">this</span>.$refs[form].validate(<span class="function">(<span class="params">valid</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (valid) &#123;</span><br><span class="line">            <span class="keyword">this</span>.dialogVisible = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">this</span>.form.parentId = <span class="keyword">this</span>.form.parentId[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.form.id == <span class="literal">null</span> || <span class="keyword">this</span>.form.id == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//添加</span></span><br><span class="line">                <span class="keyword">this</span>.$http.post(api.system.dept.add, <span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>.form)).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (response.body.code == <span class="number">200</span>) &#123;</span><br><span class="line">                        <span class="keyword">this</span>._notify(response.body.msg, <span class="string">'success'</span>)</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">this</span>._notify(response.body.msg, <span class="string">'error'</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">this</span>.clearForm();</span><br><span class="line">                    <span class="keyword">this</span>.init()</span><br><span class="line">                    <span class="keyword">this</span>.search(<span class="keyword">this</span>.pageConf.pageCode, <span class="keyword">this</span>.pageConf.pageSize)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//修改</span></span><br><span class="line">                <span class="keyword">this</span>.$http.post(api.system.dept.update, <span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>.form)).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (response.body.code == <span class="number">200</span>) &#123;</span><br><span class="line">                        <span class="keyword">this</span>._notify(response.body.msg, <span class="string">'success'</span>)</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">this</span>._notify(response.body.msg, <span class="string">'error'</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">this</span>.clearForm();</span><br><span class="line">                    <span class="keyword">this</span>.init()</span><br><span class="line">                    <span class="keyword">this</span>.search(<span class="keyword">this</span>.pageConf.pageCode, <span class="keyword">this</span>.pageConf.pageSize)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="后端-1"><a href="#后端-1" class="headerlink" title="后端"></a>后端</h3><p>上面对部门的添加和修改节点其实都比较简单些，直接将前端数据保存进数据库即可，这里我们将一下节点的删除：</p>
<h4 id="节点删除"><a href="#节点删除" class="headerlink" title="节点删除"></a>节点删除</h4><p>节点删除，主要涉及：</p>
<ul>
<li><p>根据ID删除此id对应的数据库中的记录</p>
</li>
<li><p>如果此表于其他表有关联（比如 角色按钮关联表），还需要根据id删除其关联表中的记录。（此处的关联不是外键关联）</p>
</li>
<li><p>修改此节点的父级节点ID，比如B节点的父级简单是A，删除了A，B节点应该是A节点那一级</p>
</li>
</ul>
<p>举例：改变父级节点，<code>service</code>层实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(List&lt;Long&gt; ids)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.batchDelete(ids, <span class="string">"id"</span>, Dept.class);</span><br><span class="line">    <span class="keyword">this</span>.deptMapper.changeTopNode(ids);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>deptMapper</code>的mapper.xml如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"changeTopNode"</span>&gt;</span></span><br><span class="line">    update tb_dept</span><br><span class="line">    set parent_id = 0</span><br><span class="line">    where id in (select a.id</span><br><span class="line">    from (select id from tb_dept where parent_id in</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"list"</span> <span class="attr">item</span>=<span class="string">"id"</span> <span class="attr">index</span>=<span class="string">"index"</span> <span class="attr">open</span>=<span class="string">"("</span> <span class="attr">close</span>=<span class="string">")"</span> <span class="attr">separator</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">        #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    ) a);</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<ul>
<li><code>ids</code>是一个<code>List&lt;Long&gt;</code>集合，目的是实现批量删除功能。在Mybatis中遍历集合就要用<code>&lt;foreach&gt;</code></li>
</ul>
<p>将上面</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> tb_dept <span class="keyword">where</span> parent_id <span class="keyword">in</span></span><br><span class="line">&lt;foreach collection=<span class="string">"list"</span> item=<span class="string">"id"</span> <span class="keyword">index</span>=<span class="string">"index"</span> <span class="keyword">open</span>=<span class="string">"("</span> <span class="keyword">close</span>=<span class="string">")"</span> separator=<span class="string">","</span>&gt;</span><br><span class="line">    <span class="comment">#&#123;id&#125;</span></span><br><span class="line">&lt;/foreach&gt;</span><br></pre></td></tr></table></figure>

<p>拆分，大概就是这样一段SQL：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> tb_dept <span class="keyword">where</span> parent_id <span class="keyword">in</span> (<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> a.id <span class="keyword">from</span> (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> tb_menu <span class="keyword">where</span> parent_id <span class="keyword">in</span> (<span class="number">1</span>, <span class="number">2</span>)) a;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> tb_menu <span class="keyword">where</span> parent_id <span class="keyword">in</span> (<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>上述两种方式都能查询出来parent_id是(1,2)的记录行的id值。而第一种方式是先生成一张临时表a，再查询id值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> tb_menu</span><br><span class="line"><span class="keyword">set</span> parent_id = <span class="number">0</span></span><br><span class="line"><span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">in</span> (<span class="keyword">select</span> a.id</span><br><span class="line">             <span class="keyword">from</span> (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> tb_menu <span class="keyword">where</span> parent_id <span class="keyword">in</span> (<span class="number">1</span>, <span class="number">2</span>)) a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> tb_menu</span><br><span class="line"><span class="keyword">set</span> parent_id = <span class="number">0</span></span><br><span class="line"><span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> tb_menu <span class="keyword">where</span> parent_id <span class="keyword">in</span> (<span class="number">1</span>, <span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<p>若执行后者会报错：<code>You can&#39;t specify target table &#39;tb_menu&#39; for update in FROM clause</code>，
百度查到是由于mysql不能对一张表查询到某些值就同时更新这张表，通过生成一张临时表来避免这个问题</p>
<br>

<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <categories>
        <category>shiro</category>
      </categories>
      <tags>
        <tag>shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>Shiro权限管理项目中，如何构建权限菜单？</title>
    <url>/2019/01/30/ssm/shiro/shiro-tree/</url>
    <content><![CDATA[<h1 id="如何构建一个Tree树，并在前端渲染成Tree菜单？"><a href="#如何构建一个Tree树，并在前端渲染成Tree菜单？" class="headerlink" title="如何构建一个Tree树，并在前端渲染成Tree菜单？"></a>如何构建一个Tree树，并在前端渲染成Tree菜单？</h1><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><p>为什么要构建一棵Tree树？在权限管理系统中（或说是本例中），Tree树主要用于构建前端不同权限展示的不同菜单，这个菜单的名称和URL地址保存在数据库中，当用户登录后，查询到此用户对应角色的资源菜单，并封装为集合对象已JSON格式返回给前端渲染。</p>
<h3 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h3><p>那么首先后端封装Tree树的结构：</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tree</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id; <span class="comment">//节点ID</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long parentId; <span class="comment">//父节点ID</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Boolean hasChildren; <span class="comment">//是否有子节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Boolean hasParent; <span class="comment">//是否有父节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">//节点名称</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String url; <span class="comment">//节点URL</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Tree&lt;T&gt;&gt; children = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">//子节点信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然以上的属性仅用来测试举例，结合项目的实际情况定义。关于数据库表结构的定义可以参看：<a href="https://www.tycoding.cn/2018/09/15/ssm/shiro/shiro-database/">Shiro权限表设计</a></p>
<h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>定义了Tree实体结构，下面我们看前端请求当前用户资源菜单的Service层实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Tree&lt;Resource&gt;&gt; getResource(String username) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取用户资源列表和角色列表</span></span><br><span class="line">    List&lt;Resource&gt; menus = resourceMapper.findUserResources(username);</span><br><span class="line"></span><br><span class="line">    List&lt;Tree&lt;Resource&gt;&gt; treeList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    menus.forEach(menu -&gt; &#123;</span><br><span class="line">        Tree&lt;Resource&gt; tree = <span class="keyword">new</span> Tree&lt;&gt;();</span><br><span class="line">        tree.setId(menu.getId());</span><br><span class="line">        tree.setParentId(menu.getParentId());</span><br><span class="line">        tree.setName(menu.getName());</span><br><span class="line">        tree.setUrl(menu.getUrl());</span><br><span class="line">        treeList.add(tree);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> TreeUtils.build(treeList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>list.forEach(item -&gt; {})</code>是JDK8的lambda表达式，作用就是遍历集合对象。</p>
<p>这里Tree的泛型是<code>Resource</code>，结合实际情况，前端展示的资源菜单数据在哪里定义，这个泛型就指向哪里。看一下我的<code>tb_resource</code>表：</p>
<p><img src="/2019/01/30/ssm/shiro/shiro-tree/9.png" alt></p>
<p>通过上面的遍历和循环添加，<code>treeList</code>中储存了<code>menus</code>中所有的数据并以<code>Resource</code>对象结构出现：</p>
<p><img src="/2019/01/30/ssm/shiro/shiro-tree/10.png" alt></p>
<p>按照上面的代码，此时还没有构建Tree树的结构，只是将信息都封装在<code>List&lt;Tree&gt;</code>中：</p>
<h3 id="TreeUtils"><a href="#TreeUtils" class="headerlink" title="TreeUtils"></a>TreeUtils</h3><p>通过这个工具类判断封装在<code>treeList</code>中的节点是父节点还是子节点；若是子节点，这个子节点的父节点又是谁？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;Tree&lt;T&gt;&gt; build(List&lt;Tree&lt;T&gt;&gt; nodes) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nodes == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Tree&lt;T&gt;&gt; tree = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        nodes.forEach(children -&gt; &#123;</span><br><span class="line">            Long pid = children.getParentId();</span><br><span class="line">            <span class="keyword">if</span> (pid == <span class="keyword">null</span> || pid.equals(<span class="number">0L</span>)) &#123;</span><br><span class="line">                <span class="comment">//是父节点</span></span><br><span class="line">                tree.add(children);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (Tree&lt;T&gt; parent : nodes) &#123;</span><br><span class="line">                Long id = parent.getId();</span><br><span class="line">                <span class="keyword">if</span> (id != <span class="keyword">null</span> &amp;&amp; id.equals(pid)) &#123;</span><br><span class="line">                    <span class="comment">//说明是该节点是children的父节点</span></span><br><span class="line">                    children.setHasParent(<span class="keyword">true</span>);</span><br><span class="line">                    parent.setHasChildren(<span class="keyword">true</span>);</span><br><span class="line">                    parent.getChildren().add(children);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上代码：</p>
<ol>
<li>若<code>pid</code>是null或0就代表父节点，直接封装到List集合中；</li>
<li>若<code>pid</code>不是null或0就代表子节点，则继续循环判断此子节点属于哪个父节点；</li>
<li>继2，循环整个<code>nodes</code>集合，若<code>id</code>等于了<code>pid</code>就说明此<code>id</code>对应的节点是当前查询的父节点。</li>
</ol>
<h3 id="结"><a href="#结" class="headerlink" title="结"></a>结</h3><p>以上代码就实现了构建前端资源菜单的Tree集合。代码仅用来举例，以实际项目需求为准。</p>
<h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p><strong>强调：</strong><br>本项目中前端主要用了三个技术：<code>vue.js</code>, <code>vue-menu.js</code>, <code>element-ui</code>。
But，这并不是一个前后端分离的项目，半分离而已。因此前端仅仅用<code>&lt;script&gt;</code>标签引入了<code>vue.js</code>和<code>vue-menu.js</code>以及<code>elementui.js</code>。所以能看到前端都是HTML页面，并不是<code>.vue</code>的组件。</p>
<h3 id="用户登录"><a href="#用户登录" class="headerlink" title="用户登录"></a>用户登录</h3><p>按照正常的逻辑，在<code>login.html</code>直接给出一个登录表单即可：</p>
<p><img src="/2019/01/30/ssm/shiro/shiro-tree/1.png" alt></p>
<p>(关于Shiro生成验证码的例子之后再讲)</p>
<p>如果登录的<code>username</code>和<code>password</code>与数据库中的匹配就登录成功，跳转到<code>index</code>主页面。</p>
<h4 id="关于获取用户信息"><a href="#关于获取用户信息" class="headerlink" title="关于获取用户信息"></a>关于获取用户信息</h4><p>因为整个项目哪个页面都需要用户信息（比如在<code>header</code>上展示用户名和头像），所以我们可以在登录成功后立即发送请求获取当前登录用户信息，如：</p>
<p><img src="/2019/01/30/ssm/shiro/shiro-tree/2.png" alt></p>
<p>上图中登录成功后获取用户信息，此时我们可以调用<code>window.localStorage.setItem(key, value)</code>将用户信息储存到浏览器的<code>localStorage</code>中（<code>setItem</code>的value值是String类型，直接存入对象是不行的，调用<code>JSON.stringify()</code>将JSON对象转换为JSON字符串存入）。<br>如何获取呢？在其他任意页面，调用<code>JSON.parse(window.localStorage.getItem(&quot;info&quot;))</code>便能获取到此JSON对象，如：</p>
<p><img src="/2019/01/30/ssm/shiro/shiro-tree/3.png" alt></p>
<p>当然这可能不适合你，也可能不是好的方式，但我这里就先介绍这种方式。关于浏览器的<code>Cookie</code>, <code>localStorage</code>, <code>sessionStorage</code>的生命周期：</p>
<table>
<thead>
<tr>
<th>储存</th>
<th>生命周期</th>
</tr>
</thead>
<tbody><tr>
<td>cookie</td>
<td>没有设置 expires 选项时，cookie 的生命周期仅限于当前会话中，关闭浏览器意味着这次会话的结束，所以会话 cookie 仅存在于浏览器打开状态之下。 这就是为什么当你登录一个 Web 应用时经常会看到一个复选框，询问你是否记住登录信息：如果你勾选了复选框，那么一个 expires 选项会被附加到登录 cookie 中。</td>
</tr>
<tr>
<td>localStorage</td>
<td>生命周期是永久，这意味着除非用户显性的清除浏览器的localStorage信息，否则这些信息将永远存在。</td>
</tr>
<tr>
<td>sessionStorage</td>
<td>生命周期为当前窗口或标签页，一旦窗口或标签页被永久关闭了，那么所有通过sessionStorage存储的数据也就被清空了。</td>
</tr>
</tbody></table>
<p>参考博文：<a href="https://www.cnblogs.com/cag2050/p/8214726.html" target="_blank" rel="noopener">cookie、localStorage、sessionStorage 的生命周期</a></p>
<h4 id="关于Token"><a href="#关于Token" class="headerlink" title="关于Token"></a>关于Token</h4><p>如果你看过我的这篇文章：<a href="https://www.tycoding.cn/2019/01/25/boot/springboot-shiro/#more">在基于SpringBoot的前后端分离项目中使用Shiro</a> 你可能会好奇在传统的（前后端不分离）项目中，为什么不需要每次请求时都在请求头<code>Request Headers</code>中添加<code>X-Token</code>呢？</p>
<p>那么来看一下<code>/user/info</code>这个请求的头信息：</p>
<p><img src="/2019/01/30/ssm/shiro/shiro-tree/4.png" alt></p>
<p>很容易发现，<code>Request Headers</code>中有一个<code>Cookie</code>，他的值正是Shiro拦截请求跳转到<code>loginUrl</code>时生成sessionId。那么每次每次请求，请求头都会自动携带这个Cookie并发送到后端Shiro。</p>
<p>当Shiro经过<code>SessionManager</code>时，发现请求头的Cookie中包含了<code>JSESSIONID</code>值，Shiro就视为这个请求是经过验证的，Shiro的<code>DefaultWebSessionManager</code>:</p>
<p><img src="/2019/01/30/ssm/shiro/shiro-tree/5.png" alt></p>
<p>所以，在编写<code>ShiroConfig.java</code>配置时，<code>SessionManager</code>并不需要再单独使用自己的<code>MySessionManager</code>，直接用Shiro的<code>DefaultWenSessionManager</code>即可，他会自动获取请求头Cookie中<code>JSESSIONID</code>的值进行校验。</p>
<h3 id="渲染Tree菜单"><a href="#渲染Tree菜单" class="headerlink" title="渲染Tree菜单"></a>渲染Tree菜单</h3><p>比如，在请求后端获得的tree树是这种数据结构：</p>
<p><img src="/2019/01/30/ssm/shiro/shiro-tree/6.png" alt></p>
<p>那么前端仅需要直接遍历这个数组，根层索引标识根节点，其下的children数组索引标识其根节点的子节点。最终的效果如图：</p>
<p><img src="/2019/01/30/ssm/shiro/shiro-tree/7.png" alt></p>
<p>实现代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-menu</span> <span class="attr">unique-opened</span> <span class="attr">:default-active</span>=<span class="string">"defaultActive"</span> <span class="attr">:collapse</span>=<span class="string">"!sidebarStatus"</span> <span class="attr">background-color</span>=<span class="string">"rgb(48, 65, 86)"</span> <span class="attr">text-color</span>=<span class="string">"#fff"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-submenu</span> <span class="attr">v-for</span>=<span class="string">"(parent, topIndex) in tree"</span> <span class="attr">:key</span>=<span class="string">"topIndex + 1"</span> <span class="attr">:index</span>=<span class="string">"'' + topIndex + 1"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">"title"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-list fa-fw"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;parent.name&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-menu-item-group</span> <span class="attr">v-for</span>=<span class="string">"(child, index) in parent.children"</span> <span class="attr">:key</span>=<span class="string">"index + 1"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">"child.url"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">el-menu-item</span> <span class="attr">:index</span>=<span class="string">"child.name"</span>&gt;</span>&#123;&#123;child.name&#125;&#125;<span class="tag">&lt;/<span class="name">el-menu-item</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">el-menu-item-group</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-submenu</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-menu</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>主要就是按照后端Tree树的结构遍历前端Tree菜单，菜单名称为Tree树的name值。其中要<strong>注意</strong>，<code>&lt;el-menu-item&gt;</code>中有一个<code>index</code>属性，若<code>&lt;el-menu&gt;</code>中的<code>default-active</code>值等于这个<code>index</code>值，那么这个节点就被选中，所以我们设置其为<code>name</code>的值。<br>比如进入到用户管理页面，设置<code>defaultActive: &#39;用户管理&#39;</code>，那么此节点就将被选中，实现了激活的效果：</p>
<p><img src="/2019/01/30/ssm/shiro/shiro-tree/8.png" alt></p>
<h4 id="关于Tree"><a href="#关于Tree" class="headerlink" title="关于Tree"></a>关于Tree</h4><p>经过上面的步骤，前端已经渲染了Tree菜单，因为每个页面都需要左侧的这个Tree菜单导航，所以，我们也可以将tree数据储存到浏览器的<code>localStorage</code>中，这样进入其他页面，直接调用<code>JSON.parse(window.localStorage.getItem(&quot;tree&quot;))</code>就能获取到Tree树结构。</p>
<p>但是这种方式可能并不好，因为项目中可能涉及修改菜单的名称、图标的修改等，那么在修改的时候就必须考虑更新localStorage中的tree数据。所以呢，我们也可以单独在页面渲染时就请求这个tree列表数据。弊端就是每个页面都要定义这个请求。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">created() &#123;</span><br><span class="line">    <span class="comment">//获取Tree</span></span><br><span class="line">    <span class="keyword">this</span>.$http.get(api.common.tree(<span class="keyword">this</span>.info.username)).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> $<span class="keyword">this</span> = response.body;</span><br><span class="line">        <span class="keyword">if</span> ($<span class="keyword">this</span>.code == <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.tree = $<span class="keyword">this</span>.data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注</strong></p>
<p>前面说了浏览器的<code>localStorage</code>数据生命周期是永久的，那就造成当前用户退出系统后，换另一个用户名登录，<code>localStorage</code>中还是原先用户的信息，所以我们可以在登录页先清空浏览器的<code>localStorage</code>再登录系统。</p>
<p>实现代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">created() &#123;</span><br><span class="line">    if (window.localStorage.getItem("info") != null) &#123;</span><br><span class="line">        //如果浏览器localStorage中储存了用户信息，就先清空浏览器localStorage</span><br><span class="line">        window.localStorage.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<br>

<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <categories>
        <category>shiro</category>
      </categories>
      <tags>
        <tag>shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>（七）在基于SpringBoot的前后端分离项目中使用Shiro</title>
    <url>/2019/01/25/boot/springboot-shiro/</url>
    <content><![CDATA[<h1 id="SpringBoot-Shiro-Vue-JS"><a href="#SpringBoot-Shiro-Vue-JS" class="headerlink" title="SpringBoot + Shiro + Vue.JS"></a>SpringBoot + Shiro + Vue.JS</h1><p>:tada: :tada: :tada: <strong>这里有丰富的 Spring 框架学习案例</strong></p>
<p><strong>仓库地址：<a href="https://github.com/TyCoding/spring-learn" target="_blank" rel="noopener">spring-learn</a></strong><br><strong>欢迎star、fork，给作者一些鼓励</strong></p>
<p><strong>Shiro-Session</strong></p>
<p>Shiro提供<em>会话</em>管理实现用户于应用之间保持连接关系，在多次交互中能够识别当前访问的用户是谁，而这些会话信息由<code>SessionManager</code>管理。</p>
<h2 id="springboot-shiro-vue"><a href="#springboot-shiro-vue" class="headerlink" title="springboot+shiro+vue"></a>springboot+shiro+vue</h2><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><p>首先我简易的画一张登录校验的流程图：</p>
<p><img src="/2019/01/25/boot/springboot-shiro/1.png" alt></p>
<a id="more"></a>

<h4 id="Shiro-Config"><a href="#Shiro-Config" class="headerlink" title="Shiro Config"></a>Shiro Config</h4><p>在前后端分离项目中，后端使用SpringBoot+Shiro，前端使用Vue.js；所有的请求都是通过ajax，如果我们要维持Shiro会话状态，就应该保证每次请求的<code>SessionId</code>都相同。</p>
<p>按照之前的方式，我这样写Shiro的配置文件<code>ShiroConfig.java</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShiroConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ShiroFilterFactoryBean <span class="title">shiroFilterFactoryBean</span><span class="params">(SecurityManager securityManager)</span> </span>&#123;</span><br><span class="line">        ShiroFilterFactoryBean shiroFilterFactoryBean = <span class="keyword">new</span> ShiroFilterFactoryBean();</span><br><span class="line">        shiroFilterFactoryBean.setSecurityManager(securityManager);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//配置拦截器链，注意顺序</span></span><br><span class="line">        Map&lt;String, String&gt; filterChainDefinitionMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">"/logout"</span>, <span class="string">"logout"</span>);</span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">"/login"</span>, <span class="string">"anon"</span>);</span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">"/**"</span>, <span class="string">"user"</span>);</span><br><span class="line"></span><br><span class="line">        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);</span><br><span class="line">        <span class="keyword">return</span> shiroFilterFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Realm <span class="title">realm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AuthRealm();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SecurityManager <span class="title">securityManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultWebSecurityManager securityManager = <span class="keyword">new</span> DefaultWebSecurityManager();</span><br><span class="line">        securityManager.setRealm(realm());</span><br><span class="line"></span><br><span class="line">        securityManager.setSessionManager(sessionManager());</span><br><span class="line">        securityManager.setCacheManager(cacheManager());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> securityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SessionManager <span class="title">sessionManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultWebSessionManager defaultWebSessionManager = <span class="keyword">new</span> DefaultWebSessionManager();</span><br><span class="line">        defaultWebSessionManager.setGlobalSessionTimeout(<span class="number">1800000</span>);</span><br><span class="line">        defaultWebSessionManager.setSessionIdCookieEnabled(<span class="keyword">true</span>);</span><br><span class="line">        defaultWebSessionManager.setSessionIdCookie(simpleCookie());</span><br><span class="line">        defaultWebSessionManager.setCacheManager(cacheManager());</span><br><span class="line">        defaultWebSessionManager.setSessionIdUrlRewritingEnabled(<span class="keyword">true</span>);</span><br><span class="line">        defaultWebSessionManager.setSessionDAO(sessionDAO());</span><br><span class="line">        <span class="keyword">return</span> defaultWebSessionManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SessionDAO <span class="title">sessionDAO</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EnterpriseCacheSessionDAO sessionDAO = <span class="keyword">new</span> EnterpriseCacheSessionDAO();</span><br><span class="line">        sessionDAO.setActiveSessionsCacheName(<span class="string">"shiro-activeSessionCache"</span>);</span><br><span class="line">        sessionDAO.setSessionIdGenerator(<span class="keyword">new</span> JavaUuidSessionIdGenerator());</span><br><span class="line">        <span class="keyword">return</span> sessionDAO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleCookie <span class="title">simpleCookie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SimpleCookie simpleCookie = <span class="keyword">new</span> SimpleCookie();</span><br><span class="line">        simpleCookie.setName(<span class="string">"cn.tycoding.id"</span>);</span><br><span class="line">        simpleCookie.setHttpOnly(<span class="keyword">true</span>);</span><br><span class="line">        simpleCookie.setMaxAge(<span class="number">180000</span>);</span><br><span class="line">        <span class="keyword">return</span> simpleCookie;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Shiro本身只提供了Cahche缓存的接口，并不提供实现类。EhCacheManager是Shiro-Cache的一个实现类</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EhCacheManager cacheManager = <span class="keyword">new</span> EhCacheManager();</span><br><span class="line">        cacheManager.setCacheManagerConfigFile(<span class="string">"classpath:config/shiro-ehcache.xml"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EhCacheManager();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为使用<code>EhCache</code>做缓存，我们需要引入<code>EhCache</code>的pom依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>按照上面的方式，我们还需要定义<code>EhCache</code>缓存的配置文件：<code>shiro-ehcache.xml</code></p>
<p><img src="/2019/01/25/boot/springboot-shiro/2.png" alt></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ehcache</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">defaultCache</span></span></span><br><span class="line"><span class="tag">            <span class="attr">maxElementsInMemory</span>=<span class="string">"10000"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">eternal</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">timeToIdleSeconds</span>=<span class="string">"120"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">timeToLiveSeconds</span>=<span class="string">"120"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">overflowToDisk</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">diskPersistent</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">diskExpiryThreadIntervalSeconds</span>=<span class="string">"120"</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 登录记录缓存锁定10分钟 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span> <span class="attr">name</span>=<span class="string">"passwordRetryCache"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">maxEntriesLocalHeap</span>=<span class="string">"2000"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">eternal</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">timeToIdleSeconds</span>=<span class="string">"3600"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">timeToLiveSeconds</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">overflowToDisk</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">statistics</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="LoginController"><a href="#LoginController" class="headerlink" title="LoginController"></a>LoginController</h4><p>在上面已经介绍了，如果用户登录成功，后端应该返回给前端一个<code>Token</code>值，于是，这个<code>Token</code>值应该是Shiro生成的<code>sessionId</code>，那么我们在<code>LoginController.java</code>中这样定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/login"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseCode <span class="title">login</span><span class="params">(@RequestParam(<span class="string">"username"</span>)</span> String username,</span></span><br><span class="line"><span class="function">                          @<span class="title">RequestParam</span><span class="params">(<span class="string">"password"</span>)</span> String password) </span>&#123;</span><br><span class="line">    UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(username, password);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        <span class="keyword">if</span> (subject != <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.info(<span class="string">"subject==&gt;&#123;&#125;"</span>, subject);</span><br><span class="line">            subject.logout();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.login(token);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseCode(StatusEnums.SUCCESS, subject.getSession().getId());</span><br><span class="line">    &#125; </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/logout"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseCode <span class="title">logout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    getSubject().logout();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ResponseCode(StatusEnums.SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p>上面介绍了后端接口设计，这里我们看一下前端ajax的请求格式和后端的响应数据：</p>
<p><strong>login</strong></p>
<p><img src="/2019/01/25/boot/springboot-shiro/3.png" alt></p>
<p>响应数据：</p>
<p><img src="/2019/01/25/boot/springboot-shiro/4.png" alt></p>
<br>

<p><strong>登录后的ajax请求</strong></p>
<p><img src="/2019/01/25/boot/springboot-shiro/5.png" alt></p>
<p>你会发现上面的请求竟然是<code>302</code>重定向了，也就是说这个请求被Shiro拦截了，而我们在上上图中已经登过了啊，为什么还会被Shiro拦截呢？(记得之前配置了自定义拦截器链<code>/** = user</code>)。</p>
<p>紧接着你会发现浏览器会跳转到另一个请求地址：</p>
<p><img src="/2019/01/25/boot/springboot-shiro/6.png" alt></p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>为什么会自动跳转到<code>http://127.0.0.1:8080/login.jsp;JSESSIONID=XX</code>这个地址？</p>
<ul>
<li>因为我们自定义配置的拦截器链<code>/** user</code>拦截了这个请求，Shiro默认将拦截的请求都跳转到loginUrl地址（默认是<code>login.jsp</code>）。</li>
</ul>
<p>为什么302重定向后的地址还携带了<code>JSESSIONID</code>？</p>
<ul>
<li>Shiro在用户登录后会生成Session信息，SessionId就是这个Session的标识key。也就是Shiro在执行自定义拦截器链的时候判断到新的请求（产生）的sessionId和系统已缓存的sessionId不同，所以Shiro判断这个请求是未登录不合法请求，所以被拦截并重定向到loginUrl地址。</li>
</ul>
<p>为什么重定向后的请求是404？</p>
<ul>
<li>这个很显然了，因为根本没有这个地址，我们采用的前后端分离开发，前端用的Vue(Node.JS)和后端页面完全不一回事。</li>
</ul>
<h2 id="思考-1"><a href="#思考-1" class="headerlink" title="思考"></a>思考</h2><p>因为采用了SpringBoot + vue的前后端分离的开发模式，前端与后端都通过ajax的方式进行交互。</p>
<p>那么可以看到，后端通过<code>SecurityUtils.getSubject().getSession().getId()</code>获取到的SessionId和登录时已经返回给前端的SessionId(Token)是不同的。也就是你会发现，每次请求都产生一个全新的SessionId，导致Shiro认为你新的请求在已有的Session中没有查询到登录状态而拦截。</p>
<p>（Shiro的<code>sessionId</code>是通过<code>org.apache.shiro.session.mgt.eis.JavaUuidSessionIdGenerator</code>生成的随机值。）</p>
<p>为了保证用户登录后的请求都应该被Shiro识别为已登录用户的请求，我们应该保证前端每次请求都在请求头中定义一个参数值为后端传来的SessionId(Token)，这部分前端以实现了，看下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">service.interceptors.request.use(</span><br><span class="line">  config =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (store.getters.token) &#123;</span><br><span class="line">      config.headers[<span class="string">'X-Token'</span>] = getToken() <span class="comment">// 让每个请求携带自定义token 请根据实际情况自行修改</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用<code>Vuex</code>技术，会将用户已登录的Token信息写入全局store中，这样前端每次的<code>axios</code>请求的<code>Request Headers</code>中都将包含<code>X-Token</code>这个属性，其值是后端返回的sessionId。</p>
<p><img src="/2019/01/25/boot/springboot-shiro/7.png" alt></p>
<p>那么后端应该如何接收呢？</p>
<h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>为了保证前端的每次请求都是已登录用户的请求，后端应该接收<code>Request Headers</code>中<code>X-Token</code>的值，并以它作为sessionId让Shiro去验证用户的请求。</p>
<p>因为Shiro的<code>Session</code>由管理器<code>org.apache.shiro.session.mgt.SessionManager</code>进行统一管理，所以应该修改其的sessionId值，又因为<code>SessionManager</code>只是一个接口，通常用它的<code>DefaultWebSessionManager</code>实现类来管理Session，所以我们改造一下<code>DefaultWebSessionManager</code>即可：</p>
<p>新建<code>MySessionManager.java</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySessionManager</span> <span class="keyword">extends</span> <span class="title">DefaultWebSessionManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTHORIZATION = <span class="string">"X-Token"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REFERENCED_SESSION_ID_SOURCE = <span class="string">"Stateless request"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MySessionManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Serializable <span class="title">getSessionId</span><span class="params">(ServletRequest request, ServletResponse response)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"==&gt; already to MySessionManager"</span>);</span><br><span class="line">        <span class="comment">//获取请求头中X-Token中保存的sessionId</span></span><br><span class="line">        String id = WebUtils.toHttp(request).getHeader(AUTHORIZATION);</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.isEmpty(id)) &#123;</span><br><span class="line">            request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_SOURCE, REFERENCED_SESSION_ID_SOURCE);</span><br><span class="line">            request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID, id);</span><br><span class="line">            request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_IS_VALID, Boolean.TRUE);</span><br><span class="line">            <span class="keyword">return</span> id;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则默认从cookie中获取sessionId</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.getSessionId(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样每次请求都被<code>MySessionManager</code>拦截到，并通过<code>getHeader(AUTHORIZATION)</code>获取到请求头<code>Request Headers</code>中的<code>X-Token</code>信息并将其设置为<code>SESSION_ID</code>。这样就保证了每次请求的<code>sessionId</code>和已登录用户的<code>sessionId</code>相同了，Shiro就不会拦截这些请求了。</p>
<p><strong>如何使用呢？</strong></p>
<p>在<code>ShiroConfig.java</code>配置文件中将<code>SecurityManager</code>中注入的<code>SessionManager</code>改为自定义的<code>MySessionManager</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义SessionManager</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SessionManager <span class="title">sessionManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MySessionManager mySessionManager = <span class="keyword">new</span> MySessionManager();</span><br><span class="line">    mySessionManager.setCacheManager(cacheManager());</span><br><span class="line">    mySessionManager.setSessionIdUrlRewritingEnabled(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> mySessionManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，再次请求接口：</p>
<p><img src="/2019/01/25/boot/springboot-shiro/7.png" alt></p>
<p><img src="/2019/01/25/boot/springboot-shiro/8.png" alt></p>
<p>就解决了Shiro重定向的问题了。</p>
<h2 id="Shiro使用Redis做缓存"><a href="#Shiro使用Redis做缓存" class="headerlink" title="Shiro使用Redis做缓存"></a>Shiro使用Redis做缓存</h2><p>上面我们使用了<code>EhCache</code>作为缓存，那么我们也可整合Redis，把Shiro的缓存信息储存到Redis中。</p>
<p>使用<a href="https://gitee.com/iherus/shiro-redis" target="_blank" rel="noopener">shiro-redis</a>开源插件，导入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.crazycake<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.2.1-RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>修改配置文件</strong></p>
<ul>
<li><p><code>org.apache.shiro.cache.CacheManager</code> – <code>org.crazycake.shiro.RedisCacheManager</code></p>
</li>
<li><p><code>org.apache.shiro.session.mgt.eis.SessionDAO</code> – <code>org.crazycake.shiro.RedisSessionDAO</code></p>
</li>
<li><p><code>org.apache.shiro.cache.CacheManager</code> – <code>org.crazycake.shiro.RedisCacheManager</code></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用shiro-redis配置</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"redis.shiro"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisManager <span class="title">redisManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RedisManager();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * redis实现缓存</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisCacheManager <span class="title">cacheManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RedisCacheManager redisCacheManager = <span class="keyword">new</span> RedisCacheManager();</span><br><span class="line">    redisCacheManager.setRedisManager(redisManager());</span><br><span class="line">    <span class="keyword">return</span> redisCacheManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Redis实现 shiro sessionDao</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisSessionDAO <span class="title">redisSessionDAO</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RedisSessionDAO redisSessionDAO = <span class="keyword">new</span> RedisSessionDAO();</span><br><span class="line">    redisSessionDAO.setRedisManager(redisManager());</span><br><span class="line">    <span class="keyword">return</span> redisSessionDAO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>修改<code>application.yml</code>，添加：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">redis:</span><br><span class="line">  shiro:</span><br><span class="line">    host: 127.0.0.1</span><br><span class="line">    port: 6379</span><br><span class="line">    timeout: 0</span><br><span class="line">    password:</span><br></pre></td></tr></table></figure>

<p>至此，Shiro-Redis的配置已完成，下面，需要在本地电脑上安装Redis（同时可以选择安装操作Redis的可视化工具）。<br>可以参考这篇教程：<a href="https://tycoding.cn/2018/09/24/other/redis/#more" target="_blank" rel="noopener">Redis及Spring-Data-Redis</a></p>
<p>先启动本地Redis服务，再启动项目，登录系统，发现Redis数据库中就缓存了登录的<code>session</code>数据：</p>
<p><img src="/2019/01/25/boot/springboot-shiro/9.png" alt></p>
<br>

<p>上述是我个人在整合SpringBoot+Shiro+VueJS过程中遇到的问题，并（收集）整理的解决办法。</p>
<p>由于本人菜鸡，可能分析的有错误，欢迎大佬指出。</p>
<br>

<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <categories>
        <category>shiro</category>
      </categories>
      <tags>
        <tag>shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>算法学习之各种排序算法（一）</title>
    <url>/2019/01/08/java/algorithm-sort-1/</url>
    <content><![CDATA[<h1 id="算法学习"><a href="#算法学习" class="headerlink" title="算法学习"></a>算法学习</h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>算法有时间和空间的<strong>复杂度</strong>，这是可以衡量的。<strong>时间复杂度</strong>–运行它花了多少时间；<strong>空间复杂度</strong>–运行它需要多少内存。</p>
<p><strong>常数时间</strong>操作：一个操作如果和数据量没有关系，每次都是固定时间内完成的操作，叫做<strong>常数操作</strong>。常数时间的操作记为<strong>O(1)</strong></p>
<h3 id="大-O-表示"><a href="#大-O-表示" class="headerlink" title="大 O 表示"></a>大 O 表示</h3><p>比如我们称算法 B 有与n<sup>2</sup>成比例的时间需求，我们说B是 <strong>O(n<sup>2</sup>)</strong>的(读作big O(n<sup>2</sup>))</p>
<p>具体而言，在<strong>常数操作</strong>数量的表达式中，<strong>只要高阶项，不要低阶项，也不要高阶项的系数，剩下的部分若记为f(N)，那么在</strong>最差<strong>情况下，算法流程的指标（</strong>时间复杂度**）为 O(f(N))。</p>
<p>比如符合 aN<sup>2</sup> + bN + C 操作的事件复杂度就是 <strong>O(n<sup>2</sup>)</strong></p>
<a id="more"></a>

<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>遍历算法：</strong></p>
<p>比如有 1,2,3,4,5  这几个数，我们需要遍历得到这些数，那么每次遍历的时间复杂度称为<strong>O(N)</strong>的话，那么一共有M个数，就称遍历算法的事件复杂度是: O(M * N)。（区分 O(1) 表示常数操作，这里的 O(N) 表示时间复杂度）。</p>
<p><strong>二分查找算法</strong></p>
<p>比如有 1,2,3,4,5  二分查找算法，就是实现将已有数列分为Right Left 两列（不一定相等），然后依次从Right、Left中查找，如果找到了就不用找另一侧（比如在Right中查找，再将Right分为right left两列进行查找）。这种算法比遍历算法要简单。</p>
<p>那么因为每次查找都是先将数列分为两列，再进行查找，那么一个数列一共可以分 <strong>logN</strong> 次，所以二分查找算法的事件复杂度就是 log(M*logN)</p>
<h2 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h2><p>当解决一个问题的时候，将它划分为更小的问题且用相同的方法进行解决。这种特殊的处理称为<strong>递归</strong>。递归的关键是：最终你能到达一个较小的问题，且这个小问题是很容易解决的。</p>
<p>故：<strong>调用自己的方法称为递归方法</strong>。调用是递归调用。</p>
<p>设计一个递归方案，应该考虑哪些问题？</p>
<ol>
<li>方案的那个部分的工作能让你直接完成？</li>
<li>哪些较小问题已经有了解决方案。</li>
<li>该递归过程何时结束？</li>
</ol>
<p>若递归方法没有设计<strong>终止情形</strong>，将<strong>永远执行</strong>，这种情形称为<strong>无穷</strong>递归。</p>
<p>总结来说：<strong>递归函数</strong>就是自己调用自己的函数。系统帮你压栈，将<strong>当前</strong>函数的所有信息储存到栈内存中，当调用<strong>子过程</strong>时，只储存每次子过程调用具体的变量值。若递归结束，调用栈顶的函数信息并还原函数的原始状态。</p>
<h3 id="跟踪递归方法"><a href="#跟踪递归方法" class="headerlink" title="跟踪递归方法"></a>跟踪递归方法</h3><p>通常而言，跟中一个递归算法过程是比较复杂的，如果你按照一定的准则设计递归方法，一般是无需跟踪它们。这里我一个<strong>倒计时</strong>递归举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_Recursive</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">(<span class="keyword">int</span> integer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (integer &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(integer);</span><br><span class="line">            countDown(integer - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        countDown(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这将打印出来3、2、1 倒计时数字，使用的正是递归的方法。它符合了以下设计准则：</p>
<ol>
<li>这个倒计时打印（显示）的工作是可以直接完成的。</li>
<li>该递归方法最终是化小为打印一个数字，这是可以直接 sys 解决的。</li>
<li>该递归方法执行到integer参数为1时就结束递归。</li>
</ol>
<p><strong>实现过程</strong></p>
<p><img src="/2019/01/08/java/algorithm-sort-1/recursive.png" alt></p>
<p>可以看到，图中是countDown(3)的递归调用过程，其中出现了多个countDown方法的副本，但其实我们就写了一个递归方法。</p>
<p>也就是说对方法的每次调用（递归或非递归）Java都记录方法执行的当前状态，包含它的参数和局部变量的值，以及当前指令的位置。每个记录称为一个活动记录，它提供运行期间方法状态的快照。记录放入程序栈中。栈按照时间先后组织这些记录，所以当前正在执行的方法的记录位于栈顶。Java可以暂停递归方法的运行，并用新的变量值再次调用它。</p>
<h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p><strong>master公式</strong></p>
<p><img src="/2019/01/08/java/algorithm-sort-1/master.png" alt></p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>时间复杂度：O(N<sup>2<sup> )</sup></sup></p>
<p>在一个一维数组中，冒泡排序就是实现数组中相邻两个索引位置值的大小比较，若条件符合就不动，如果条件不符合就将两个索引位置的值进行交换。且外层循环决定了外层一共需要循环多少次，且决定了外层循环一次内层需要循环多少次，外层一次循环才能排序好一个值（最大最小），下次循环就忽略掉这个极值从剩余的数据中得出极值，然后依次这样。</p>
<p><img src="/2019/01/08/java/algorithm-sort-1/bubble.png" alt></p>
<p>实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_00_BubbleSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span> || arr == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">        bubbleSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中我们对数组<code>arr[3,2,0,7,4]</code>进行从大到小的排序，在<code>bubbleSort</code>方法中，外层循环<code>arr.length-1</code>次，内层每次循环<code>arr.length-1</code>次。</p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>时间复杂度：O(N<sup>2</sup>)</p>
<p>选择排序，首先我们需要一个minIndex，记录最小值，然后将当前索引位置的值与后面索引位置的值依次比较,如果符合条件，就将此索引赋值给minIndex，再进行交换值（因为此时极限值minIndex改变了）。<br>可以看到这种方式比上面的冒泡排序简单很多。</p>
<p><img src="/2019/01/08/java/algorithm-sort-1/selection.png" alt></p>
<p>实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_01_SelectionSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span> || arr == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> minIndex = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(arr, i, minIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">        selectionSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="递归选择排序"><a href="#递归选择排序" class="headerlink" title="递归选择排序"></a>递归选择排序</h2><p>时间复杂度：O(N<sup>2</sup>)</p>
<p>根据前面讲到的递归算法的设计，我们首先要明白：</p>
<ol>
<li>递归方案的哪些工作是可以直接完成的？1.动态替换minIndex的值；2.交换minIndex和当前索引；</li>
<li>递归化到最小问题是什么？得到一个索引比minIndex索引对应的值要小，替换minIndex，并进行swap操作。</li>
<li>递归何时结束？当循环到索引值和arr.length相等就停止递归。</li>
</ol>
<p>带着上面的思考问题，我们可以进行如下设计</p>
<p><img src="/2019/01/08/java/algorithm-sort-1/recursive_selection.png" alt></p>
<p>想要通过递归实现选择排序，要知道<strong>递归</strong>是重复调用自己的过程。那么：</p>
<ul>
<li><p>首先你把<code>sort</code>函数理解为一个外层圈子，而其中的<code>for()</code>循环是内层的圈子，内层的圈子循环完毕一次（n~arr.length），就得到一个最小值。</p>
</li>
<li><p>需要规定<strong>minIndex</strong>记录最小值的索引位置，这个值和外层的圈子有关，如果排序好的最小值不用管，直接从外层圈子范围开始循环内层圈子，所以定义<code>for(int i=n)</code>。</p>
</li>
<li><p>如果满足内层圈子循环中<code>arr[minIndex] &gt; arr[i]</code>说明此索引值比当前的minIndex还要小，那么就替换minIndex。</p>
</li>
<li><p>内层圈子每<strong>完全循环完毕</strong>（n~arr.length），就<code>swap</code>替换对应索引位置的值。</p>
</li>
<li><p>最后，因<code>sort(arr, n + 1)</code>，当<code>n+1</code>等于<code>arr.length</code>，就停止递归。</p>
</li>
</ul>
<p>实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_01_Recursive_SelectionSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex = n;</span><br><span class="line">        <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span> || arr == <span class="keyword">null</span> || n &gt;= arr.length) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[minIndex] &gt; arr[i]) &#123;</span><br><span class="line">                minIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, n, minIndex);</span><br><span class="line">        sort(arr, n + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">        sort(arr, <span class="number">0</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>时间复杂度：O(N<sup>2</sup>)</p>
<p>从无需集合的1位置开始，比较其0<del>1位置的值，如比较0</del>1、2<del>0、3</del>0、4~0… 相当于整体是根据一个有序集合（索引），将无序集合（要排序的集合）往有序集合的区间中插入。</p>
<p><img src="/2019/01/08/java/algorithm-sort-1/insertion.png" alt></p>
<p>实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_02_InsertionSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span> || arr == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; arr[j + <span class="number">1</span>]; j--) &#123;</span><br><span class="line">                System.out.println(<span class="string">"arr["</span> + j + <span class="string">"], arr["</span> + (j + <span class="number">1</span>) + <span class="string">"]"</span>);</span><br><span class="line">                swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">        insertionSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="递归插入排序"><a href="#递归插入排序" class="headerlink" title="递归插入排序"></a>递归插入排序</h2><p>实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_02_Recursive_InsertionSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length &lt; <span class="number">2</span> || arr == <span class="keyword">null</span> || n &gt;= arr.length) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; arr[j + <span class="number">1</span>]; j--) &#123;</span><br><span class="line">                swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(arr, n + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">        sort(arr, <span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>tumo-vue</title>
    <url>/2019/01/03/project/tumo-vue/</url>
    <content><![CDATA[<h1 id="Tumo-Blog"><a href="#Tumo-Blog" class="headerlink" title="Tumo Blog"></a>Tumo Blog</h1><p><img src="http://cdn.tycoding.cn/tumo.png" alt></p>
<p><strong>Tumo Blog -vue</strong> 一个基于vue组件、SpringBoot2开发的前后端分离的博客项目，简约的设计希望你能喜欢。欢迎提出建议、star、fork 给作者一些鼓励。</p>
<p>基于HTML、Thymeleaf版本的请看：<a href="https://github.com/TyCoding/tumo" target="_blank" rel="noopener">tumo</a></p>
<p>项目地址：<a href="https://github.com/TyCoding/tumo-vue" target="_blank" rel="noopener">https://github.com/TyCoding/tumo-vue</a></p>
<a id="more"></a>

<p><strong>Tumo Blog</strong>之前后端完全分离的版本，前端分为<code>vue</code> 和 <code>angular</code> 两个版本。</p>
<p>如果你正在学习前后端分离开发，这将是个不错的练手项目。</p>
<p><a href="https://github.com/TyCoding/tumo" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/SpringBoot-v2.0.5.RELEASE-green.svg" alt="License"></a><br><a href="https://github.com/TyCoding/tumo" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/Vue.js-v2.x-blue.svg" alt="License"></a><br><a href="https://github.com/TyCoding/tumo" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/Mysql-v5.7.22-blue.svg" alt="License"></a><br><a href="https://github.com/PanJiaChen/vue-admin-template" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/VueAdminTemplate-v1.0-green.svg" alt="License"></a></p>
<p>演示地址：<a href="http://tumo-vue.tycoding.cn/" target="_blank" rel="noopener">tumo-vue.tycoding.cn</a></p>
<p>后台地址：<a href="http://tumo-vue.tycoding.cn/login" target="_blank" rel="noopener">tumo-vue.tycoding.cn/login</a></p>
<p>项目地址：<a href="https://github.com/TyCoding/tumo-vue" target="_blank" rel="noopener">https://github.com/TyCoding/tumo-vue</a></p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>简约的设计，漂亮的界面。</li>
<li>博客全站响应式设计。</li>
<li>博客管理后台支持国际化。</li>
<li>支持富文本、Markdown格式文章的撰写。</li>
<li>支持文件上传，下载。</li>
<li>支持七牛云对象储存服务器的管理（上传、下载、重命名）</li>
<li>支持网易云音乐插件。</li>
<li>项目基于vue实现前后端完全分离的开发模式。</li>
<li>项目基于SpringBoot-2.x框架开发。</li>
<li>更多功能正在开发中…</li>
</ul>
<p><strong>致谢</strong></p>
<p><strong>pinghsu</strong>: 博客的前台移植于<a href="https://github.com/chakhsu/pinghsu" target="_blank" rel="noopener">@pinghsu</a>主题</p>
<p><strong>vue版本</strong>: 基于 <a href="https://github.com/PanJiaChen/vue-admin-template" target="_blank" rel="noopener">ElementUI-admin-template</a> 开发</p>
<p><strong>ng版本</strong> 由 <a href="https://github.com/yutao331763646" target="_blank" rel="noopener">TuTao</a> 开发</p>
<h2 id="路由地址"><a href="#路由地址" class="headerlink" title="路由地址"></a>路由地址</h2><p><img src="http://cdn.tycoding.cn/tumo-vue-005.png" alt></p>
<h2 id="项目预览"><a href="#项目预览" class="headerlink" title="项目预览"></a>项目预览</h2><p><img src="http://cdn.tycoding.cn/tumo-vue-004.png" alt></p>
<p><img src="http://cdn.tycoding.cn/tumo-vue-003.png" alt></p>
<p><img src="http://cdn.tycoding.cn/tumo-vue-002.png" alt></p>
<p><img src="http://cdn.tycoding.cn/tumo-vue-001.png" alt></p>
<br>

<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>部署神器Docker</title>
    <url>/2018/11/28/cloud/docker/</url>
    <content><![CDATA[<p><img src="/2018/11/28/cloud/docker/logo.png" alt></p>
<p> <strong>Docker</strong>是一种容器技术，它的存在就是为了解决容器技术本身的复杂性。Docker容器拥有很高的性能，同时同一台宿主机中可以运行更多的容器，是用户尽可能的充分利用系统资源。</p>
<a id="more"></a>

<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><blockquote>
<p>1.什么是虚拟化？</p>
</blockquote>
<p>在计算机中，虚拟化（Virtualization）是一种资源管理技术，是将计算机的各种实体资源，如服务器、网络、内存及储存等，予以抽象、转换后呈现出来，打破实体结构间的不可切割的障碍，是用户可以比原来的组态更好的方式来应用这些资源。这些资源的新虚拟部分是不受现有资源的架设方式、地域或物理组态所限制。</p>
<ul>
<li>全虚拟化架构</li>
</ul>
<p>虚拟机的监视器（hypervisor）是类似于用户的应用程序运行在主机的OS之上，如VMware的workstation，这种虚拟化产品提供了虚拟的硬件。</p>
<blockquote>
<p>2.容器技术</p>
</blockquote>
<p>容器和管理程序虚拟化（hypervisor virtualization, HV）不同，管理程序虚拟化通过中间层将一台或多台独立的机器虚拟运行在物理硬件之上，而<strong>容器</strong>是直接运行在操作系统内核之上的用户空间。因此，容器虚拟化也被称为“操作系统级虚拟化”，容器技术可以让多个独立的用户空间运行在同一台宿主机上。</p>
<p><strong>限制</strong></p>
<ol>
<li>由于“客居”与操作系统，容器只能运行与底层主机相同或相似的操作系统，比如在Ubuntu服务中运行CentOS，但无法运行Windows。</li>
<li>相对于彻底隔离的管理程序虚拟化，容器被认为是不安全的。</li>
</ol>
<p>最新的容器技术引入了OpenVZ、Solaris Zones以及Linux容器（LXC）。使用这些新技术，容器不再仅仅是一个单纯的运行环境。在自己的权限类内，容器更像一个完整宿主机。和传统虚拟化及半虚拟化想比，容器不需要模拟层（emulation layer）和管理层（hypervisor layer），而使用操作系统的系统调用接口。</p>
<h2 id="Docker特点"><a href="#Docker特点" class="headerlink" title="Docker特点"></a>Docker特点</h2><ol>
<li>上手快</li>
</ol>
<p>用户可以很容易的把自己的程序Docker化。Docker依赖于“写时复制”（copy-on-write）模型，开箱即用。</p>
<ol start="2">
<li>快速高效的开发声明周期</li>
</ol>
<br>

<h2 id="Docker组件"><a href="#Docker组件" class="headerlink" title="Docker组件"></a>Docker组件</h2><h3 id="Docker客户端和服务器"><a href="#Docker客户端和服务器" class="headerlink" title="Docker客户端和服务器"></a>Docker客户端和服务器</h3><p>Docker是一个客户端-服务器（C/S）架构程序。Docker客户端只需要向Docker服务器或守护进程发出请求，服务器或守护进程将完成所有工作并返回结果。Docker提供了一个命令行工具Docker以及一整套RESTful API。你可以在同一台宿主机上运行Docker守护进程和客户端，也可以从本地的Docker客户端连接到运行在另一台宿主机上的远程Docker守护进程。</p>
<p><img src="/2018/11/28/cloud/docker/1.png" alt></p>
<h3 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h3><p><strong>镜像</strong> 是构建Docker的基石。用户及基于镜像来运行自己的容器。镜像也是Docker声明周期中的“构建”部分。奖项是基于联合文件系统的一种层式结构，由一系列指令一步一步构建出来。</p>
<h3 id="Registry-注册中心"><a href="#Registry-注册中心" class="headerlink" title="Registry 注册中心"></a>Registry 注册中心</h3><p>Docker用Registry来保存用户构建的镜像。Registry分为共有和私有两种。Docker公司运营公共的Registry叫做Docker Hub。</p>
<h3 id="Docker容器"><a href="#Docker容器" class="headerlink" title="Docker容器"></a>Docker容器</h3><p>Docker可以帮助你构建和部署容器，你只需要把你的程序打包放进容器即可。容器是基于镜像启动的，容器找那个可以运行一个或多个进程。我们可以认为，镜像是Docker生命周期中构建和打包阶段，而容器则是启动或执行阶段。容器基于镜像启动。</p>
<p><img src="/2018/11/28/cloud/docker/2.png" alt></p>
<br>

<h1 id="Docker的安装与启动"><a href="#Docker的安装与启动" class="headerlink" title="Docker的安装与启动"></a>Docker的安装与启动</h1><p>本例中使用了CentOS7作为服务器，有关VMware安装CentOS7的教程请看我的这篇文章：<a href="https://tycoding.cn/2018/08/29/ssm/fastdfs/" target="_blank" rel="noopener">FastDFS系统搭建</a> 。</p>
<p>通过以下命令在线在CentOS7中安装Docker：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install docker</span><br></pre></td></tr></table></figure>

<p><img src="/2018/11/28/cloud/docker/3.png" alt></p>
<p><strong>查看Docker版本</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker -v</span><br><span class="line">Docker version 1.13.1, build 8633870/1.13.1</span><br></pre></td></tr></table></figure>

<h2 id="启动与停止Docker"><a href="#启动与停止Docker" class="headerlink" title="启动与停止Docker"></a>启动与停止Docker</h2><p><code>systemctl</code>命令是系统服务管理器指令，它是<code>service</code>和<code>chkconfig</code>两个命令组合。</p>
<ol>
<li>启动Docker</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>停止Docker</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>重启Docker</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>查看Docker状态</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>开机启动Docker</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>查看Docker概要信息</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>查看Docker帮助文档</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker -help</span><br></pre></td></tr></table></figure>

<br>

<h2 id="Docker镜像操作"><a href="#Docker镜像操作" class="headerlink" title="Docker镜像操作"></a>Docker镜像操作</h2><p>Docker镜像由文件系统堆叠而成（是一种文件的储存形式）。最低端是一个文件引导系统，即bootfs。实际上，当一个容器启动后，它将会被移动到内存中，而引导文件系统则会被卸载，以留出更多的内存供磁盘镜像使用。Docker容器启动是需要一些文件的，而这些文件就可以被称为Docker镜像。</p>
<p><img src="/2018/11/28/cloud/docker/4.png" alt></p>
<ol>
<li>列出镜像</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker images</span><br></pre></td></tr></table></figure>

<p><img src="/2018/11/28/cloud/docker/5.png" alt></p>
<ul>
<li>REPOSITORY: 镜像所在的仓库名称</li>
<li>TAG： 镜像标签</li>
<li>IMAGE ID：镜像ID</li>
<li>CREATED：镜像的创建日期（不是获取该镜像的日期）</li>
<li>SIZE：镜像大小</li>
</ul>
<p>这些镜像都储存在Docker宿主机的<code>/var/lib/docker</code>目录下。</p>
<ol start="2">
<li>搜索镜像</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker search 镜像名称</span><br></pre></td></tr></table></figure>

<p><img src="/2018/11/28/cloud/docker/6.png" alt></p>
<ol start="3">
<li>从Docker Hub拉取镜像</li>
</ol>
<p>去Docker Hub官网查找所需的Docker镜像：<a href="https://hub.docker.com/explore/" target="_blank" rel="noopener">https://hub.docker.com/explore/</a> ，然后通过以下命令在线pull：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker pull 镜像名称</span><br><span class="line">[root@localhost ~]# docker pull 镜像名称:版本</span><br></pre></td></tr></table></figure>

<p>因为官方提供的Docker镜像加速服务很慢，我们可以配置<code>ustc</code>的镜像。输入以下命令配置<code>ustc</code>镜像：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vi /etc/docker/daemon.json</span><br></pre></td></tr></table></figure>

<p>没有就创建，向其中写入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;registry-mirrors&quot;: [&quot;https://docker.mirrors.ustc.edu.cn&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重启Docker服务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# systemctl restart docker</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>删除镜像</li>
</ol>
<p>删除指定镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker rmi $IMAGE_ID  #这个$IMAGE_ID数值可以根据`docker images`命令查看</span><br></pre></td></tr></table></figure>

<p>删除所有镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker rmi `docker images -q`</span><br></pre></td></tr></table></figure>

<br>

<h2 id="Docker容器操作"><a href="#Docker容器操作" class="headerlink" title="Docker容器操作"></a>Docker容器操作</h2><ol>
<li>查看正在运行的容器</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker ps</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>查看所有的容器（启动过的历史容器）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker ps -a</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>查看最后一次运行的容器</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker ps -|</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>查看停止的容器</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker ps -f status=exited</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>删除容器</li>
</ol>
<p>删除指定容器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker rm $CONTAINER_ID/NAME</span><br></pre></td></tr></table></figure>

<p>删除所有容器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker rm `docker ps -a -q`</span><br></pre></td></tr></table></figure>

<br>

<h2 id="创建和启动容器"><a href="#创建和启动容器" class="headerlink" title="创建和启动容器"></a>创建和启动容器</h2><p><strong>创建容器常用的参数说明</strong></p>
<ol>
<li>创建容器命令：<code>docker run</code></li>
<li><code>-i</code>: 表示运行容器</li>
<li><code>-t</code>: 表示容器启动后会进入其命令行，加入这两个参数后，容器创建就能登录进去。即分配一个伪终端。</li>
<li><code>—name</code>: 为创建的容器命名</li>
<li><code>-v</code>: 表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个<code>-v</code>做多个目录或文件映射。注意：最好做目录映射，在宿主机上修改，然后共享到容器上。</li>
<li><code>-d</code>: 在<code>run</code>后面加上<code>-d</code>参数，则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器，如果只加<code>-i</code> <code>-t</code>两个参数，创建后就会自动进去容器）。</li>
<li><code>-p</code>： 表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个<code>-p</code>做多个端口映射。</li>
</ol>
<h3 id="交互式容器"><a href="#交互式容器" class="headerlink" title="交互式容器"></a>交互式容器</h3><p>创建一个交互式容器并取名为<code>mycentos5</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker run -it --name=mycentos5 centos:7 /bin/bash</span><br><span class="line">[root@53f33e279914 /]#</span><br></pre></td></tr></table></figure>

<p>此时我们可以新建一个连接，通过<code>docker ps</code>命令看到刚才创建的容器正在启动中：</p>
<p><img src="/2018/11/28/cloud/docker/7.png" alt></p>
<p>通过<code>exit</code>命令可以退出当前容器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@53f33e279914 /]# exit</span><br><span class="line">exit</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure>

<p>此时再通过<code>docker ps</code>命令查看刚才启动的容器也停止了。</p>
<h3 id="守护式容器"><a href="#守护式容器" class="headerlink" title="守护式容器"></a>守护式容器</h3><p>输入以下命令创建一个名字为<code>mycentos6</code>的容器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker run -di --name=mycentos6 centos:7</span><br></pre></td></tr></table></figure>

<p>创建后这个容器会在后台运行，而不是直接进入到这个容器中。可以通过<code>docker ps</code>命令查看。</p>
<p>登录守护式容器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker exec -it mycentos6 /bin/bash</span><br></pre></td></tr></table></figure>

<p>可以通过<code>exit</code>命令退出，但是容器不会停止。</p>
<h3 id="停止和启动容器"><a href="#停止和启动容器" class="headerlink" title="停止和启动容器"></a>停止和启动容器</h3><p>停止正在运行的容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker stop 容器名称</span><br></pre></td></tr></table></figure>

<p>启动已运行过的容器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker start 容器名称</span><br></pre></td></tr></table></figure>

<br>

<h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><h3 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝"></a>文件拷贝</h3><p>将文件拷贝到容器内可以用如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker cp 需要拷贝的文件或目录 容器名称:容器目录</span><br></pre></td></tr></table></figure>

<p>将文件从容器中拷贝出来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker cp 容器名称:容器目录 需要拷贝的文件或目录</span><br></pre></td></tr></table></figure>

<h3 id="目录挂载"><a href="#目录挂载" class="headerlink" title="目录挂载"></a>目录挂载</h3><p>在创建容器的时候，将宿主机的目录和容器内的目录进行映射，这样我们就可以通过修改宿主机某个目录的文件从而影响容器。格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker run -di -v 宿主机目录:容器目录</span><br></pre></td></tr></table></figure>

<h3 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker inspect mycentos5</span><br></pre></td></tr></table></figure>

<br>

<h1 id="部署应用"><a href="#部署应用" class="headerlink" title="部署应用"></a>部署应用</h1><h2 id="Mysql部署"><a href="#Mysql部署" class="headerlink" title="Mysql部署"></a>Mysql部署</h2><ol>
<li>拉取MySQL镜像</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker pull mysql:5.7</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建MySQL容器</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker run -di --name docker_mysql -p 33306:3306 -e MYSQL_ROOT_PASSWORD=root mysql:5.7</span><br></pre></td></tr></table></figure>

<p>如上我们创建一个名称为<code>docker_mysql</code>的MySQL5.7版本的守护式容器，且配置MySQL登录密码是<code>root</code>。</p>
<ul>
<li><code>-p</code> 代表端口映射，格式为 <code>宿主机映射端口:容器运行端口</code></li>
<li><code>-e</code> 代表添加环境变量， <code>MYSQL_ROOT_PASSWORD</code>是root用户的登录密码</li>
</ul>
<ol start="3">
<li>进入MySQL容器，登录MySQL</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker exec -it docker_mysql /bin/bash</span><br></pre></td></tr></table></figure>

<p>登录MySQL</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>远程连接MySQL</li>
</ol>
<p><img src="/2018/11/28/cloud/docker/8.png" alt></p>
<h2 id="Tomcat部署"><a href="#Tomcat部署" class="headerlink" title="Tomcat部署"></a>Tomcat部署</h2><ol>
<li>拉取Tomcat-8 &amp;&amp; JDK-8 镜像</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker pull tomcat:8-jre8</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>部署Web应用</li>
</ol>
<p>为了更好的演示Docker部署Tomcat的使用方式，我们可以先将需要部署的web项目发送到服务器的某个路径下，我这里在<code>/root/</code>目录下创建了<code>/root/site/</code>目录作为项目的根目录，在其中创建<code>index.html</code>文件并写入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Hello&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;Hello Docker-Tomcat!&lt;/h2&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建Tomcat容器</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker run -di --name=docker_tomcat -p 9000:8080 -v /root/site/:/usr/local/tomcat/webapps/ROOT --privileged=true tomcat:8-jre8</span><br></pre></td></tr></table></figure>

<p>以上就创建一个Tomcat容器，其容器名称Wie<code>docker_tomcat</code>，<code>-di</code>表示是一个守护式容器；<code>-p 9000:8080</code>表示此容器端口映射为<code>9000-&gt;8080</code>，即对外的端口是9000，映射到容器里Tomcat服务器的端口8080，<code>--privileged</code>是以root权限运行。</p>
<p><img src="/2018/11/28/cloud/docker/9.png" alt></p>
<p>通过命令看到，当我们启动了容器，其中的Tomcat服务器也自动启动了。当然对于部署Nginx或MySQL的Docker容器，当启动容器时都会启动对应的服务。</p>
<p><strong>注意</strong></p>
<p>上面我们指定了宿主机的<code>/root/site/</code>目录映射到<code>docker_tomcat</code>容器的<code>/usr/local/tomcat/webapps/ROOT</code>目录，为什么是这个目录呢？</p>
<p>Docker虚拟化，它会在内部虚拟一个操作系统，是在其宿主机内核上的一层空间，所有有一定的目录结构，我们可以通过<code>docker exec -it docker_tomcat /bin/bash</code>命令进入到<code>docker_tomcat</code>容器内部，通过<code>ls</code>命令查看目录会发现其Tomcat服务器确实安装在<code>docker_tomcat</code>容器的<code>/usr/local/tomcat</code>目录下。</p>
<p>最后，我们在浏览器上访问：<code>http://192.168.148.132:9000/</code>，即发现页面展示了我们刚才在<code>/root/site/</code>目录下创建的<code>index.html</code>网页：</p>
<p><img src="/2018/11/28/cloud/docker/10.png" alt></p>
<p>所以，如果你想要修改容器中Tomcat的端口号，直接进入容器的<code>/usr/local/tomcat/conf/server.xml</code>自改即可。</p>
<br>

<h2 id="Nginx部署"><a href="#Nginx部署" class="headerlink" title="Nginx部署"></a>Nginx部署</h2><ol>
<li>拉取Nginx镜像</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建Nginx容器</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -di --name=docker_nginx -p 80:80 nginx</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>测试</li>
</ol>
<p><img src="/2018/11/28/cloud/docker/11.png" alt></p>
<p>在浏览器上访问：<code>http://192.168.148.132/</code>可以进入到Nginx的欢迎页。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>以上我们介绍了MySQL、Tomcat、Nginx容器的创建，对于其他的服务，如Redis等操作基本相同，不再阐述。</p>
<br>

<h1 id="备份与迁移"><a href="#备份与迁移" class="headerlink" title="备份与迁移"></a>备份与迁移</h1><ol>
<li>容器保存为镜像</li>
</ol>
<p>可以通过以下命令将我们已创建（配置好的）容器打包为镜像，这样我们以后就能用该镜像再次创建新的容器了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker commit docker_tomcat my_tomcat</span><br></pre></td></tr></table></figure>

<p><code>docker_tomcat</code>是容器名称；<code>my_tomcat</code>是新的镜像名称。</p>
<ol start="2">
<li>镜像备份</li>
</ol>
<p>通过以下命令可以将镜像打包为tar文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker save -o my_tomcat.tar my_tomcat</span><br></pre></td></tr></table></figure>

<p><code>-o</code>输出到的文件</p>
<ol start="3">
<li>镜像恢复与</li>
</ol>
<p>当我们删除了<code>docker_tomcat</code>镜像后，可以通过以下命令将刚才打包备份的<code>.tar</code>镜像文件恢复成一个Docker镜像：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker load -i my_tomcat.tar</span><br></pre></td></tr></table></figure>

<p><code>-i</code>输入的文件。</p>
<br>

<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>高性能HTTP服务器Nginx</title>
    <url>/2018/11/27/other/nginx/</url>
    <content><![CDATA[<p><img src="/2018/11/27/other/nginx/logo.jpg" alt></p>
<p>Nginx是一款高性能HTTP服务器、反向代理服务器及电子邮件（IMAP、POP3）代理服务器，官方测试nginx能够支持5万并发连接。</p>
<a id="more"></a>

<p><strong>Nginx应用场景：</strong></p>
<ol>
<li>http服务器。Nginx是一个http服务器，可以独立提供http服务。可以做网页静态服务器。</li>
<li>虚拟主机。可以实现在一台服务器虚拟出多个网站。</li>
<li>反向代理，负载均衡。当网站的并发量过大需要配置服务器集群时可以使用Nginx做反向代理。并且多台服务器可以平均分摊负载。</li>
</ol>
<br>

<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p><strong>本文章默认使用的软件：</strong></p>
<ul>
<li>Centos7</li>
<li>nginx-1.12.2</li>
<li>Jdk8</li>
<li>Tomcat8</li>
</ul>
<p><strong>开发工具：</strong></p>
<ul>
<li>VMware</li>
<li>SecureCRT</li>
</ul>
<p>如果第一次在虚拟机上安装Linux系统，我建议你看一下这篇文章：<a href="https://tycoding.cn/2018/08/29/fastdfs/" target="_blank" rel="noopener">FastDFS系统搭建</a>，其中详细记录了虚拟机如何安装CentOS和联网。本文默认你已经安装了Centos7。</p>
<br>

<h1 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h1><br>

<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ol>
<li>安装gcc的环境</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install gcc-c++</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>PCRE（perl库，包括perl兼容的正则表达式库。nginx的http模块使用pcre来解析正则表达式）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y pcre pcre-devel</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Zlib（zlib提供了很多压缩和解压的方式，nginx使用http包的内容进行gzip）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y zlib zlib-devel</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>OpenSSL（一个强大的安全套接字层密码库，为nginx支持的https(即在SSL协议上传输http)协议服务）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y openssl openssl-devel</span><br></pre></td></tr></table></figure>

<br>



<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在本地电脑下载nginx的压缩包（我这里是<code>nginx-1.12.2.tar.gz</code>），然后打开SecureCRT连接服务器，使用命令<code>gz</code>将本地的文件上传到Linux服务器上。</p>
<blockquote>
<p>注：如果在SecureCRT上输入<code>gz</code>显示command not found，是因为Linux虚拟机上没有安装<code>lrsz</code>服务。</p>
</blockquote>
<p>执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y indtall lrzsz</span><br></pre></td></tr></table></figure>

<p>然后可以输入<code>rz</code>命令选择要上传的文件。默认上传到当前路径上。</p>
<ol>
<li><strong>解压：</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar zxvf nginx-1.12.2.tar.gz</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>创建Makefile文件，执行命令：</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# cd nginx-1.12.2</span><br><span class="line">[root@localhost nginx-1.12.2]# ./configure</span><br></pre></td></tr></table></figure>

<p><img src="/2018/11/27/other/nginx/1.png" alt></p>
<p>完成后可以看到Makefile文件：</p>
<p><img src="/2018/11/27/other/nginx/2.png" alt></p>
<p><strong>拓展</strong></p>
<p>Makefile是一种配置文件，Makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译…。Makefile就像一个Shell脚本一样。</p>
<ol start="3">
<li><strong>编译</strong></li>
</ol>
<p>执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost nginx-1.12.2]# make</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>安装</strong></li>
</ol>
<p>执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost nginx-1.12.2]# make install</span><br></pre></td></tr></table></figure>

<p>到此，Nginx安装已经完成。</p>
<br>

<h1 id="Nginx启动与访问"><a href="#Nginx启动与访问" class="headerlink" title="Nginx启动与访问"></a>Nginx启动与访问</h1><p>上面我本编译安装的Nginx其实默认被安装在CentOS7系统的<code>/usr/local/nginx</code>目录。</p>
<p><img src="/2018/11/27/other/nginx/3.png" alt></p>
<p><strong>启动Nginx</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost nginx]# cd sbin</span><br><span class="line">[root@localhost sbin]# ./nginx</span><br></pre></td></tr></table></figure>

<p>此时已经启动成功Nginx，可以直接在浏览器上输入虚拟机IP（可通过<code>ip addr</code>命令查看），即可访问到Nginx欢迎界面，如果显示未连接，可以：</p>
<ol>
<li>先使用本机的终端工具<code>ping</code>虚拟机IP地址看是否成功</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ping ip</span><br></pre></td></tr></table></figure>

<p>如果ping成功，请看下一步，如果失败，请检查虚拟机是否联网</p>
<ol start="2">
<li>关闭CentOS7的防火墙，开放80端口</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost sbin]# systemctl stop firewalld.service #停止firewall</span><br><span class="line">[root@localhost sbin]# systemctl disable firewalld.service #禁止firewall开机启动</span><br><span class="line">[root@localhost sbin]# firewall-cmd --state #查看默认防火墙状态（关闭后显示notrunning，开启后显示running）</span><br></pre></td></tr></table></figure>

<p>一般情况下就能访问到了：</p>
<p><img src="/2018/11/27/other/nginx/4.png" alt></p>
<p><strong>查看Nginx进程</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost sbin]# ps aux|grep nginx</span><br></pre></td></tr></table></figure>

<p><strong>关闭Nginx</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost sbin]# ./nginx -s stop</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost sbin]# ./nginx -s quit</span><br></pre></td></tr></table></figure>

<p><strong>重启Nginx</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost sbin]# ./nginx -s reload</span><br></pre></td></tr></table></figure>

<p><strong>检查Nginx配置文件是否正确</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost sbin]# ./nginx -t</span><br></pre></td></tr></table></figure>

<br>



<h1 id="部署静态网站"><a href="#部署静态网站" class="headerlink" title="部署静态网站"></a>部署静态网站</h1><p>经过上面的操作，我们已经正常启动了nginx，那么如何将我们的静态项目部署到服务器的Nginx上呢？</p>
<p>为了模拟操作，我这里只部署一个<code>index.html</code>网页为例：</p>
<ol>
<li><strong>上传静态网站</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 回到根目录下</span><br><span class="line">[root@localhost sbin]# cd ../</span><br><span class="line"></span><br><span class="line"># 创建文件夹`my`，视为我们的项目文件夹</span><br><span class="line">[root@localhost nginx]# mkdir my</span><br><span class="line"></span><br><span class="line"># 在文件夹`my`下创建一个`index.html`网页</span><br><span class="line">[root@localhost nginx]# cd my</span><br><span class="line">[root@localhost my]# vi index.html</span><br></pre></td></tr></table></figure>

<p>写入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Hello&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;h2&gt;Hello Nginx!&lt;/h2&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>修改Nginx的配置文件</strong></li>
</ol>
<p>修改<code>/usr/local/nginx/conf/nginx.conf</code>文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost my]# cd ../conf</span><br><span class="line">[root@localhost conf]# vi nginx.conf</span><br></pre></td></tr></table></figure>

<p>在<code>http {}</code>这个节点下新创建一个<code>server {}</code>节点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 81;</span><br><span class="line">    server_name localhost;</span><br><span class="line">    location / &#123;</span><br><span class="line">        root my;</span><br><span class="line">        index index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此，我们已经将81端口绑定了<code>/nginx</code>文件夹下的名称为<code>my</code>的项目。重启Nginx，访问：<code>192.168.148.132:81</code>即可以访问到我们刚才新创建的网页：<code>index.html</code>。</p>
<br>

<h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><p><strong>域名</strong>是由一串用“.”分隔的字符逐层的Internet上某一台计算机或计算机组的名称，用于在数据传输时表示计算机的电子方位。域名是一个IP地址的“面具”。域名的目的是便于记忆和沟通的一组服务器的地址。域名按照<strong>域名系统DNS</strong>的规则流程组成，在DNS中注册的任何名称都是域名。域名用于各种网络环境和应用程序特定的命名和寻址目的。通常，域名表示互联网协议（IP）资源。</p>
<p>一个域名对应一个IP地址，一个IP地址可以被多个域名绑定。</p>
<p>为了模拟，我们可以在本地hosts文件中配置域名和IP映射关系，这样就不用走DNS服务器了。</p>
<p>因为hosts文件内容不能直接修改，需要把hosts文件拷贝出来然后修改后再替换进去就行了（我这里使用的MACOS系统）。</p>
<ol>
<li><strong>修改hosts</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp /private/etc/hosts ~/Desktop/</span><br><span class="line">vi ~/Desktop/hosts</span><br></pre></td></tr></table></figure>

<p>添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.168.148.132 www.tumo.xixi</span><br></pre></td></tr></table></figure>

<p>然后替换原来的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp ~/Desktop/hosts /private/etc/</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改Nginx配置文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost conf]# vi /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure>

<p>为了模拟效果，我们可以先把之前新增的<code>server {}</code>节点81端口改为80端口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name localhost;</span><br><span class="line">    location / &#123;</span><br><span class="line">        root my;</span><br><span class="line">        index index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重启Nginx：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost conf]# cd ../sbin</span><br><span class="line">[root@localhost sbin]# ./nginx -s stop</span><br><span class="line">[root@localhost sbin]# ./nginx</span><br></pre></td></tr></table></figure>

<p>访问<code>192.168.148.132</code>发现还是Nginx的Welcome页面，因为nginx.conf默认配置的80端口就是指向Nginx欢迎页，且默认的<code>server_name</code>就是<code>localhost</code>。那么想实现不同的域名访问不同的资源且还必须是80端口，就需要绑定域名：</p>
<p>修改<code>nginx.conf</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name tumo.xixi;</span><br><span class="line">    location / &#123;</span><br><span class="line">        root my;</span><br><span class="line">        index index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，很简单，只需要把<code>server_name</code>改为我们要绑定的域名地址就好了，然后重启Nginx，在浏览器上访问<code>tumo.xixi</code>就展示我们之前创建的<code>index.html</code>，而输入<code>192.168.148.132</code>访问的还是Nginx的欢迎页，这就实现了域名的绑定。多个域名绑定同一个IP地址，但是不同的域名指向了不同的资源地址。</p>
<br>

<h1 id="Nginx反向代理"><a href="#Nginx反向代理" class="headerlink" title="Nginx反向代理"></a>Nginx反向代理</h1><blockquote>
<p>什么是反向代理？</p>
</blockquote>
<p>反向代理（Reverse Proxy）方式是指以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器，并从服务器上得到的结果返回给Internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p>
<blockquote>
<p>正向代理</p>
</blockquote>
<p><img src="/2018/11/27/other/nginx/5.png" alt></p>
<p><strong>正向代理</strong>，主要针对客户端。当用户通过PC向Internet发送请求时，可以通过一个代理服务器来统一处理请求并转发给Internet，比如一个教室的所有学生机都需要通过老师的教师机才能实现联网，那么这个教师机就相当于一个代理服务器，负责将PC的网络请求转发给Internet，然后Internet将相应的数据再通过代理服务器转发给不同的PC。</p>
<blockquote>
<p>反向代理</p>
</blockquote>
<p><img src="/2018/11/27/other/nginx/6.png" alt></p>
<p><strong>反向代理</strong>的过程则刚好相反，主要针对服务器。当用户通过网络请求不同的资源，而这些资源被分布在不同的服务器上，那么不同的请求就应该指向对应不同的服务器，那么就需要一个中介：反向代理服务器。通过反向代理服务器将不同的资源请求信息发送给不同的服务器，然后服务器将不同的信心都返回给反向代理服务器，最后通过反向代理服务器将这些结果信息展示在Internet上。</p>
<br>

<h2 id="配置反向代理"><a href="#配置反向代理" class="headerlink" title="配置反向代理"></a>配置反向代理</h2><p>这里我们以一个非常实用的案例来演示如何配置Nginx的反向代理实现不同的域名访问不同的页面。</p>
<ol>
<li>在服务器上安装JDK8和Tomcat8</li>
</ol>
<p>通过<code>rz</code>命令将本地的JDK和Tomcat安装包上传到服务器。因为Tomcat解压即可用，我们这里记录一下如何安装JDK：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 解压</span><br><span class="line">tar zxvf jdk-8u191-linux-x64.tar.gz</span><br><span class="line"></span><br><span class="line"># 配置JDK环境</span><br><span class="line">vi /etc/profile</span><br></pre></td></tr></table></figure>

<p>在<code>profile</code>文件的结尾处添加如下环境配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/root/jdk1.8.0_191    </span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br></pre></td></tr></table></figure>

<p><code>:wq!</code>保存并退出，输入命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# source /etc/profile</span><br></pre></td></tr></table></figure>

<p>更新配置。然后输入<code>java -version</code>显示则说明JDK配置成功。</p>
<p>解压Tomcat，在其<code>bin</code>目录下执行命令<code>./startup.sh</code>启动Tomcat服务器，然后我们再浏览器上访问：<code>http://192.168.148.132:8080/</code>显示Tomcat的欢迎页面则配置成功。</p>
<ol start="2">
<li>拷贝项目到Tomcat服务器下</li>
</ol>
<p>为了模拟，我们在<code>tomcat/webapps/ROOT/</code>下创建一个<code>index.html</code>网页：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ROOT]# vi index.html</span><br></pre></td></tr></table></figure>

<p>并写入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Hello&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;Hello Tomcat!&lt;/h2&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>保存并退出，再次访问<code>http://192.168.148.132:8080/</code>发现展示的即是我们刚创建的页面</p>
<p><img src="/2018/11/27/other/nginx/7.png" alt></p>
<ol start="3">
<li>配置反向代理</li>
</ol>
<p>之前讲了<strong>反向代理</strong>的概念，那么很实用的一个例子就是，当我们想在购买的阿里云服务器上部署两个项目，一个项目是用Nginx部署的静态网站（占用80端口），另一个项目部署在Tomcat服务器上（占用8080端口）。</p>
<p>这时，我们固然是可以通过：<code>ip:8080</code>来访问我们的Web项目的，但是请求路径上显示了端口好久显得很别扭，为此，我们通过Nginx的反向代理就能解决：</p>
<ul>
<li>3.1在本地配置一个二级域名映射</li>
</ul>
<p>修改本机的hosts文件，添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.168.148.132 site.tumo.xixi</span><br></pre></td></tr></table></figure>

<p>这时我们访问<code>site.tumo.xixi</code>默认进入nginx的欢迎页，这是正确的。</p>
<p><img src="/2018/11/27/other/nginx/8.png" alt></p>
<p>注意：此时的<code>site.tumo.xixi</code>是<code>tumo.xixi</code>的一个二级子域名。</p>
<ul>
<li>3.2 修改服务器Nginx的配置文件，添加如下配置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream site &#123;</span><br><span class="line">        server 192.168.148.132:8080;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name site.tumo.xixi;</span><br><span class="line">        location / &#123;</span><br><span class="line">       		proxy_pass http://site;</span><br><span class="line">        	index index.html;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，其中<code>server {}</code>节点下的<code>proxy_pass</code>表示反向代理的地址，其中<code>http://site</code>这个<code>site</code>其实是指向上面<code>upstream site {}</code>节点的<code>site</code>名称，因此要保持两者名称一致。但实际上我们不采用这种方式也能实现反向代理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># upstream site &#123;</span><br><span class="line">#         server 192.168.148.132:8080;</span><br><span class="line"># &#125;</span><br><span class="line">server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name site.tumo.xixi;</span><br><span class="line">        location / &#123;</span><br><span class="line">       		# proxy_pass http://site;</span><br><span class="line">        	proxy_pass http://192.168.148.132:8080;</span><br><span class="line">        	index index.html;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2018/11/27/other/nginx/9.png" alt></p>
<p>两者的区别就是第一种方式通过<em>指向</em>的方式可以配置更多，必须实现<strong>负载均衡</strong>就需要在<code>upstream site {}</code>节点下配置。</p>
<br>

<h1 id="Nginx配置负载均衡"><a href="#Nginx配置负载均衡" class="headerlink" title="Nginx配置负载均衡"></a>Nginx配置负载均衡</h1><blockquote>
<p>什么是负载均衡？</p>
</blockquote>
<p><strong>负载均衡（Load Balance）</strong>，其意思就是分摊到多个操作单元上进行执行，从而共同完成工作任务。</p>
<p><strong>负载均衡</strong> 是建立在现有网络结构上，提供一种廉价有效透明的方法扩展网络设备和服务器的带宽，增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。</p>
<ol>
<li><strong>模拟负载均衡</strong>，我们可以提供多个Tomcat服务器，采用不同的端口区分。</li>
</ol>
<p>为了模拟<strong>负载均衡</strong>效果，可以copy 2份虚拟机上的Tomcat服务器，命名为tomcat-2，tomcat-3:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# cp ~/apache-tomcat-8.5.33 ~/tomcat-2</span><br><span class="line">[root@localhost ~]# cp ~/apache-tomcat-8.5.33 ~/tomcat-3</span><br></pre></td></tr></table></figure>

<p>修改端口号分别为8180，8280。我们主要修改<code>/tomcat/conf/server.xml</code>配置文件中的<code>&lt;Server port=&quot;8005&quot;</code>和<code>&lt;Connector port=&quot;8080&quot;</code>这两个节点的端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 修改tomcat-2服务器的`/conf/server.xml`参数</span><br><span class="line">&lt;Server port=&quot;8006&quot; shutdown=&quot;SHUTDOWN&quot;&gt;</span><br><span class="line">	    &lt;Connector port=&quot;8180&quot; protocol=&quot;HTTP/1.1&quot;	</span><br><span class="line"></span><br><span class="line"># 修改tomcat-3服务器的`/conf/server.xml`参数</span><br><span class="line">&lt;Server port=&quot;8007&quot; shutdown=&quot;SHUTDOWN&quot;&gt;</span><br><span class="line">	    &lt;Connector port=&quot;8280&quot; protocol=&quot;HTTP/1.1&quot;</span><br></pre></td></tr></table></figure>

<p>如上，我们在虚拟机上配置了三个Tomcat服务器，分别使用8080，8180，8280端口。</p>
<ol start="2">
<li><strong>配置负载均衡</strong></li>
</ol>
<p>修改Nginx下的配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vi /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure>

<p>修改之前配置的<code>upstream site {}</code>节点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> upstream site &#123;</span><br><span class="line">     server 192.168.148.132:8080;</span><br><span class="line">     server 192.168.148.132:8180;</span><br><span class="line">     server 192.168.148.132:8280;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name site.tumo.xixi;</span><br><span class="line">    location / &#123;</span><br><span class="line">    	proxy_pass http://site;</span><br><span class="line">    	index index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就给Nginx配置了3台服务器，都指向了<code>site.tumo.xixi</code>这个域名地址，那么访问这个地址时同时会访问这三台服务器，也就是三台服务器平均分摊访问压力。</p>
<p>为了更好的实现效果，我们可以依次修改tomcat-2和tomcat-3服务器的<code>/webapps/ROOT/index.html</code>网页显示数据，更容易区分每次访问的是哪台服务器。</p>
<p>然后运行这三个Tomcat服务器，在浏览器上访问：<code>site.tumo.xixi</code>，多次刷新页面，每次访问的都是不同的页面，且依次是配置负载均衡的三台服务器次序。</p>
<p>如果你想让某个服务器承担更大的压力，可以为其设置权重：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> upstream site &#123;</span><br><span class="line">     server 192.168.148.132:8080;</span><br><span class="line">     server 192.168.148.132:8180 weight=2;</span><br><span class="line">     server 192.168.148.132:8280;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>简洁美观的Tumo Blog开源了</title>
    <url>/2018/11/05/project/tumo/</url>
    <content><![CDATA[<h1 id="Tumo-Blog"><a href="#Tumo-Blog" class="headerlink" title="Tumo Blog"></a>Tumo Blog</h1><p><img src="http://cdn.tycoding.cn/tumo.png" alt></p>
<p>Base on SpringBoot-2.x framework’s java Blog system open source. Simple design, beautiful interface. Tumo Blog development is beginning, you can pull requests or pull issue on Github if you have better design.</p>
<p>演示站点: <a href="http://tumo.tycoding.cn" target="_blank" rel="noopener">http://tumo.tycoding.cn</a></p>
<p>项目地址：<a href="https://github.com/TyCoding/tumo" target="_blank" rel="noopener">https://github.com/TyCoding/tumo</a></p>
<p>如果你喜欢，或是对你的学习有所帮助，欢迎点击右上角star、fork 给作者一些鼓励。</p>
<a id="more"></a>

<blockquote>
<p>‘Tumo’是一个中文单词，Tumo用中文解释为 <strong>道路</strong> 的意思，希望可以通过博客来记录自己学习的历程。</p>
</blockquote>
<p>Tumo Blog是一个基于SpringBoot2开发的博客系统。博客前台UI移植自<a href="https://github.com/chakhsu/pinghsu" target="_blank" rel="noopener">@pinghsu</a>主题，因为原主题是基于PHP的，所以我不能直接使用它，但是非常感谢<a href="https://github.com/chakhsu/pinghsu" target="_blank" rel="noopener">@pinghsu</a>的作者。<br>Tumo Blog的后台管理页面基于ElementUI绘制，后台管理通过ajax异步交互，相当于前后端半分离吧。如果你觉得它不错，欢迎 star flok。</p>
<p>注意：本博客系统仍在不断的维护开发中，欢迎提出合理的建议。当前系统适合正在学习SSM&amp;&amp;SpringBoot框架的同学。陆续，我会发布基于Vue、Angular（node.js）的前后端完全分离的版本，如果你喜欢，请持续关注了(#^.^#)。</p>
<p>演示站点: <a href="http://tumo.tycoding.cn" target="_blank" rel="noopener">http://tumo.tycoding.cn</a></p>
<p><a href="https://github.com/TyCoding/tumo/wiki/%E5%A6%82%E4%BD%95%E9%83%A8%E7%BD%B2Tumo-Blog" target="_blank" rel="noopener">快速开始</a></p>
<h2 id="Vue版本"><a href="#Vue版本" class="headerlink" title="Vue版本"></a>Vue版本</h2><p>本博客也有基于Vue组件开发的前后端完全分离的版本，如果你已经熟悉的传统的SSM框架开发模式，或许你可以尝试一下前后端分离的开发模式，那么 <a href="https://github.com/TyCoding/tumo-vue" target="_blank" rel="noopener">https://github.com/TyCoding/tumo-vue</a>就是一个不错的选择。</p>
<p>同时也欢迎大家借此项目进行二次开发。详细介绍请看：<a href="https://github.com/TyCoding/tumo-vue" target="_blank" rel="noopener">https://github.com/TyCoding/tumo-vue</a></p>
<p>如果大家喜欢、或是对大家的学习有所帮助，请点击右上角star、fork 给作者一些鼓励。</p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>项目地址：<a href="https://github.com/TyCoding/tumo-vue" target="_blank" rel="noopener">TyCoding/tumo-vue</a><br>预览站点：<a href="http://tumo-vue.tycoding.cn/" target="_blank" rel="noopener">tumo-vue.tycoding.cn</a><br>后台地址：<a href="http://tumo-vue.tycoding.cn/login" target="_blank" rel="noopener">tumo-vue.tycoding.cn/login</a></p>
<h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ul>
<li>简约的设计，漂亮的界面。</li>
<li>博客前台、管理后台响应式设计。</li>
<li>支持Markdown格式文章的撰写。</li>
<li>支持文件上传。</li>
<li>支持网易云音乐插件。</li>
<li>项目后端管理页面基于Vue.js和ElementUI设计。</li>
<li>项目基于SpringBoot-2.x框架开发。</li>
<li>更多功能正在开发中…</li>
</ul>
<h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><p>Tumo Blog是一个基于SpringBoot-2.x框架的博客系统。如果你已经熟悉SSM框架，部署这个项目将是非常简单的。更多的信息，请看：</p>
<ul>
<li><input checked disabled type="checkbox"> <a href="https://github.com/TyCoding/tumo/wiki/%E5%A6%82%E4%BD%95%E9%83%A8%E7%BD%B2Tumo-Blog" target="_blank" rel="noopener">1.如何部署Tumo Blog</a></li>
</ul>
<h1 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h1><p><strong>演示站点:</strong> <a href="http://tumo.tycoding.cn" target="_blank" rel="noopener">tumo.tycoding.cn</a></p>
<p><strong>Github:</strong> <a href="https://github.com/TyCoding/tumo" target="_blank" rel="noopener">tumo</a></p>
<p><strong>Blog:</strong> <a href="http://tycoding.cn" target="_blank" rel="noopener">tycoding.cn</a></p>
<p>初始账户：tycoding  密码：123456</p>
<h2 id="预览图"><a href="#预览图" class="headerlink" title="预览图"></a>预览图</h2><p><img src="http://cdn.tycoding.cn/tumo-admin.png" alt></p>
<p><img src="http://cdn.tycoding.cn/tumo-article-publish.png" alt></p>
<p><img src="http://cdn.tycoding.cn/tumo-article.png" alt></p>
<p><strong>响应式：</strong></p>
<p><img src="http://cdn.tycoding.cn/tumo-login-phone.png" alt></p>
<p><img src="http://cdn.tycoding.cn/tumo-admin-phone2.png" alt></p>
<p><img src="http://cdn.tycoding.cn/tumo-cover-phone.png" alt></p>
<br>

<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot实现Java高并发秒杀系统之并发优化（四）</title>
    <url>/2018/10/15/ssm/seckill/</url>
    <content><![CDATA[<p>之前我们已经讲了：</p>
<ul>
<li><p><a href="http://tycoding.cn/2018/10/14/ssm/seckill-web/" target="_blank" rel="noopener">SpringBoot实现Java高并发秒杀系统之Web层开发（三）</a></p>
</li>
<li><p><a href="http://tycoding.cn/2018/10/13/ssm/seckill-service/" target="_blank" rel="noopener">SpringBoot实现Java高并发秒杀系统之Service层开发（二）</a></p>
</li>
<li><p><a href="http://tycoding.cn/2018/10/12/ssm/seckill-dao/" target="_blank" rel="noopener">SpringBoot实现Java高并发秒杀系统之DAO层开发（一）</a></p>
</li>
</ul>
<p>今天我们来分析一下秒杀系统的难点和怎么进行并发优化。</p>
<p>本项目的源码请参看：<a href="https://github.com/TyCoding/springboot-seckill" target="_blank" rel="noopener">springboot-seckill</a>  如果觉得不错可以star一下哦(#^.^#)</p>
<a id="more"></a>


<p>秒杀系统架构的设计和优化分析，以我一个小菜鸡，目前是说不出来的o(╥﹏╥)o。</p>
<p>因此呢，我这里仅从本项目已经实现的优化来介绍一下：</p>
<p>本项目中做到了以下优化：</p>
<ul>
<li>秒杀接口采用md5加密方式防刷。</li>
<li>订单表使用联合主键方式，限制一个用户只能购买该商品一次。</li>
<li>配合Spring事务控制实现简单的优化。</li>
<li>使用redis缓存优化。</li>
</ul>
<h1 id="Spring的事务控制"><a href="#Spring的事务控制" class="headerlink" title="Spring的事务控制"></a>Spring的事务控制</h1><p>Spring的声明式事务通过：传播行为、隔离级别、只读提示、事务超时、回滚规则来进行定义。</p>
<h2 id="传播行为"><a href="#传播行为" class="headerlink" title="传播行为"></a>传播行为</h2><p>事务的第一个方面就是传播行为。传播行为定义了客户端与被调用方法之间的事务边界。Spring定义了7中不同的传播行为，传播规则规定了何时要创建一个事务或何时使用已有的事务：</p>
<table>
<thead>
<tr>
<th>传播行为</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>PROPAGATION_MANDATORY</td>
<td>表示该方法必须在事务中运行。如果当前事务不存在，则会抛出一个异常</td>
</tr>
<tr>
<td>PROPAGATION_NESTED</td>
<td>表示如果当前已经存在一个事务，那么该方法将会在嵌套事务中运行。嵌套的事务可以独立与当前事务进行单独的提交或回滚</td>
</tr>
<tr>
<td>PROPAGATION_NEVER</td>
<td>表示当前方法不应该运行在事务上下文中，如果当前正在有一个事务运行，则会抛出异常</td>
</tr>
<tr>
<td>PROPAGATION_NOT_SUPPORTED</td>
<td>表示该方法不应该运行在事务中。</td>
</tr>
<tr>
<td>PROPAGATION_REQUIRED</td>
<td>表示当前方法必须运行在事务中。如果当前事务存在，方法将会在该事务中运行。否者，会启动一个新的事务</td>
</tr>
<tr>
<td>PROPAGATION_REQUIRES_NEW</td>
<td>表示当前方法必须运行在它自己的事务中。一个新的事务将被启动</td>
</tr>
<tr>
<td>PROPAGATION_SUPPORTS</td>
<td>表示当前方法不需要事务上下文，但是如果存在当前事务的话，那么该方法会在这个事务中运行</td>
</tr>
</tbody></table>
<h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><p>声明式事务的第二个维度就是隔离级别。隔离级别定义了一个事务可能受其他并发事务影响的程度。多个事务并发运行，经常会操作相同的数据来完成各自的任务，但是可以回导致以下问题：</p>
<ul>
<li>更新丢失：当多个事务选择同一行操作，并且都是基于最初的选定的值，由于每个事务都不知道其他事务的存在，就会发生更新覆盖的问题。</li>
<li>脏读：事务A读取了事务B已经修改但为提交的数据。若事务B回滚数据，事务A的数据存在不一致的问题。</li>
<li>不可重复读：书屋A第一次读取最初数据，第二次读取事务B已经提交的修改或删除的数据。导致两次数据读取不一致。不符合事务的隔离性。</li>
<li>幻读：事务A根据相同条件第二次查询到的事务B提交的新增数据，两次数据结果不一致，不符合事务的隔离性。</li>
</ul>
<p>理想情况下，事务之间是完全隔离的，从而可以防止这些问题的发生。但是完全的隔离会导致性能问题，因为它通常会涉及锁定数据库中的记录。侵占性的锁定会阻碍并发性，要求事务互相等待以完成各自的工作。</p>
<p>因此为了实现在事务隔离上有一定的灵活性。因此，就会有多重隔离级别：</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ISOLATION_DEFAULT</td>
<td>使用后端数据库默认的隔离级别</td>
</tr>
<tr>
<td>SIOLATION_READ_UNCOMMITTED</td>
<td>允许读取尚未提交的数据变更。可能会导致脏读、幻读或不可重复读</td>
</tr>
<tr>
<td>ISOLATION_READ_COMMITTED</td>
<td>允许读取并发事务提交的数据。可以阻止脏读，但是幻读或不可重复读仍可能发生</td>
</tr>
<tr>
<td>ISOLATION_REPEATABLE_READ</td>
<td>对同一字段的多次读取结果是一致的，除非数据是被本事务自己所修改，可以阻止脏读和不可重复读，但幻读仍可能发生</td>
</tr>
<tr>
<td>ISOLATION_SERIALIZABLE</td>
<td>完全服从ACID的事务隔离级别，确保阻止脏读、不可重复读、幻读。这是最慢的事务隔离级别，因为它通常是通过完全锁定事务相关的数据库来实现的</td>
</tr>
</tbody></table>
<h2 id="回滚规则"><a href="#回滚规则" class="headerlink" title="回滚规则"></a>回滚规则</h2><p>Spring的事务管理器默认是针对unchecked exception回滚，也就是默认对Error异常和RuntimeException异常以及其子类进行事务回滚。</p>
<p>也就是说事务只有在遇到运行期异常才会回滚，而在遇到检查型异常时不会回滚。</p>
<p>这也就是我们之前设计Service业务层逻辑的时候一再强调捕获<code>try catch</code>异常，且将编译期异常转换为运行期异常。</p>
<h1 id="简单优化"><a href="#简单优化" class="headerlink" title="简单优化"></a>简单优化</h1><p>这里我们还是要关注一些项目中的两个核心的业务：1.减库存；2.插入购买明细。我们以一张图来看一下这两个操作的事务执行流程：</p>
<p><img src="/2018/10/15/ssm/seckill/1.png" alt></p>
<p>可以看到我们的秒杀操作主要是基于Mysql的事务进行的，而基于MySQL事务的秒杀操作主要瓶颈是网络延迟和GC（Java垃圾回收机制）。执行一条update语句首先要拿到MySQL的行级锁rowLock，而我们要解决的就是如何降低update对rowLock的持有时间。</p>
<p>我们先了解一下MySQL的InnoDB储存引擎的行级锁（rowLock）:</p>
<ul>
<li>行锁的劣势：开销大；加锁慢；会出现死锁</li>
<li>行锁的优势：锁的粒度小，发生锁冲突的概率低；处理并发的能力强</li>
<li>加锁的方式：自动加锁。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁；对于普通SELECT语句，InnoDB不会加任何锁；当然我们也可以显示的加锁：</li>
<li>共享锁：select * from tableName where … + lock in share more</li>
<li>排他锁：select * from tableName where … + for update</li>
<li>InnoDB和MyISAM的最大不同点有两个：一，InnoDB支持事务(transaction)；二，默认采用行级锁。加锁可以保证事务的一致性，可谓是有人(锁)的地方，就有江湖(事务)。</li>
</ul>
<p>详细的介绍请看博文：<a href="http://www.cnblogs.com/itdragon/p/8194622.html" target="_blank" rel="noopener">MySQL 表锁和行锁机制</a></p>
<p>所以在此基础上我们可以进行简单的优化：</p>
<p><img src="/2018/10/15/ssm/seckill/2.png" alt></p>
<p>很简单，就是调整update和insert操作的执行顺序。目的就是为了缩短update对rowLock的持有时间提高性能，因为我们的查询语句使用了<code>insert ignore into xx</code>的方式来避免重复秒杀，那么闲执行insert语句可以在插入时就排除可能存在重复秒杀的操作，这样就不用再向下执行更新操作了。在一定程度上降低了一倍的rowLock持有时间。</p>
<p>下面是源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SeckillExecution <span class="title">executeSeckill</span><span class="params">(<span class="keyword">long</span> seckillId, BigDecimal money, <span class="keyword">long</span> userPhone, String md5)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> SeckillException, RepeatKillException, SeckillCloseException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (md5 == <span class="keyword">null</span> || !md5.equals(getMD5(seckillId))) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SeckillException(<span class="string">"seckill data rewrite"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行秒杀逻辑：1.减库存；2.储存秒杀订单</span></span><br><span class="line">    Date nowTime = <span class="keyword">new</span> Date();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//记录秒杀订单信息</span></span><br><span class="line">        <span class="keyword">int</span> insertCount = seckillOrderMapper.insertOrder(seckillId, money, userPhone);</span><br><span class="line">        <span class="comment">//唯一性：seckillId,userPhone，保证一个用户只能秒杀一件商品</span></span><br><span class="line">        <span class="keyword">if</span> (insertCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//重复秒杀</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RepeatKillException(<span class="string">"seckill repeated"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//减库存</span></span><br><span class="line">            <span class="keyword">int</span> updateCount = seckillMapper.reduceStock(seckillId, nowTime);</span><br><span class="line">            <span class="keyword">if</span> (updateCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//没有更新记录，秒杀结束</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SeckillCloseException(<span class="string">"seckill is closed"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//秒杀成功</span></span><br><span class="line">                SeckillOrder seckillOrder = seckillOrderMapper.findById(seckillId);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> SeckillExecution(seckillId, SeckillStatEnum.SUCCESS, seckillOrder);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SeckillCloseException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RepeatKillException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(e.getMessage(), e);</span><br><span class="line">        <span class="comment">//所有编译期异常，转换为运行期异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SeckillException(<span class="string">"seckill inner error:"</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h1 id="Redis缓存优化"><a href="#Redis缓存优化" class="headerlink" title="Redis缓存优化"></a>Redis缓存优化</h1><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>如果想使用Redis缓存进行优化，首先你需要连接什么是Redis缓存，以及Spring提供的一种操作Redis缓存的框架：Spring-data-redis。最终要的是：你需要在本地电脑上安装好Redis缓存服务器：</p>
<p>所以呢，我推荐你看一下我的几篇文章：</p>
<ul>
<li><p><a href="http://tycoding.cn/2018/09/24/other/redis/" target="_blank" rel="noopener">Redis即Spring-data-redis入门学习</a></p>
</li>
<li><p><a href="https://github.com/TyCoding/ssm-redis-solr" target="_blank" rel="noopener">优雅的整合SSM+Shiro+Redis+Solr框架</a></p>
</li>
</ul>
<p>在看了上面的文章后相信你已经初步了解了使用Spring-data-redis操作Redis缓存服务器，下面讲解针对本项目的缓存优化实现：</p>
<p>启动安装好的Redis缓存服务器，修改项目中的 <a href="https://github.com/TyCoding/springboot-seckill/blob/master/src/main/resources/application.yml" target="_blank" rel="noopener">resources/application.yml</a> 关于Redis和Jedis的配置，</p>
<p>例中我使用的本地Redis服务器：host：127.0.0.1；port：6379</p>
<h2 id="添加Redis、Jedis缓存配置"><a href="#添加Redis、Jedis缓存配置" class="headerlink" title="添加Redis、Jedis缓存配置"></a>添加Redis、Jedis缓存配置</h2><p>这里我们依赖:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- redis客户端 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>同时我们需要在<code>application.yml</code>中配置缓存：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">#redis缓存</span><br><span class="line">redis:</span><br><span class="line">  #redis数据库索引，默认是0</span><br><span class="line">  database: 0</span><br><span class="line">  #redis服务器地址，这里用本地的redis</span><br><span class="line">  host: 127.0.0.1</span><br><span class="line">  # Redis服务器连接密码（默认为空）</span><br><span class="line">  password:</span><br><span class="line">  #redis服务器连接端口，默认是6379</span><br><span class="line">  port: 6379</span><br><span class="line">  # 连接超时时间（毫秒）</span><br><span class="line">  timeout: 1000</span><br><span class="line">  jedis:</span><br><span class="line">    pool:</span><br><span class="line">      # 连接池最大连接数（使用负值表示没有限制）</span><br><span class="line">      max-active: 8</span><br><span class="line">      # 连接池最大阻塞等待时间（使用负值表示没有限制</span><br><span class="line">      max-wait: -1</span><br><span class="line">      # 连接池中的最大空闲连接</span><br><span class="line">      max-idle: 8</span><br><span class="line">      # 连接池中的最小空闲连接</span><br><span class="line">      min-idle: 0</span><br></pre></td></tr></table></figure>

<h3 id="实现Redis的序列化"><a href="#实现Redis的序列化" class="headerlink" title="实现Redis的序列化"></a>实现Redis的序列化</h3><blockquote>
<p>1.创建JedisConfig</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(JedisConfig.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.redis.host&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.redis.port&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.redis.timeout&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> timeout;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.redis.jedis.pool.max-active&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxActive;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.redis.jedis.pool.max-idle&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxIdle;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.redis.jedis.pool.min-idle&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> minIdle;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.redis.jedis.pool.max-wait&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> maxWaitMillis;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JedisPool <span class="title">redisPoolFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line">        JedisPoolConfig jedisPoolConfig = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">        jedisPoolConfig.setMaxIdle(maxIdle);</span><br><span class="line">        jedisPoolConfig.setMaxWaitMillis(maxWaitMillis);</span><br><span class="line">        jedisPoolConfig.setMaxTotal(maxActive);</span><br><span class="line">        jedisPoolConfig.setMinIdle(minIdle);</span><br><span class="line">        JedisPool jedisPool = <span class="keyword">new</span> JedisPool(jedisPoolConfig, host, port, timeout, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">"JedisPool注入成功"</span>);</span><br><span class="line">        logger.info(<span class="string">"redis地址："</span> + host + <span class="string">":"</span> + port);</span><br><span class="line">        <span class="keyword">return</span> jedisPool;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是为了将我们在<code>application.yml</code>中配置的参数注入到JedisPool中，使用Spring的<code>@Value</code>注解能读取到Spring配置文件中已经配置的参数的值</p>
<blockquote>
<p>2.创建RedisTemplateConfig</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTemplateConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span></span>&#123;</span><br><span class="line">        Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer&lt;Object&gt;(Object.class);</span><br><span class="line">        ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; redisTemplate = <span class="keyword">new</span> RedisTemplate&lt;String, Object&gt;();</span><br><span class="line">        redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        redisTemplate.setKeySerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        redisTemplate.setHashKeySerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        redisTemplate.afterPropertiesSet();</span><br><span class="line">        logger.info(<span class="string">"RedisTemplate序列化配置，转化方式："</span> + jackson2JsonRedisSerializer.getClass().getName());</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一步才是真正实现Redis序列化的配置，当然，不实现序列化也是可以的，舍去上面两步，我们依然可以将数据放入到Redis缓存中。所以我们需要注意以下几点：</p>
<ul>
<li><p>实现序列化目前而言不是必须的，因为我们使用了Spring-data-redis提供的高度封装的RedisTemplate模板类。</p>
</li>
<li><p>SpringBoot2.x实现Redis的序列化仍是由很多方案，但是我这里使用了Spring-data-redis提供的一种jackson2JsonRedisSerializer的序列化方式。</p>
</li>
<li><p>如果不实现Redis的序列化，可以往Redis中存入数据，但是存入的key都是乱码的，想要避免这一点就必须实现序列化。</p>
</li>
<li><p>这个步骤和我们之前<a href="https://github.com/TyCoding/ssm-redis-solr" target="_blank" rel="noopener">整合SSM+Redis+Shiro+Solr框架</a>中已经讲到了用XML实现序列化配置，这里仅是换成了Java配置而已。</p>
</li>
</ul>
<h2 id="优化findAll方法"><a href="#优化findAll方法" class="headerlink" title="优化findAll方法"></a>优化findAll方法</h2><p>秒杀列表（即查询<code>findAll</code>方法）也是经常被访问的，所以我们可以将商品数据放入Redis缓存中</p>
<p>调用<code>findAll()</code>方法得到的是一个List集合，而我们不能直接将一个List集合的数据放入缓存(<code>key-value</code>形式)中，我们必须指定key和value的为实体类中某个属性值。</p>
<p>所以本例中我们采用key: 秒杀商品ID值；value：秒杀商品数据（实体类）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置秒杀redis缓存的key</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String key = <span class="string">"seckill"</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Seckill&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Seckill&gt; seckillList = redisTemplate.boundHashOps(<span class="string">"seckill"</span>).values();</span><br><span class="line">    <span class="keyword">if</span> (seckillList == <span class="keyword">null</span> || seckillList.size() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//说明缓存中没有秒杀列表数据</span></span><br><span class="line">        <span class="comment">//查询数据库中秒杀列表数据，并将列表数据循环放入redis缓存中</span></span><br><span class="line">        seckillList = seckillMapper.findAll();</span><br><span class="line">        <span class="keyword">for</span> (Seckill seckill : seckillList)&#123;</span><br><span class="line">            <span class="comment">//将秒杀列表数据依次放入redis缓存中，key:秒杀表的ID值；value:秒杀商品数据</span></span><br><span class="line">            redisTemplate.boundHashOps(key).put(seckill.getSeckillId(), seckill);</span><br><span class="line">            logger.info(<span class="string">"findAll -&gt; 从数据库中读取放入缓存中"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        logger.info(<span class="string">"findAll -&gt; 从缓存中读取"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> seckillList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优化exportSeckillUrl方法"><a href="#优化exportSeckillUrl方法" class="headerlink" title="优化exportSeckillUrl方法"></a>优化exportSeckillUrl方法</h2><p><code>exportSeckillUrl()</code>暴露接口的方法也是常调用的，因为其中要频繁的调用<code>findById()</code>方法，所以将指定ID的商品数据放入缓存中也是很必要的，当然我们在之前的findAll()方法中已经将每个ID的数据都分别放入了缓存中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Exposer <span class="title">exportSeckillUrl</span><span class="params">(<span class="keyword">long</span> seckillId)</span> </span>&#123;</span><br><span class="line">    Seckill seckill = (Seckill) redisTemplate.boundHashOps(key).get(seckillId);</span><br><span class="line">    <span class="keyword">if</span> (seckill == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//说明redis缓存中没有此key对应的value</span></span><br><span class="line">        <span class="comment">//查询数据库，并将数据放入缓存中</span></span><br><span class="line">        seckill = seckillMapper.findById(seckillId);</span><br><span class="line">        <span class="keyword">if</span> (seckill == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//说明没有查询到</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Exposer(<span class="keyword">false</span>, seckillId);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//查询到了，存入redis缓存中。 key:秒杀表的ID值； value:秒杀表数据</span></span><br><span class="line">            redisTemplate.boundHashOps(key).put(seckill.getSeckillId(), seckill);</span><br><span class="line">            logger.info(<span class="string">"RedisTemplate -&gt; 从数据库中读取并放入缓存中"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.info(<span class="string">"RedisTemplate -&gt; 从缓存中读取"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Date startTime = seckill.getStartTime();</span><br><span class="line">    Date endTime = seckill.getEndTime();</span><br><span class="line">    <span class="comment">//获取系统时间</span></span><br><span class="line">    Date nowTime = <span class="keyword">new</span> Date();</span><br><span class="line">    <span class="keyword">if</span> (nowTime.getTime() &lt; startTime.getTime() || nowTime.getTime() &gt; endTime.getTime()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Exposer(<span class="keyword">false</span>, seckillId, nowTime.getTime(), startTime.getTime(), endTime.getTime());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//转换特定字符串的过程，不可逆的算法</span></span><br><span class="line">    String md5 = getMD5(seckillId);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Exposer(<span class="keyword">true</span>, md5, seckillId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优化executeSeckill方法"><a href="#优化executeSeckill方法" class="headerlink" title="优化executeSeckill方法"></a>优化executeSeckill方法</h2><p>上面的两个查询操作都将商品数据放入了缓存中，key:商品ID；value:商品数据（实体类）。而对于减库存操作，用户每次抢购一件商品，商品的库存总量都需要-1，但是我们页面展示的数据都是从缓存中读取的，即使修改了数据库中的库存数量，页面上展示的数量仍是无法修改的，所以我们同时要修改缓存中的数据来保证缓存和数据库数据的一致性。</p>
<p>更新缓存的办法就简单了，即重新<code>put</code>进去数据就行了，因为Redis缓存数据库中存放的数据是key-value形式，你重新对指定key put进去新的值，就势必会覆盖掉原来的值（这也就是我们为什么设计key:商品ID；value:商品数据）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SeckillExecution <span class="title">executeSeckill</span><span class="params">(<span class="keyword">long</span> seckillId, BigDecimal money, <span class="keyword">long</span> userPhone, String md5)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> SeckillException, RepeatKillException, SeckillCloseException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (md5 == <span class="keyword">null</span> || !md5.equals(getMD5(seckillId))) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SeckillException(<span class="string">"seckill data rewrite"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//执行秒杀逻辑：1.减库存；2.储存秒杀订单</span></span><br><span class="line">        Date nowTime = <span class="keyword">new</span> Date();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//记录秒杀订单信息</span></span><br><span class="line">            <span class="keyword">int</span> insertCount = seckillOrderMapper.insertOrder(seckillId, money, userPhone);</span><br><span class="line">            <span class="comment">//唯一性：seckillId,userPhone，保证一个用户只能秒杀一件商品</span></span><br><span class="line">            <span class="keyword">if</span> (insertCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//重复秒杀</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RepeatKillException(<span class="string">"seckill repeated"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//减库存</span></span><br><span class="line">                <span class="keyword">int</span> updateCount = seckillMapper.reduceStock(seckillId, nowTime);</span><br><span class="line">                <span class="keyword">if</span> (updateCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//没有更新记录，秒杀结束</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> SeckillCloseException(<span class="string">"seckill is closed"</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//秒杀成功</span></span><br><span class="line">                    SeckillOrder seckillOrder = seckillOrderMapper.findById(seckillId);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//更新缓存（更新库存数量）</span></span><br><span class="line">                    Seckill seckill = (Seckill) redisTemplate.boundHashOps(key).get(seckillId);</span><br><span class="line">                    seckill.setStockCount(seckill.getSeckillId() - <span class="number">1</span>);</span><br><span class="line">                    redisTemplate.boundHashOps(key).put(seckillId, seckill);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> SeckillExecution(seckillId, SeckillStatEnum.SUCCESS, seckillOrder);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SeckillCloseException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RepeatKillException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(e.getMessage(), e);</span><br><span class="line">            <span class="comment">//所有编译期异常，转换为运行期异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SeckillException(<span class="string">"seckill inner error:"</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<br>

<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot实现Java高并发秒杀系统之Web层开发（三）</title>
    <url>/2018/10/14/ssm/seckill-web/</url>
    <content><![CDATA[<p>接着上一篇文章：<a href="http://tycoding.cn/2018/10/13/ssm/seckill-service/" target="_blank" rel="noopener">SpringBoot实现Java高并发之Service层开发</a>，今天我们开始讲SpringBoot实现Java高并发秒杀系统之Web层开发。</p>
<p>Web层即Controller层，当然我们所说的都是在基于Spring框架的系统上而言的，传统的SSH项目中，与页面进行交互的是struts框架，但struts框架很繁琐，后来就被SpringMVC给顶替了，SpringMVC框架在与页面的交互上提供了更加便捷的方式，MVC的设计模式也是当前非常流行的一种设计模式。这次我们针对秒杀系统讲解一下秒杀系统需要和页面交互的操作和数据都涉及哪些？</p>
<p>本项目的源码请参看：<a href="https://github.com/TyCoding/springboot-seckill" target="_blank" rel="noopener">springboot-seckill</a>  如果觉得不错可以star一下哦(#^.^#)</p>
<a id="more"></a>

<p>本项目一共分为四个模块来讲解，具体的开发教程请看我的博客文章：</p>
<ul>
<li><p><a href="http://tycoding.cn/2018/10/12/ssm/seckill-dao/" target="_blank" rel="noopener">SpringBoot实现Java高并发秒杀系统之DAO层开发（一）</a></p>
</li>
<li><p><a href="http://tycoding.cn/2018/10/13/ssm/seckill-service/" target="_blank" rel="noopener">SpringBoot实现Java高并发秒杀系统之Service层开发（二）</a></p>
</li>
<li><p><a href="http://tycoding.cn/2018/10/14/ssm/seckill-web/" target="_blank" rel="noopener">SpringBoot实现Java高并发秒杀系统之Web层开发（三）</a></p>
</li>
<li><p><a href="http://tycoding.cn/2018/10/15/ssm/seckill/" target="_blank" rel="noopener">SpringBoot实现Java高并发秒杀系统之并发优化（四）</a></p>
</li>
</ul>
<p>首先如果你对SpringBoot项目还是不清楚的话，我依然推荐你看一下我的这个项目：<a href="https://github.com/TyCoding/spring-boot" target="_blank" rel="noopener">优雅的入门SpringBoot2.x，整合Mybatis实现CRUD</a></p>
<h1 id="前端交互流程设计"><a href="#前端交互流程设计" class="headerlink" title="前端交互流程设计"></a>前端交互流程设计</h1><p>编写Controller就是要搞清楚：1.页面需要什么数据？2.页面将返回给Controller什么数据？3.Controller应该返回给页面什么数据？</p>
<p>带着这些问题我们看一下秒杀详情页流程逻辑（不再讲基本的<code>findById</code>和<code>findAll()</code>方法）：</p>
<p><img src="/2018/10/14/ssm/seckill-web/1.png" alt></p>
<p>因为整个秒杀系统中最核心的业务就是：1.减库存；2.查询订单明细。我们看一下Controller层的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/seckill"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeckillController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SeckillService seckillService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/findAll"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Seckill&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seckillService.findAll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/findById"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Seckill <span class="title">findById</span><span class="params">(@RequestParam(<span class="string">"id"</span>)</span> Long id) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seckillService.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/&#123;seckillId&#125;/detail"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">detail</span><span class="params">(@PathVariable(<span class="string">"seckillId"</span>)</span> Long seckillId, Model model) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (seckillId == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"page/seckill"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Seckill seckill = seckillService.findById(seckillId);</span><br><span class="line">        model.addAttribute(<span class="string">"seckill"</span>, seckill);</span><br><span class="line">        <span class="keyword">if</span> (seckill == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"page/seckill"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"page/seckill_detail"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/&#123;seckillId&#125;/exposer"</span>,</span><br><span class="line">            method = RequestMethod.POST, produces = &#123;<span class="string">"application/json;charset=UTF-8"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SeckillResult&lt;Exposer&gt; <span class="title">exposer</span><span class="params">(@PathVariable(<span class="string">"seckillId"</span>)</span> Long seckillId) </span>&#123;</span><br><span class="line">        SeckillResult&lt;Exposer&gt; result;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Exposer exposer = seckillService.exportSeckillUrl(seckillId);</span><br><span class="line">            result = <span class="keyword">new</span> SeckillResult&lt;Exposer&gt;(<span class="keyword">true</span>, exposer);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(e.getMessage(), e);</span><br><span class="line">            result = <span class="keyword">new</span> SeckillResult&lt;Exposer&gt;(<span class="keyword">false</span>, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/&#123;seckillId&#125;/&#123;md5&#125;/execution"</span>,</span><br><span class="line">            method = RequestMethod.POST,</span><br><span class="line">            produces = &#123;<span class="string">"application/json;charset=UTF-8"</span>&#125;)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SeckillResult&lt;SeckillExecution&gt; <span class="title">execute</span><span class="params">(@PathVariable(<span class="string">"seckillId"</span>)</span> Long seckillId,</span></span><br><span class="line"><span class="function">                                                   @<span class="title">PathVariable</span><span class="params">(<span class="string">"md5"</span>)</span> String md5,</span></span><br><span class="line"><span class="function">                                                   @<span class="title">RequestParam</span><span class="params">(<span class="string">"money"</span>)</span> BigDecimal money,</span></span><br><span class="line"><span class="function">                                                   @<span class="title">CookieValue</span><span class="params">(value = <span class="string">"killPhone"</span>, required = <span class="keyword">false</span>)</span> Long userPhone) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (userPhone == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SeckillResult&lt;SeckillExecution&gt;(<span class="keyword">false</span>, <span class="string">"未注册"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SeckillExecution execution = seckillService.executeSeckill(seckillId, money, userPhone, md5);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SeckillResult&lt;SeckillExecution&gt;(<span class="keyword">true</span>, execution);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RepeatKillException e) &#123;</span><br><span class="line">            SeckillExecution seckillExecution = <span class="keyword">new</span> SeckillExecution(seckillId, SeckillStatEnum.REPEAT_KILL);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SeckillResult&lt;SeckillExecution&gt;(<span class="keyword">true</span>, seckillExecution);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SeckillCloseException e) &#123;</span><br><span class="line">            SeckillExecution seckillExecution = <span class="keyword">new</span> SeckillExecution(seckillId, SeckillStatEnum.END);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SeckillResult&lt;SeckillExecution&gt;(<span class="keyword">true</span>, seckillExecution);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SeckillException e) &#123;</span><br><span class="line">            SeckillExecution seckillExecution = <span class="keyword">new</span> SeckillExecution(seckillId, SeckillStatEnum.INNER_ERROR);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SeckillResult&lt;SeckillExecution&gt;(<span class="keyword">true</span>, seckillExecution);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(value = <span class="string">"/time/now"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SeckillResult&lt;Long&gt; <span class="title">time</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Date now = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SeckillResult(<span class="keyword">true</span>, now.getTime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我以问答的形式讲解一下Controller层方法的定义：</p>
<blockquote>
<p>1.<code>@ResponseBody</code>和<code>@RestController</code>注解分别有什么作用？</p>
</blockquote>
<ul>
<li><p><code>@ResponseBody</code>注解标识的方法，Spring会将此方法return的数据转换成JSON格式且不会被Spring视图解析器所扫描到，也就是此方法永不可能返回一个视图页面。且这个注解只能用在方法体上，不能用在类上。</p>
</li>
<li><p><code>@RestController</code>注解标识的类，Spring会将其下的所有方法return的数据都转换成JSON格式且不会被Spring视图解析器扫描到，也就是此类下面的所有方法都不可能返回一个视图页面。且这个注解只能用在类上，不能用在方法体上。</p>
</li>
</ul>
<blockquote>
<p>2.<code>@RequestMapping</code>中<code>{xx}</code>的语法是什么？<code>@PathVariable</code>注解的用处是什么？</p>
</blockquote>
<p>Spring框架很早就支持开发REST资源。也是就是现在我们定义的RESTful URL，在Spring框架上支持的尤为完美，我们可以在Controller中定义这样一个URL映射地址：<code>/{id}/detail</code>，他是合理的RESTful URL定义方式。</p>
<p>这种URL的特点：URL地址由动态的数据拼接组成的，而不是将所有的资源全部映射到一个路径下，比如：<code>/article/detail</code>。</p>
<p>这种URL结构的优势：我们能很容易从URL地址上判断出该地址所展示的页面是什么？比如：<code>/1/detail</code>就可能表示ID为1的文章的详情页，看起来设计的很清晰。</p>
<p>这种URL如何进行交互：我们定义了<code>/{id}/detail</code>这样一个URL映射地址，其对应的映射方法上就应该添加<code>@PathVariable</code>注解标识，如：<code>@PathVariable(&quot;id&quot;) Long id</code>Spring就能装配前端传递的URL中指定位置的数据并赋值给<code>id</code>这个参数。比如前端调用后端接口：<code>localhost:8080/seckill/1/detail</code>，后端存在一个映射方法：<code>@RequestMapping(&quot;/{id}/detail&quot;)</code>，这样就能刚好匹配上这个URL映射地址。</p>
<p>所以我们看一下秒杀系统的RESTful URL设计：</p>
<p><img src="/2018/10/14/ssm/seckill-web/2.png" alt></p>
<blockquote>
<p>3.为什么要单独写一个接口用来获取当前系统时间？</p>
</blockquote>
<p>由于我们开发的系统肯定不是给自己用的，我们的用户可能处于不同的时区，他们的当前系统时间也是不同的，所以我们写一个通用的时间规范：就是当前服务器的时间。</p>
<blockquote>
<p>4.SeckillResult是什么？</p>
</blockquote>
<p>在前面我们将Service层系统开发的时候就手动创建了很多类来封装一些通用的结果信息。而对于Controller层也会返回很多结果数据，比如传入的URL中id值为null，那么就没必要继续向下请求，而是直接给页面返回false信息。</p>
<p>于是我们创建：<code>SeckillResult.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeckillResult</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> success;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String error;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SeckillResult</span><span class="params">(<span class="keyword">boolean</span> success, T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.success = success;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SeckillResult</span><span class="params">(<span class="keyword">boolean</span> success, String error)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.success = success;</span><br><span class="line">        <span class="keyword">this</span>.error = error;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型<code>T</code>表示可以代表不同类型的对象。这是泛型类应用很广泛的一个特性，我们调用SeckillResult类，将其中的T用什么替换那么T就表示这个替换的对象类型。</p>
<h1 id="页面设计"><a href="#页面设计" class="headerlink" title="页面设计"></a>页面设计</h1><p><strong>用了哪些技术？</strong></p>
<ol>
<li>HTML页面，用Bootstrap绘制。</li>
<li>Thymeleaf模板引擎渲染HTML页面，使得HTML页面拥有类似JSP页面一样功能。</li>
<li>JS方面使用原生的JQuery。</li>
</ol>
<p>我们来看一下前端的页面设计：</p>
<p><img src="/2018/10/14/ssm/seckill-web/3.png" alt></p>
<p>本项目使用Cookie存储用户手机号的方式模拟用户登录功能，实际上没有与后端交互的操作。如果用户没有登录就打开了商品详情页会直接弹出一个手机号登录框提醒用户登录，且没有登录时无法关闭登录框的。</p>
<p>具体的源码请看：<a href="https://github.com/TyCoding/spring-boot/tree/master/src/main/resources" target="_blank" rel="noopener">GitHub</a></p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>在从JSP页面转换到HTML页面的时候我常会遇到这么一个问题：前端如何取出来后端查询到的数据？</p>
<p>在之前我们写的JSP页面中，可以通过将后端查询到的数据放进request,session域对象中，JSP页面可以直接调用Java中域对象的数据，甚至可以通过EL表达式（<code>${}</code>）来直接获取参数，但是这种方法有一个弊端：Controller必须是返回一个视图，这样才能在此视图中获取存进域对象中的数据。</p>
<p>而我们现在都开始用HTML页面，也无法从域对象中取出数据该怎么办呢？我这里提供两个思路：</p>
<ul>
<li><p>1.像本项目中一样，前端使用Thymeleaf模板引擎渲染页面，那么Thymeleaf内置很多方法如同JSP页面的EL表达式。Thymeleaf在HTML中取出域对象数据使用：<code>&lt;span th:text=&quot;${xx}&quot;&gt;</code>；在JS中取出域对象数据：<code>var v = [[${xx}]]</code>（当然都必须是在HTML页面中，在外部JS文件中是得不到数据的）。</p>
</li>
<li><p>2.使用原生js提供的<code>location</code>对象，我们先看一下URL的组成结构：</p>
</li>
</ul>
<p><img src="/2018/10/14/ssm/seckill-web/4.png" alt></p>
<p>详细介绍请看：<a href="https://blog.csdn.net/J_Y_X_8/article/details/51272098?locationNum=9&fps=1" target="_blank" rel="noopener">博文</a></p>
<p><strong>举个栗子</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">QueryUrl</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">     <span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"(^|&amp;)"</span>+ name +<span class="string">"=([^&amp;]*)(&amp;|$)"</span>);</span><br><span class="line">     <span class="keyword">var</span> r = <span class="built_in">window</span>.location.search.substr(<span class="number">1</span>).match(reg);</span><br><span class="line">     <span class="keyword">if</span>(r!=<span class="literal">null</span>)<span class="keyword">return</span>  <span class="built_in">unescape</span>(r[<span class="number">2</span>]); <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方法</span></span><br><span class="line">alert(QueryUrl(<span class="string">"参数名1"</span>));</span><br></pre></td></tr></table></figure>

<br>

<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot实现Java高并发秒杀系统之Service层开发（二）</title>
    <url>/2018/10/13/ssm/seckill-service/</url>
    <content><![CDATA[<p>继上一篇文章：<a href="http://tycoding.cn/2018/10/12/ssm/seckill-dao/" target="_blank" rel="noopener">SpringBoot实现Java高并发秒杀系统之DAO层开发</a> 我们创建了SpringBoot项目并熟悉了秒杀系统的表设计，下面我们将讲解一下秒杀系统的核心部分：Service业务层的开发。</p>
<p>Service层又称为业务层，在Spring阶段主要是由<code>@Service</code>注解标记的一层，包含Service业务接口的开发和业务接口实现类的开发，这里我们将讲解如何优雅的设计业务层接口以及针对秒杀系统业务层的优化技术等和针对高并发的解决方案。</p>
<p>本项目的源码请参看：<a href="https://github.com/TyCoding/springboot-seckill" target="_blank" rel="noopener">springboot-seckill</a>  如果觉得不错可以star一下哦(#^.^#)</p>
<a id="more"></a>

<p>本项目一共分为四个模块来讲解，具体的开发教程请看我的博客文章：</p>
<ul>
<li><p><a href="http://tycoding.cn/2018/10/12/ssm/seckill-dao/" target="_blank" rel="noopener">SpringBoot实现Java高并发秒杀系统之DAO层开发（一）</a></p>
</li>
<li><p><a href="http://tycoding.cn/2018/10/13/ssm/seckill-service/" target="_blank" rel="noopener">SpringBoot实现Java高并发秒杀系统之Service层开发（二）</a></p>
</li>
<li><p><a href="http://tycoding.cn/2018/10/14/ssm/seckill-web/" target="_blank" rel="noopener">SpringBoot实现Java高并发秒杀系统之Web层开发（三）</a></p>
</li>
<li><p><a href="http://tycoding.cn/2018/10/15/ssm/seckill/" target="_blank" rel="noopener">SpringBoot实现Java高并发秒杀系统之并发优化（四）</a></p>
</li>
</ul>
<h1 id="Service接口的设计"><a href="#Service接口的设计" class="headerlink" title="Service接口的设计"></a>Service接口的设计</h1><p>之前我们写好了DAO层的接口，这里我们要开始着手编写业务层接口，然后编写业务层接口的实现类并编写业务层的核心逻辑。</p>
<p>设计业务层接口，应该站在<strong>使用者</strong>角度上设计，如我们应该做到：</p>
<ul>
<li><p>1.定义业务方法的颗粒度要细。</p>
</li>
<li><p>2.方法的参数要明确简练，不建议使用类似Map这种类型，让使用者可以封装进Map中一堆参数而传递进来，尽量精确到哪些参数。</p>
</li>
<li><p>3.方法的return返回值，除了应该明确返回值类型，还应该指明方法执行可能产生的异常(RuntimeException)，并应该手动封装一些通用的异常处理机制。</p>
</li>
</ul>
<p>类比DAO层接口的定义，我这里先给出完整的<code>SeckillService.java</code>的定义（注意：在DAO层（Mapper）中我们定义了两个接口<code>SeckillMapper</code>和<code>SeckillOrderMapper</code>，但是Service层接口为1个）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SeckillService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取所有的秒杀商品列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;Seckill&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取某一条商品秒杀信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> seckillId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Seckill <span class="title">findById</span><span class="params">(<span class="keyword">long</span> seckillId)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 秒杀开始时输出暴露秒杀的地址</span></span><br><span class="line"><span class="comment">     * 否者输出系统时间和秒杀时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> seckillId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Exposer <span class="title">exportSeckillUrl</span><span class="params">(<span class="keyword">long</span> seckillId)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行秒杀的操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> seckillId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userPhone</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> md5</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">SeckillExecution <span class="title">executeSeckill</span><span class="params">(<span class="keyword">long</span> seckillId, BigDecimal money, <span class="keyword">long</span> userPhone, String md5)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> SeckillException, RepeatKillException, SeckillCloseException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我将依次讲解一下为什么接口会这样设计？接口方法的返回值是怎样定义的？</p>
<h2 id="findById和findAll方法"><a href="#findById和findAll方法" class="headerlink" title="findById和findAll方法"></a>findById和findAll方法</h2><p>这两个方法就简单很多：</p>
<ul>
<li><p>findById(): 顾名思义根据ID主键查询。按照接口的设计我们需要指定参数是<code>seckillId</code>(秒杀商品的ID值。注意：这里定义为<code>long</code>类型，不要定义为包装类类型，因为包装类类型不能直接进行大小比较，必须转换为基本类型才能进行值大小比较）；返回值自然是查询到的商品表数据级<code>Seckill</code>实体类了。</p>
</li>
<li><p>findAll(): 顾名思义是查询数据库中所有的秒杀商品表的数据，因为记录数不止一条，所以一般就用List集合接收，并制定泛型是<code>List&lt;Seckill&gt;</code>，表示从数据库中查询到的列表数据都是Seckill实体类对应的数据，并以Seckill实体类的结构将列表数据封装到List集合中。</p>
</li>
</ul>
<h2 id="exportSeckillUrl方法"><a href="#exportSeckillUrl方法" class="headerlink" title="exportSeckillUrl方法"></a>exportSeckillUrl方法</h2><p><code>exportSeckillUrl()</code>方法可有的讲了，他是<strong>暴露接口</strong>用到的方法，目的就是<strong>获取秒杀商品抢购的地址</strong>。</p>
<blockquote>
<p>1.为什么要单独创建一个方法来获取秒杀地址？</p>
</blockquote>
<p>在之前我们做的后端项目中，跳转到某个详情页一般都是：根据ID查询该详情数据，然后将页面跳转到详情页并将数据直接渲染到页面上。但是秒杀系统不同，它也不能就这样简单的定义，要知道秒杀技术的难点就是如何应对高并发？同一件商品，比如瞬间有十万的用户访问，而还存在各种黄牛，有各种工具去抢购这个商品，那么此时肯定不止10万的访问量的，并且开发者要尽量的保证每个用户抢购的公平性，也就是不能让一个用户抢购一堆数量的此商品。</p>
<p>这就是我们常说的<strong>接口防刷</strong>问题。因此单独定义一个获取秒杀接口的方法是有必要的。</p>
<blockquote>
<p>2.如何做到接口防刷？</p>
</blockquote>
<p>接口方法：<code>Exposer exportSeckillUrl(long seckillId);</code>从参数列表中很易明白：就是根据该商品的ID获取到这个商品的秒杀url地址；但是返回值类型<code>Exposer</code>是什么呢？</p>
<p>思考一下如何做到<strong>接口防刷？</strong> </p>
<ol>
<li><p>首先要保证该商品处于秒杀状态。也就是1.秒杀开始时间要&lt;当前时间；2.秒杀截止时间要&gt;当前时间。</p>
</li>
<li><p>要保证一个用户只能抢购到一件该商品，应做到商品秒杀接口对应同一用户只能有唯一的一个URL秒杀地址，不同用户间秒杀地址应是不同的，且配合订单表<code>seckill_order</code>中<em>联合主键</em>的配置实现。</p>
</li>
</ol>
<p>针对上面的两条分析，我们给出<code>Exposer</code>的设计（要注意此类定义在<code>/dto/</code>路径下表明此类是我们手动封装的结果属性，它类似JavaBean但又不属于，仅用来封装秒杀状态的结果，目的是提高代码的重用率）：</p>
<p>此例源码请看：<a href="https://github.com/TyCoding/springboot-seckill/tree/master/src/main/java/cn/tycoding/dto" target="_blank" rel="noopener">GitHub</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exposer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否开启秒杀</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> exposed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加密措施，避免用户通过抓包拿到秒杀地址</span></span><br><span class="line">    <span class="keyword">private</span> String md5;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ID</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> seckillId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//系统当前时间（毫秒）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> now;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//秒杀开启时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> start;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//秒杀结束时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Exposer</span><span class="params">(<span class="keyword">boolean</span> exposed, String md5, <span class="keyword">long</span> seckillId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.exposed = exposed;</span><br><span class="line">        <span class="keyword">this</span>.md5 = md5;</span><br><span class="line">        <span class="keyword">this</span>.seckillId = seckillId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Exposer</span><span class="params">(<span class="keyword">boolean</span> exposed, Long seckillId, <span class="keyword">long</span> now, <span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.exposed = exposed;</span><br><span class="line">        <span class="keyword">this</span>.seckillId = seckillId;</span><br><span class="line">        <span class="keyword">this</span>.now = now;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Exposer</span><span class="params">(<span class="keyword">boolean</span> exposed, <span class="keyword">long</span> seckillId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.exposed = exposed;</span><br><span class="line">        <span class="keyword">this</span>.seckillId = seckillId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上我们封装的结果类可以满足我们的需求：1.首先指明商品当前秒杀状态：秒杀未开始、秒杀进行中、秒杀已结束；2.如果秒杀未开始返回false和相关时间用于前端展示秒杀倒计时；3。如果秒杀已经结束就返回false和当前商品的ID；3.如果秒杀正在进行中就返回该商品的秒杀地址（md5混合值，避免用户抓包拿到秒杀地址）。</p>
<h2 id="executeSeckill方法"><a href="#executeSeckill方法" class="headerlink" title="executeSeckill方法"></a>executeSeckill方法</h2><p>这里我们再回顾一下秒杀系统的业务分析：</p>
<p><img src="/2018/10/13/ssm/seckill-service/1.png" alt></p>
<p>可以看到，秒杀的业务逻辑很清晰，用户抢购了商品业务层需要完成：1.减库存；2.储存用户秒杀订单明细。而因为储存订单明细应该是在用户成功秒杀到订单后才执行的操作，所以并不需要定义在Service接口中。那么我们就看一下用户针对库存的业务分析：</p>
<p><img src="/2018/10/13/ssm/seckill-service/2.png" alt></p>
<p>可以看到针对库存业务其实还是两个操作：1.减库存；2.记录购买明细。但是其中涉及到很多事物操作和性能优化问题我们放在后面讲。这里我们将这两个操作合并为一个接口方法：执行秒杀的操作。</p>
<p>所以再看一下我们对<code>exexuteSeckill()</code>方法的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">SeckillExecution <span class="title">executeSeckill</span><span class="params">(<span class="keyword">long</span> seckillId, BigDecimal money, <span class="keyword">long</span> userPhone, String md5)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> SeckillException, RepeatKillException, SeckillCloseException</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1.分析参数列表</p>
</blockquote>
<p>由于<code>executeSeckill()</code>方法涉及：1.减库存；2.记录购买明细。因为我们的项目不涉及复杂的数据，所以没有太多的明细参数（用<code>money</code>替代）。那么当前参数分别有何作用？</p>
<ul>
<li><p><code>seckillId</code>和<code>userPhone</code>用于在insert订单明细时进行防重复秒杀；只要有相同的<code>seckillId</code>和<code>userPhone</code>就一定主键冲突报错。</p>
</li>
<li><p><code>seckillId</code>和<code>md5</code>用于组成秒杀接口地址的一部分，当用户点击抢购时获取到之前暴露的秒杀地址中的md5值和当前传入的md5值进行比较，如果匹配再进行下一步操作。</p>
</li>
</ul>
<blockquote>
<p>2.分析返回值类型</p>
</blockquote>
<p>和在设计<code>exportSeckillUrl</code>接口方法时一样，针对秒杀操作也应该包含很多返回数据，比如：秒杀结束、秒杀成功、秒杀系统异常…信息，我们也将这些信息用类封装在dto文件夹中。于是我们的返回值<code>SeckillExecution</code>类定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeckillExecution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long seckillId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//秒杀执行结果状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//状态表示</span></span><br><span class="line">    <span class="keyword">private</span> String stateInfo;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//秒杀成功的订单对象</span></span><br><span class="line">    <span class="keyword">private</span> SeckillOrder seckillOrder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SeckillExecution</span><span class="params">(Long seckillId, <span class="keyword">int</span> state, String stateInfo, SeckillOrder seckillOrder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.seckillId = seckillId;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">        <span class="keyword">this</span>.stateInfo = stateInfo;</span><br><span class="line">        <span class="keyword">this</span>.seckillOrder = seckillOrder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SeckillExecution</span><span class="params">(Long seckillId, <span class="keyword">int</span> state, String stateInfo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.seckillId = seckillId;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">        <span class="keyword">this</span>.stateInfo = stateInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>state</code>用于-1,0,1这种状态的表示，这些数字分别被赋予不同的含义，后面讲到。<code>stateInfo</code>表示<code>state</code>状态数字的中文解释，比如：秒杀成功、秒杀结束、秒杀系统异常等信息。</p>
<blockquote>
<p>3.分析异常</p>
</blockquote>
<p>减库存操作和插入购买明细操作都会产生很多未知异常（RuntimeException），比如秒杀结束、重复秒杀等。除了要返回这些异常信息，还有一个非常重要的操作就是捕获这些RuntimeException，从而避免系统直接报错。</p>
<p>针对秒杀关闭的异常，我们定义<code>SeckillCloseException.java</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeckillCloseException</span> <span class="keyword">extends</span> <span class="title">SeckillException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SeckillCloseException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SeckillCloseException</span><span class="params">(String message, Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对重复秒杀的异常，我们定义<code>RepeatKillException.java</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RepeatKillException</span> <span class="keyword">extends</span> <span class="title">SeckillException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RepeatKillException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RepeatKillException</span><span class="params">(String message, Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，系统还可能出现其他位置异常，所以我们还需要定义一个异常继承所有异常的父类Exception:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeckillException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SeckillException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SeckillException</span><span class="params">(String message, Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h1 id="ServiceImpl实现类的设计"><a href="#ServiceImpl实现类的设计" class="headerlink" title="ServiceImpl实现类的设计"></a>ServiceImpl实现类的设计</h1><p>我们在<code>src/cn/tycoding/service/impl</code>下创建Service接口的实现类： <a href="https://github.com/TyCoding/springboot-seckill/blob/master/src/main/java/cn/tycoding/service/impl/SeckillServiceImpl.java" target="_blank" rel="noopener">SeckillServiceImpl.java</a></p>
<p>在开始讲解之前我们先理解几个概念：</p>
<blockquote>
<p>1.为什么我们的系统需要事务？</p>
</blockquote>
<p>举个栗子：比如a在购买商品A的同时，售卖该商品的商家突然调低了A商品的价格，但此瞬时价格调整还没有更新到数据库用户购买的订单就已经提交了，那么用户不就多掏了钱吗？又比如a购买的商品后库存数量减少的sql还没有更新到数据库，此时瞬间b用户看到还有商品就点击购买了，而此时商品的库存数量其实已经为0了，这样就造成了超卖。</p>
<p>针对上面两个栗子，我们必须要给出解决方案，不然就太坑了。</p>
<blockquote>
<p>2.什么是事务？</p>
</blockquote>
<p>在软件开发领域，<strong>全有或全无的操作称为事务(transaction)。</strong>事务有四个特性，即ACID：</p>
<ul>
<li><strong>原子性</strong>：原子性确保事务中所有操作全部发生或全部不发生。</li>
<li><strong>一致性</strong>：一旦事务完成（不管成功还是失败），系统必须却把它所建模的业务处于一致的状态。</li>
<li><strong>隔离性</strong>：事务允许多个用户对相同的数据进行操作，每个用户的操作不会与其他用户纠缠在一起。</li>
<li><strong>持久性</strong>：一旦事务完成，事务的结果应该持久化，这样就能从任何的系统崩溃中恢复过来。</li>
</ul>
<p><strong>事务常见的问题：</strong></p>
<ul>
<li><strong>更新丢失</strong>：当多个事务选择同一行操作，并且都是基于最初的选定的值，由于每个事务都不知道其他事务的存在，就会发生更新覆盖的问题。</li>
<li><strong>脏读</strong>：事务A读取了事务B已经修改但为提交的数据。若事务B回滚数据，事务A的数据存在不一致的问题。</li>
<li><strong>不可重复读</strong>：书屋A第一次读取最初数据，第二次读取事务B已经提交的修改或删除的数据。导致两次数据读取不一致。不符合事务的隔离性。</li>
<li><strong>幻读</strong>：事务A根据相同条件第二次查询到的事务B提交的新增数据，两次数据结果不一致，不符合事务的隔离性。</li>
</ul>
<blockquote>
<p>3.Spring对事务的控制</p>
</blockquote>
<p>Spring框架针对事务提供了很多事务管理解决方案。我们这里只说常用的：<strong>声明式事务</strong>。声明式事务通过传播行为、隔离级别、只读提示、事务超时及回滚规则来进行定义。我们这里讲用Spring提供的注解式事务方法：<code>@Transaction</code>。</p>
<p>使用注解式事务的优点：开发团队达到一致的约定，明确标注事务方法的编程风格。</p>
<p>使用事务控制需要注意：</p>
<ol>
<li>保证事务方法的执行时间尽可能短，不要穿插其他的网络操作PRC/HTTP请求（可以将这些请求剥离出来）。</li>
<li>不是所有的放阿飞都需要事务控制，如只有一条修改操作、只读操作等是不需要事务控制的。</li>
</ol>
<p><strong>注意</strong></p>
<p>Spring默认只对运行期异常（RuntimeException）进行事务回滚操作，对于编译异常Spring是不进行回滚的，所以对于需要进行事务控制的方法尽量将可能抛出的异常都转换成运行期异常。这也是我们我什么要在Service接口中手动封装一些RuntimeException信息的一个重要原因。</p>
<h2 id="exportSeckillUrl方法-1"><a href="#exportSeckillUrl方法-1" class="headerlink" title="exportSeckillUrl方法"></a>exportSeckillUrl方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeckillServiceImpl</span> <span class="keyword">implements</span> <span class="title">SeckillService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置盐值字符串，随便定义，用于混淆MD5值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String salt = <span class="string">"sjajaspu-i-2jrfm;sd"</span>;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SeckillMapper seckillMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SeckillOrderMapper seckillOrderMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Exposer <span class="title">exportSeckillUrl</span><span class="params">(<span class="keyword">long</span> seckillId)</span> </span>&#123;</span><br><span class="line">        Seckill seckill = seckillMapper.findById(seckillId);</span><br><span class="line">        <span class="keyword">if</span> (seckill == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//说明没有查询到</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Exposer(<span class="keyword">false</span>, seckillId);</span><br><span class="line">        &#125;</span><br><span class="line">        Date startTime = seckill.getStartTime();</span><br><span class="line">        Date endTime = seckill.getEndTime();</span><br><span class="line">        <span class="comment">//获取系统时间</span></span><br><span class="line">        Date nowTime = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="keyword">if</span> (nowTime.getTime() &lt; startTime.getTime() || nowTime.getTime() &gt; endTime.getTime()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Exposer(<span class="keyword">false</span>, seckillId, nowTime.getTime(), startTime.getTime(), endTime.getTime());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//转换特定字符串的过程，不可逆的算法</span></span><br><span class="line">        String md5 = getMD5(seckillId);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Exposer(<span class="keyword">true</span>, md5, seckillId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成MD5值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getMD5</span><span class="params">(Long seckillId)</span> </span>&#123;</span><br><span class="line">        String base = seckillId + <span class="string">"/"</span> + salt;</span><br><span class="line">        String md5 = DigestUtils.md5DigestAsHex(base.getBytes());</span><br><span class="line">        <span class="keyword">return</span> md5;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>exportSeckillUrl()</code>还是比较清晰的，主要逻辑：根据传进来的<code>seckillId</code>查询<code>seckill</code>表中对应数据，如果没有查询到就直接返回<code>Exposer(false,seckillId)</code>标识没有查询到该商品的秒杀接口信息，可能是用户非法输入的数据；如果查询到了，就获取秒杀开始时间和秒杀结束时间以及new一个当前系统时间进行判断当前秒杀商品是否正在进行秒杀活动，还没有开始或已经结束都直接返回<code>Exposer</code>；如果上面两个条件都符合了就证明该商品存在且正在秒杀活动中，那么我们需要暴露秒杀接口地址。</p>
<p>因为我们要做到接口防刷的功能，所以需要生成一串md5值作为秒杀接口中一部分。而Spring提供了一个工具类<code>DigestUtils</code>用于生成MD5值，且又由于要做到更安全所以我们采用md5+盐的加密方式生成一传md5加密数据作为秒杀URL地址的一部分发送给Controller。</p>
<h2 id="executeSeckill方法-1"><a href="#executeSeckill方法-1" class="headerlink" title="executeSeckill方法"></a>executeSeckill方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SeckillExecution <span class="title">executeSeckill</span><span class="params">(<span class="keyword">long</span> seckillId, BigDecimal money, <span class="keyword">long</span> userPhone, String md5)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> SeckillException, RepeatKillException, SeckillCloseException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (md5 == <span class="keyword">null</span> || !md5.equals(getMD5(seckillId))) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SeckillException(<span class="string">"seckill data rewrite"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行秒杀逻辑：1.减库存；2.储存秒杀订单</span></span><br><span class="line">    Date nowTime = <span class="keyword">new</span> Date();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//记录秒杀订单信息</span></span><br><span class="line">        <span class="keyword">int</span> insertCount = seckillOrderMapper.insertOrder(seckillId, money, userPhone);</span><br><span class="line">        <span class="comment">//唯一性：seckillId,userPhone，保证一个用户只能秒杀一件商品</span></span><br><span class="line">        <span class="keyword">if</span> (insertCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//重复秒杀</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RepeatKillException(<span class="string">"seckill repeated"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//减库存</span></span><br><span class="line">            <span class="keyword">int</span> updateCount = seckillMapper.reduceStock(seckillId, nowTime);</span><br><span class="line">            <span class="keyword">if</span> (updateCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//没有更新记录，秒杀结束</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SeckillCloseException(<span class="string">"seckill is closed"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//秒杀成功</span></span><br><span class="line">                SeckillOrder seckillOrder = seckillOrderMapper.findById(seckillId);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> SeckillExecution(seckillId, SeckillStatEnum.SUCCESS, seckillOrder);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SeckillCloseException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RepeatKillException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(e.getMessage(), e);</span><br><span class="line">        <span class="comment">//所有编译期异常，转换为运行期异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SeckillException(<span class="string">"seckill inner error:"</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>executeSeckill</code>方法相对复杂一些，主要涉及两个业务操作：1.减库存（调用<code>reduceStock()</code>）；2.记录订单明细（调用<code>insertOrder()</code>）。我们以一张图来描述一下主要逻辑：</p>
<p><img src="/2018/10/13/ssm/seckill-service/3.png" alt></p>
<p>由此我抛出以下问答：</p>
<blockquote>
<p>1.insertCount和updateCount哪来？</p>
</blockquote>
<p>在之前我们写项目中可能对于insert和update的操作直接设置返回值类型为void，虽然Mybatis的<code>&lt;insert&gt;</code>和<code>&lt;update&gt;</code>语句都没有<code>resultType</code>属性，但是并不带表其没有返回值，默认的返回值是0或1…表示该条SQL影响的行数，如果为0就表示该SQL没有影响数据库，但是为了避免系统遇到错误的SQL返回错误信息而不是直接报错，我们可以在书写SQL时：<code>insert ignore into xxx</code>即用<code>ignore</code>参数，当Mybatis执行该SQL发生异常时直接返回0表示更新失败而不是系统报错。</p>
<blockquote>
<p>2.为什么先记录秒杀订单信息操作再执行减库存操作？</p>
</blockquote>
<p>这里涉及了一个简单的Java并发优化操作，详细内容优化方式请看：<a href>SpringBoot实现Java高并发秒杀系统之系统优化</a></p>
<blockquote>
<p>3.上例中用到的<code>SeckillStatEnum</code>是什么？</p>
</blockquote>
<p>之前我们讲<code>exportSeckillUrl</code>时在<code>/dto/</code>中创建了类<code>Exposer</code>；在讲<code>executeSeckill</code>的时候创建了<code>SeckillExecution</code>类，他们都是用来封装返回的结果信息的，不是说他们是必须的，而是用这种方式会更规范且代码看起来更加整洁，而且我们的代码的重用率会更高。</p>
<p>于是，当用户秒杀成功后其实需要返回一句话<code>秒杀成功</code>即可，但是我们单独提取到了一个枚举类中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SeckillStatEnum &#123;</span><br><span class="line">    SUCCESS(<span class="number">1</span>, <span class="string">"秒杀成功"</span>),</span><br><span class="line">    END(<span class="number">0</span>, <span class="string">"秒杀结束"</span>),</span><br><span class="line">    REPEAT_KILL(-<span class="number">1</span>,<span class="string">"重复秒杀"</span>),</span><br><span class="line">    INNER_ERROR(-<span class="number">2</span>, <span class="string">"系统异常"</span>),</span><br><span class="line">    DATA_REWRITE(-<span class="number">3</span>, <span class="string">"数据串改"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> state;</span><br><span class="line">    <span class="keyword">private</span> String stateInfo;</span><br><span class="line"></span><br><span class="line">    SeckillStatEnum(<span class="keyword">int</span> state, String stateInfo) &#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">        <span class="keyword">this</span>.stateInfo = stateInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStateInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stateInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SeckillStatEnum <span class="title">stateOf</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (SeckillStatEnum state : values())&#123;</span><br><span class="line">            <span class="keyword">if</span> (state.getState() == index)&#123;</span><br><span class="line">                <span class="keyword">return</span> state;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体枚举的语法不再讲，简单来说就是将这些通用的返回结果提取出来，且枚举这种类型更适合当前方法的返回值特点。除了创建这个枚举对象，还需要修改<code>SeckillExecution</code>的源代码，这里不再贴出。</p>
<blockquote>
<p>4.为什么要cache这么多异常？</p>
</blockquote>
<p>前面我们已经提到了Spring默认只对运行期异常进行事务回滚操作，对于编译期异常时不进行回滚的，所以这也是我们为什么一直强调要手动创建异常类。</p>
<p>这里就是要将所有编译期异常转换为运行期异常，因为我们定义的所有异常最终都是继承RuntimeException。</p>
<p>此例具体代码请看：<a href="https://github.com/TyCoding/springboot-seckill/blob/master/src/main/java/cn/tycoding/service/impl/SeckillServiceImpl.java" target="_blank" rel="noopener">GitHub</a></p>
<br>

<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot实现Java高并发秒杀系统之DAO层开发（一）</title>
    <url>/2018/10/12/ssm/seckill-dao/</url>
    <content><![CDATA[<p><strong>秒杀</strong>系统在如今电商项目中是很常见的，最近在学习电商项目时讲到了秒杀系统的实现，于是打算使用SpringBoot框架学习一下秒杀系统（本项目基于慕课网的一套免费视频教程：<a href="https://www.imooc.com/u/2145618/courses?sort=publish" target="_blank" rel="noopener">Java高并发秒杀API</a>，视频教程中讲解的很详细，非常感谢这位讲师）。也是因为最近学习了SpringBoot框架（GitHub教程：<a href="https://github.com/TyCoding/spring-boot" target="_blank" rel="noopener">SpringBoot入门之CRUD</a> ），觉得SpringBoot框架确实比传统SSM框架方便了很多，于是更深层次练习使用SpringBoot框架，注意：<strong>SpringBoot不是对Spring功能上的增强，而是提供了一种快速使用Spring的方式。</strong> 如果你熟悉了SSM框架，学习SpringBoot框架也是很Easy的。</p>
<p>本项目的源码请参看：<a href="https://github.com/TyCoding/springboot-seckill" target="_blank" rel="noopener">springboot-seckill</a>  如果觉得不错可以star一下哦(#^.^#)</p>
<a id="more"></a>

<p>本项目一共分为四个模块来讲解，具体的开发教程请看我的博客文章：</p>
<ul>
<li><p><a href="http://tycoding.cn/2018/10/12/ssm/seckill-dao/" target="_blank" rel="noopener">SpringBoot实现Java高并发秒杀系统之DAO层开发（一）</a></p>
</li>
<li><p><a href="http://tycoding.cn/2018/10/13/ssm/seckill-service/" target="_blank" rel="noopener">SpringBoot实现Java高并发秒杀系统之Service层开发（二）</a></p>
</li>
<li><p><a href="http://tycoding.cn/2018/10/14/ssm/seckill-web/" target="_blank" rel="noopener">SpringBoot实现Java高并发秒杀系统之Web层开发（三）</a></p>
</li>
<li><p><a href="http://tycoding.cn/2018/10/15/ssm/seckill/" target="_blank" rel="noopener">SpringBoot实现Java高并发秒杀系统之并发优化（四）</a></p>
</li>
</ul>
<h1 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h1><p>首先我们需要搭建SpringBoot项目开发环境，IDEA搭建SpringBoot项目的具体教程请看我的：<a href="http://tycoding.cn/2018/09/30/boot/springboot-mybatis/#more" target="_blank" rel="noopener">博文</a>。</p>
<p>如果你对SpringBoot框架或是SSM框架不熟悉，我想推荐一下我的几个小项目帮助你更好的理解：</p>
<ul>
<li><p><a href="http://tycoding.cn/2018/09/28/boot/spring-boot/" target="_blank" rel="noopener">SpringBoot起步之环境搭建</a></p>
</li>
<li><p><a href="http://tycoding.cn/2018/09/30/boot/springboot-mybatis/#more" target="_blank" rel="noopener">SpringBoot-Mybatis入门之CRUD</a></p>
</li>
<li><p><a href="https://github.com/TyCoding/ssm" target="_blank" rel="noopener">手把手教你整合SSM框架</a></p>
</li>
<li><p><a href="http://tycoding.cn/2018/06/04/ssm/ssm/" target="_blank" rel="noopener">SSM框架入门之环境搭建</a></p>
</li>
</ul>
<br>

<p><strong>项目设计</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── README  -- Doc文档</span><br><span class="line">├── db  -- 数据库约束文件</span><br><span class="line">├── mvnw</span><br><span class="line">├── mvnw.cmd</span><br><span class="line">├── pom.xml  -- 项目依赖</span><br><span class="line">└── src</span><br><span class="line">    ├── main</span><br><span class="line">    │   ├── java</span><br><span class="line">    │   │   └── cn</span><br><span class="line">    │   │       └── tycoding</span><br><span class="line">    │   │           ├── SpringbootSeckillApplication.java  -- SpringBoot启动器</span><br><span class="line">    │   │           ├── controller  -- MVC的web层</span><br><span class="line">    │   │           ├── dto  -- 统一封装的一些结果属性，和entity类似</span><br><span class="line">    │   │           ├── entity  -- 实体类</span><br><span class="line">    │   │           ├── enums  -- 手动定义的字典枚举参数</span><br><span class="line">    │   │           ├── exception  -- 统一的异常结果</span><br><span class="line">    │   │           ├── mapper  -- Mybatis-Mapper层映射接口，或称为DAO层</span><br><span class="line">    │   │           ├── redis  -- redis,jedis 相关配置</span><br><span class="line">    │   │           └── service  -- 业务层</span><br><span class="line">    │   └── resources</span><br><span class="line">    │       ├── application.yml  -- SpringBoot核心配置</span><br><span class="line">    │       ├── mapper  -- Mybatis-Mapper层XML映射文件</span><br><span class="line">    │       ├── static  -- 存放页面静态资源，可通过浏览器直接访问</span><br><span class="line">    │       │   ├── css</span><br><span class="line">    │       │   ├── js</span><br><span class="line">    │       │   └── lib</span><br><span class="line">    │       └── templates  -- 存放Thymeleaf模板引擎所需的HTML，不能在浏览器直接访问</span><br><span class="line">    │           ├── page</span><br><span class="line">    │           └── public  -- HTML页面公共组件（头部、尾部）</span><br><span class="line">    └── test  -- 测试文件</span><br></pre></td></tr></table></figure>

<h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><p>之前我们在<a href="https://github.com/TyCoding/spring-boot" target="_blank" rel="noopener">SpringBoot-Mybatis入门之CRUD</a>中已经详细讲解了SpringBoot框架的开发流程，还是觉得一句话说的特别好：<strong>SpringBoot不是对对Spring功能上的增强，而是提供了一种快速使用Spring的方式</strong>。所以用SSM阶段的知识足够了SpringBoot阶段的开发，下面我们强调一下小技巧：</p>
<ul>
<li><p>SpringBoot不需要配置注解扫描，之前我们配置<code>&lt;context:component-scan&gt;</code>扫描可能使用注解(@Service,@Component,@Controller等)的包路径。默认创建SpringBoot项目自动生成的Application.java启动器类会自动扫描其下的所有注解。</p>
</li>
<li><p>SpringBoot项目中静态资源都放在<code>resources</code>目录下，其中<code>static</code>目录中的数据可以直接通过浏览器访问，多用来放CSS、JS、img，但是不用来放html页面；其中<code>templates</code>用来存放HTML页面，但是需要在SpringBoot的配置文件(application.yml)中配置<code>spring.thymeleaf.prefix</code>标识Thymeleaf模板引擎渲染的页面位置。</p>
</li>
<li><p>HTML页面通过Thymeleaf的加持，为HTML页面赋予了很多功能，此时的HTML页面类似于JSP页面。访问后端存入域对象(session,request…)中的数据，可以通过<code>th:text=&quot;${key}&quot;</code>获得，在JS中也可以通过<code>[[${key}]]</code>获得。</p>
</li>
<li><p>Thymeleaf提供了类似JSP页面<code>&lt;include&gt;</code>的功能：public-component:<code>&lt;div th:fragment=&quot;header&quot;&gt;</code>，main-component:<code>&lt;div th:replace=&quot;path/header :: header&quot;&gt;</code>(其中<code>path</code>表示public-component相对于templates的路径，<code>/header</code>表示component文件名，最后的<code>header</code>表示<code>th:fragment</code>中定义的名称)。</p>
</li>
</ul>
<h2 id="pom依赖"><a href="#pom依赖" class="headerlink" title="pom依赖"></a>pom依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- alibaba的druid数据库连接池 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- redis客户端 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="JavaBean实体类配置"><a href="#JavaBean实体类配置" class="headerlink" title="JavaBean实体类配置"></a>JavaBean实体类配置</h2><p>此处源码请看：<a href="https://github.com/TyCoding/springboot-seckill/tree/master/src/main/java/cn/tycoding/entity" target="_blank" rel="noopener">GitHub</a></p>
<p>Seckill.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Seckill</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> seckillId; <span class="comment">//商品ID</span></span><br><span class="line">    <span class="keyword">private</span> String title; <span class="comment">//商品标题</span></span><br><span class="line">    <span class="keyword">private</span> String image; <span class="comment">//商品图片</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal price; <span class="comment">//商品原价格</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal costPrice; <span class="comment">//商品秒杀价格</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@DateTimeFormat</span>(pattern = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>)</span><br><span class="line">    <span class="meta">@JsonFormat</span>(pattern = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>, timezone = <span class="string">"GMT+8"</span>)</span><br><span class="line">    <span class="keyword">private</span> Date createTime; <span class="comment">//创建时间</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@DateTimeFormat</span>(pattern = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>)</span><br><span class="line">    <span class="meta">@JsonFormat</span>(pattern = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>, timezone = <span class="string">"GMT+8"</span>)</span><br><span class="line">    <span class="keyword">private</span> Date startTime; <span class="comment">//秒杀开始时间</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@DateTimeFormat</span>(pattern = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>)</span><br><span class="line">    <span class="meta">@JsonFormat</span>(pattern = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>, timezone = <span class="string">"GMT+8"</span>)</span><br><span class="line">    <span class="keyword">private</span> Date endTime; <span class="comment">//秒杀结束时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> stockCount; <span class="comment">//剩余库存数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SeckillOrder.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeckillOrder</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> seckillId; <span class="comment">//秒杀到的商品ID</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal money; <span class="comment">//支付金额</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> userPhone; <span class="comment">//秒杀用户的手机号</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@DateTimeFormat</span>(pattern = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>)</span><br><span class="line">    <span class="meta">@JsonFormat</span>(pattern = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>, timezone = <span class="string">"GMT+8"</span>)</span><br><span class="line">    <span class="keyword">private</span> Date createTime; <span class="comment">//创建时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> status; <span class="comment">//订单状态， -1:无效 0:成功 1:已付款</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Seckill seckill; <span class="comment">//秒杀商品，和订单是一对多的关系</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意实体类中<code>Date</code>类型数据都用了<code>@DateTimeFormat()</code>(来自springframework)和<code>@JsonFormat()</code>(来自jackson)标识可以实现Controller在返回JSON数据（用<code>@ResponseBody</code>标识的方法或<code>@RestController</code>标识的类）的时候能将Date类型的参数值（经Mybatis查询得到的数据是英文格式的日期，因为实体类中是Date类型）转换为注解中指定的格式返回给页面（相当于经过了一层SimpleDateFormate）。</p>
<p>其次要<strong>注意</strong>在编写实体类的时候尽量养成习惯<strong>继承Serializable接口</strong>。在<code>SeckillOrder</code>中我们注入了<code>Seckill</code>类作为一个属性，目的是为了可以使用多表查询的方式从<code>seckill_order</code>表中查询出来对应的<code>seckill</code>表数据。</p>
<h1 id="表设计"><a href="#表设计" class="headerlink" title="表设计"></a>表设计</h1><p>创建完成了SpringBoot项目，首先我们需要初始化数据库，秒杀系统的建表SQL如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  mysql-v: 5.7.22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建数据库</span></span><br><span class="line"><span class="comment">-- CREATE DATABASE seckill DEFAULT CHARACTER SET utf8;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`seckill`</span>;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`seckill_order`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建秒杀商品表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`seckill`</span>(</span><br><span class="line">  <span class="string">`seckill_id`</span> <span class="built_in">bigint</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'商品ID'</span>,</span><br><span class="line">  <span class="string">`title`</span> <span class="built_in">varchar</span> (<span class="number">1000</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'商品标题'</span>,</span><br><span class="line">  <span class="string">`image`</span> <span class="built_in">varchar</span> (<span class="number">1000</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'商品图片'</span>,</span><br><span class="line">  <span class="string">`price`</span> <span class="built_in">decimal</span> (<span class="number">10</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'商品原价格'</span>,</span><br><span class="line">  <span class="string">`cost_price`</span> <span class="built_in">decimal</span> (<span class="number">10</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'商品秒杀价格'</span>,</span><br><span class="line">  <span class="string">`stock_count`</span> <span class="built_in">bigint</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'剩余库存数量'</span>,</span><br><span class="line">  <span class="string">`start_time`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'1970-02-01 00:00:01'</span> <span class="keyword">COMMENT</span> <span class="string">'秒杀开始时间'</span>,</span><br><span class="line">  <span class="string">`end_time`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'1970-02-01 00:00:01'</span> <span class="keyword">COMMENT</span> <span class="string">'秒杀结束时间'</span>,</span><br><span class="line">  <span class="string">`create_time`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`seckill_id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_start_time`</span> (<span class="string">`start_time`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_end_time`</span> (<span class="string">`end_time`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_create_time`</span> (<span class="string">`end_time`</span>)</span><br><span class="line">) <span class="keyword">CHARSET</span>=utf8 <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">COMMENT</span> <span class="string">'秒杀商品表'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建秒杀订单表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`seckill_order`</span>(</span><br><span class="line">  <span class="string">`seckill_id`</span> <span class="built_in">bigint</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'秒杀商品ID'</span>,</span><br><span class="line">  <span class="string">`money`</span> <span class="built_in">decimal</span> (<span class="number">10</span>, <span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'支付金额'</span>,</span><br><span class="line">  <span class="string">`user_phone`</span> <span class="built_in">bigint</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户手机号'</span>,</span><br><span class="line">  <span class="string">`create_time`</span> <span class="built_in">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>,</span><br><span class="line">  <span class="string">`state`</span> <span class="built_in">tinyint</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">-1</span> <span class="keyword">COMMENT</span> <span class="string">'状态：-1无效 0成功 1已付款'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`seckill_id`</span>, <span class="string">`user_phone`</span>) <span class="comment">/*联合主键，保证一个用户只能秒杀一件商品*/</span></span><br><span class="line">) <span class="keyword">CHARSET</span>=utf8 <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">COMMENT</span> <span class="string">'秒杀订单表'</span>;</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong></p>
<p>秒杀系统的表设计还是相对简单清晰的，这里我们只考虑秒杀系统的业务表，不涉及其他的表，所以整个系统主要涉及两张表：秒杀商品表、订单表。当然实际情况肯定不止这两张表（比如付款相关表，但是我们并未实现这个功能），也不止表中的这些字段。这里我们需要特别注意以下几点：</p>
<p><strong>注意</strong></p>
<ul>
<li><p>1.我这里使用的Mysql版本是5.7.22，在Mysql5.7之后timestamp默认值不能再是<code>0000 00-00 00:00:00</code>，具体的介绍请看：<a href="https://dev.mysql.com/doc/refman/5.7/en/datetime.html" target="_blank" rel="noopener">mysql官方文档</a>。即 TIMESTAMP has a range of ‘1970-01-01 00:00:01’ UTC to ‘2038-01-19 03:14:07’ UTC.</p>
</li>
<li><p>2.timestamp类型用来实现自动为新增行字段设置当前系统时间；且使用timestamp的字段必须给timestamp设置默认值，而在Mysql中date, datetime等类型都是无法实现默认设置当前系统时间值的功能(<code>DEFAULT CURRENT_TIMESTAMP</code>)的，所以我们必须使用timestamp类型，否则你要给字段传进来系统时间。</p>
</li>
<li><p>3.decimal类型用于在数据库中设置精确的数值，比如<code>decimal(10,2)</code>表示可以存储10位且有2位小数的数值。</p>
</li>
<li><p>4.tinyint类型用于存放int类型的数值，但是若用Mybatis作为DAO层框架，Mybatis会自动为tinyint类型的数据转换成true或false（0:false; 1 or 1+:true）。</p>
</li>
<li><p>5.在订单表<code>seckill_order</code>中我们设计了联合主键：<code>PRIMARY KEY (seckill_id, user_phone)</code>，目的是为了避免单个用户重复购买同一件商品（一个用户只能秒杀到一次同一件商品）。</p>
</li>
<li><p>6.无论是创建数据库还是创建表我们都应该养成一个习惯就是指定<code>character=utf-8</code>，避免中文数据乱码；其次还应该指定表的储存引擎是InnoDB，MySQL提供了两种储存引擎：InnoDB, MyISAM。但是只有InnoDB是支持事务的，且InnoDB相比MyISAM在并发上更具有高性能的优点。</p>
</li>
</ul>
<h1 id="DAO层开发"><a href="#DAO层开发" class="headerlink" title="DAO层开发"></a>DAO层开发</h1><p>DAO层是我们常说的三层架构（Web层-业务层-持久层）中与数据库交互的持久层，但是实际而言，架构是这样设计的，但是并不代表着实际项目中就一定存在一个<code>dao</code>文件夹，特别是现阶段我们使用的Spring-Mybatis框架。Mybatis提供了一种接口代理开发模式，也就是我们需要提供一个interface接口，其他和数据库交互的SQL编写放到对应的XML文件中（但是需要进行相关的数据库参数配置，并且Mybatis规定了使用这种开发模式必须保持接口和XML文件名称对应）。于是在本项目中就没有出现<code>dao</code>整个文件夹，取而代之的是<code>mapper</code>这个文件夹，我感觉更易识别出为Mybatis的映射接口文件。其实在实际项目中考虑到项目的大小和复杂程度，<code>dao</code>和<code>mapper</code>可能是同时存在的，因为service可能并不满足项目的设计，即为dao接口创建实现类，在实现类中再调用mapper接口来实现功能模块的扩展。</p>
<br>

<p>DAO层开发，即DAO层接口开发，主要设计需要和数据库交互的数据有哪些？应该用什么返回值类型接收查询到的数据？所以包含的方法有哪些？带着这些问题，我们先看一下秒杀系统的业务流程：</p>
<p><img src="/2018/10/12/ssm/seckill-dao/1.png" alt></p>
<p>由上图可以看出，相对与本项目而言和数据库打交道的主要涉及两个操作：1.减库存（秒杀商品表）；2.记录购买明细（订单表）。</p>
<ul>
<li><p>减库存，顾名思义就是减少当前被秒杀到的商品的库存数量，这也是秒杀系统中一个处理难点的地方。实现减库存即count-1，但是我们需要考虑Mysql的事务特性引发的种种问题、需要考虑如何避免同一用户重复秒杀的行为。</p>
</li>
<li><p>如果减库存的业务解决了那么记录购买明细的业务就相对简单很多了，我们需要记录购买用户的姓名、手机号、购买的商品ID等。因为本项目中不涉及支付功能，所以记录用户的购买订单的业务并不复杂。</p>
</li>
</ul>
<p>分析了上面的功能，下面我们开始DAO层接口的编写(源码请看：<a href="https://github.com/TyCoding/springboot-seckill/tree/master/src/main/java/cn/tycoding/mapper" target="_blank" rel="noopener">GitHub</a>)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 减库存。</span></span><br><span class="line"><span class="comment"> * 对于Mapper映射接口方法中存在多个参数的要加<span class="doctag">@Param</span>()注解标识字段名称，不然Mybatis不能识别出来哪个字段相互对应</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> seckillId 秒杀商品ID</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> killTime  秒杀时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回此SQL更新的记录数，如果&gt;=1表示更新成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reduceStock</span><span class="params">(@Param(<span class="string">"seckillId"</span>)</span> <span class="keyword">long</span> seckillId, @<span class="title">Param</span><span class="params">(<span class="string">"killTime"</span>)</span> Date killTime)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入购买订单明细</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> seckillId 秒杀到的商品ID</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> money     秒杀的金额</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userPhone 秒杀的用户</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回该SQL更新的记录数，如果&gt;=1则更新成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insertOrder</span><span class="params">(@Param(<span class="string">"seckillId"</span>)</span> <span class="keyword">long</span> seckillId, @<span class="title">Param</span><span class="params">(<span class="string">"money"</span>)</span> BigDecimal money, @<span class="title">Param</span><span class="params">(<span class="string">"userPhone"</span>)</span> <span class="keyword">long</span> userPhone)</span>;</span><br></pre></td></tr></table></figure>

<p>但从接口设计上我们无非关注的就是这两个方法：1.减库存；2.插入购买明细。此处需要注意的是：</p>
<ul>
<li><p>对于SpringBoot系统，DAO（Mapper）层的接口需要使用<code>@Mapper</code>注解标识。因为SpringBoot系统中接口的XML文件不在<code>/java</code>目录下而是在<code>/resources</code>目录下。</p>
</li>
<li><p>对于Mapper接口方法中存在传递多个参数的情况需要使用<code>@Param()</code>标识这个参数的名称，目的是为了帮助Mybatis识别传递的参数，不然Mybatis的XML中用的<code>#{}</code>不能识别出来你传递的参数名称是谁和谁对应的，类似于Controller层中常用的<code>@RequestParam()</code>注解。</p>
</li>
<li><p><strong>小技巧:</strong> 之前我们做insert和update操作时直接用<code>void</code>作为方法返回值，实际上虽然Mybatis的<code>&lt;update&gt;</code>和<code>&lt;select&gt;</code>语句并没有<code>resultType</code>属性，但是并不代表其没有返回值，默认返回0或1，表示执行该SQL影响的行数。为此我们可以这样写SQL，如：<code>insert ignore into xxx</code>用来避免Mybatis报错，而是直接返回0表示当前SQL执行失败。</p>
</li>
<li><p>小技巧：因为我们必须要避免同一个用户多次抢购同一件商品，在SQL中必须限制这一点（因为即使前端怎么控制都无法避免用户多次请求同一个接口，所谓接口防刷）。所以在设计订单表的时候用了联合主键且不自增的方式，以用户ID和用户电话组成联合主键，这样当同一个用户（电话相同）多次抢购同一件商品时插入的SQL就会产生主键冲突的问题，这样就会报错。</p>
</li>
</ul>
<h2 id="XML映射"><a href="#XML映射" class="headerlink" title="XML映射"></a>XML映射</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"reduceStock"</span>&gt;</span></span><br><span class="line">    UPDATE seckill</span><br><span class="line">    SET stock_count = stock_count - 1</span><br><span class="line">    WHERE seckill_id = #&#123;seckillId&#125;</span><br><span class="line">    AND start_time &amp;lt;= #&#123;killTime&#125;</span><br><span class="line">    AND end_time &amp;gt;= #&#123;killTime&#125;</span><br><span class="line">    AND stock_count &amp;gt; 0</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertOrder"</span>&gt;</span></span><br><span class="line">    INSERT ignore INTO seckill_order(seckill_id, money, user_phone)</span><br><span class="line">    VALUES (#&#123;seckillId&#125;, #&#123;money&#125;, #&#123;userPhone&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>SQL语句相对不是很复杂。减库存：执行update语句，令<code>stock_count</code>字段依次减一，并且当前要在一系列where条件的限制下；新增订单信息：保存订单数据，这里为接口防刷用联合主键<code>seckillId, userPhone</code>，如果同一个用户多次抢购同一件商品导致主键冲突会直接报错，为了避免系统不直接报错设计了<code>ignore</code>实现主键冲突就直接返回0表示该条SQL执行失败。</p>
<p><strong>拓展</strong></p>
<p>上面我使用了<code>&amp;lt;</code>、<code>&amp;gt;</code>的语法其实代表的是&gt;= &lt;=这种符号，因为在Mybatis中编写的SQL语句如果直接使用<code>&gt;=</code>或<code>&lt;=</code>这种判断条件可能会报错，我这里提供一种简单的解决方案就是用这种英文符号代替：</p>
<table>
<thead>
<tr>
<th>原符号</th>
<th>替换符号</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;</td>
<td>&lt;</td>
</tr>
<tr>
<td>&lt;=</td>
<td>&lt;=</td>
</tr>
<tr>
<td>&gt;</td>
<td>&gt;</td>
</tr>
<tr>
<td>&gt;=</td>
<td>&gt;=</td>
</tr>
<tr>
<td>&amp;</td>
<td>&amp;</td>
</tr>
<tr>
<td>‘</td>
<td>&apos;</td>
</tr>
<tr>
<td>“</td>
<td>&quot;</td>
</tr>
</tbody></table>
<h3 id="order表中findById方法"><a href="#order表中findById方法" class="headerlink" title="order表中findById方法"></a>order表中findById方法</h3><p>之前在<code>SeckillOrder.java</code>实体类中我们注入了<code>Seckill</code>属性，用于可以根据查询<code>seckill_order</code>表的同时查询到其对应的<code>seckill</code>表数据，对应的接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据秒杀商品ID查询订单明细数据并得到对应秒杀商品的数据，因为我们再SeckillOrder中已经定义了一个Seckill的属性</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> seckillId</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">SeckillOrder <span class="title">findById</span><span class="params">(<span class="keyword">long</span> seckillId)</span></span>;</span><br></pre></td></tr></table></figure>

<p>对应的SQL如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findById"</span> <span class="attr">resultType</span>=<span class="string">"SeckillOrder"</span>&gt;</span></span><br><span class="line">    SELECT</span><br><span class="line">      so.seckill_id,</span><br><span class="line">      so.user_phone,</span><br><span class="line">      so.money,</span><br><span class="line">      so.create_time,</span><br><span class="line">      so.state,</span><br><span class="line">      s.seckill_id "seckill.seckill_id",</span><br><span class="line">      s.title "seckill.title",</span><br><span class="line">      s.cost_price "seckill.cost_price",</span><br><span class="line">      s.create_time "seckill.create_time",</span><br><span class="line">      s.start_time "seckill.start_time",</span><br><span class="line">      s.end_time "seckill.end_time",</span><br><span class="line">      s.stock_count "seckill.stock_count"</span><br><span class="line">    FROM seckill_order so</span><br><span class="line">    INNER JOIN seckill s ON so.seckill_id = s.seckill_id</span><br><span class="line">    WHERE so.seckill_id = #&#123;seckillId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个SQL看似复杂些，但是就是仅仅的多表（两张表）查询语句：根据<code>seckill_order</code>表中的<code>seckill_id</code>字段查询<code>seckill</code>表中<code>seckill_id</code>字段值对应的数据（也就是说：对于多表查询，其实两张表之间必然存在一定的字段关联关系，不一定是外键关联，当然我们也不建议用外键关联两张表）。</p>
<p>其中<code>findById</code>的SQL中类似<code>s.seckill_id &quot;seckill.seckill_id&quot;</code>语句其实是<code>s.seckill_id as &quot;seckill.seckill_id&quot;</code>，这里省略了as（别名）；而<code>INNER JOIN</code>语句正是查询若两张表中中又相同字段的匹配值就根据两张表关联字段查询两张表的数据。这也可以使用<code>&lt;resultMap&gt;</code>中的<code>&lt;association&gt;</code>标签来实现，用于查询两张关联表的数据，如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"findById"</span> <span class="attr">type</span>=<span class="string">"SeckillOrder"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"seckill_id"</span> <span class="attr">property</span>=<span class="string">"seckillId"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"user_phone"</span> <span class="attr">property</span>=<span class="string">"userPhone"</span>/&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"seckill"</span> <span class="attr">javaType</span>=<span class="string">"Seckill"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"seckill_id"</span> <span class="attr">property</span>=<span class="string">"seckillId"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"title"</span> <span class="attr">property</span>=<span class="string">"title"</span>/&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如以上也是一种映射另外一张表数据的方式（当然使用这种方式在写SQL的时候需要指定限制条件<code>where s.seckill_id = so.seckill_id</code>强调两张表中的<code>seckill_id</code>字段值相同）。</p>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>在编写了Mybatis的映射接口和XML映射文件，我们可以编写一个测试类来测试一下接口和XML配置是否正确。由于我们使用IDEA开发工具，打开接口文件用快捷键<code>Alt + Enter</code>（我这里用的Mac系统）显示一个面板，选择<code>Create Test</code>快速创建本文件的测试类。</p>
<p>由于使用的SpringBoot框架，新创建的测试类位于<code>/src/test/java/</code>目录下，我们举例说明，比如创建<code>SeckillMapper</code>接口的测试文件：SeckillMapperTest.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeckillMapperTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SeckillMapper seckillMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findById</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduceStock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是使用IDEA快捷键创建的测试类，我们仅以<code>findAll()</code>方法举例说明一下如何使用SpringBoot的测试类。如下：</p>
<p>此处的源码请参看：<a href="https://github.com/TyCoding/springboot-seckill/tree/master/src/test/java/cn/tycoding/mapper" target="_blank" rel="noopener">Github</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="comment">//@ContextConfiguration("classpath:application.yml")</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeckillMapperTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SeckillMapper seckillMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Seckill&gt; all = seckillMapper.findAll();</span><br><span class="line">        <span class="keyword">for</span> (Seckill seckill : all) &#123;</span><br><span class="line">            System.out.println(seckill.getTitle());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findById</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduceStock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SpringBoot的测试类和传统Spring框架测试类的最大区别就是不再使用<code>@ContextConfiguration()</code>注解去加载配置文件，取而代之的是使用<code>@SpringBootTest</code>注解。因为SpringBoot已经严格规定了配置文件放在<code>resources</code>目录下，且一般是<code>.properties</code>或<code>.yml</code>结尾。如果你再使用<code>@ContextConfiguration()</code>注解加载配置文件反而会报错。</p>
<br>

<p><img src="/2018/10/12/ssm/seckill-dao/show-1.png" alt></p>
<p><img src="/2018/10/12/ssm/seckill-dao/show-2.png" alt></p>
<p><img src="/2018/10/12/ssm/seckill-dao/show-3.png" alt></p>
<br>

<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>消息中间件ActiveMQ入门学习</title>
    <url>/2018/09/30/ssm/activemq/</url>
    <content><![CDATA[<h2 id="消息中间件ActiveMQ入门学习"><a href="#消息中间件ActiveMQ入门学习" class="headerlink" title="消息中间件ActiveMQ入门学习"></a>消息中间件ActiveMQ入门学习</h2><p><strong>什么是消息中间件？</strong></p>
<p>消息中间件利用高效可靠的消息传递机制进行与平台无关的数据交流，并基于数据通信来进行分布式系统的集成。对于消息中间件，常见的角色有：Producer(生产者)、Consumer(消费者)。</p>
<p>常见的消息中间件产品有：</p>
<ul>
<li>ActiveMQ: Apache的一款完全支持JMS1.1和J2EE1.4规范的JMS Provider实现。</li>
<li>RabbitMQ: AMQP协议的领导实现，支持多种场景。</li>
<li>ZeroMQ: 号称史上最快的消息队列系统。</li>
<li>Kafka: Apache下的一个子项目，具有高吞吐的特点。</li>
</ul>
<a id="more"></a>

<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>本例中将ArtiveMQ部署在虚拟机Centos服务器上，如果你对虚拟机搭建Centos服务器不熟悉请参看我的博客：<a href="http://www.tycoding.cn/ssm/2018/08/29/ssm/fastdfs/">FastDFS文件系统的搭建</a></p>
<p>首先去下载ActiveMQ: <a href="http://activemq.apache.org/" target="_blank" rel="noopener">官网地址</a></p>
<blockquote>
<p>1.打开虚拟机上的Centos服务器；2.打开SecureCRT连接上服务器。</p>
</blockquote>
<p><img src="/2018/09/30/ssm/activemq/1.png" alt></p>
<blockquote>
<p>2.输入命令：<code>rz</code>将本地下载的apache-activemq-bin.tar.gz文件上传到linux服务器上</p>
</blockquote>
<p>输入以下命令解压文件并赋予权限</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">--解压</span><br><span class="line">tar zxvf apache-activemq-5.15.6-bin.tar.gz</span><br><span class="line">--赋予可读可写可执行的权限</span><br><span class="line">chmod 777 apache-activemq-5.15.6</span><br><span class="line"></span><br><span class="line">cd apache-activemq-5.15.6/bin</span><br><span class="line">--赋予权限</span><br><span class="line">chmod 755 activemq</span><br><span class="line"></span><br><span class="line">--启动activemq</span><br><span class="line">./activemq start</span><br></pre></td></tr></table></figure>

<p><strong>拓展</strong></p>
<p>chmod是Linux下设置文件权限的命令，后面的数字代表了不同用户组的权限，一般时三个数字：</p>
<ul>
<li>第一个数字表示文件所有者的权限</li>
<li>第二个数字表示与文件所有者同属于一个用户组的其他用户的权限</li>
<li>第三个数字表示其他用户组的权限</li>
</ul>
<p>权限分为三种：读(r=4)、写(r=2)、执行(r=1)。综合起来：可读可执行(rx=5=4+1)、可读可写(rw=6=4+2)、可读可写可执行(rwx=7=4+2+1)。</p>
<p><img src="/2018/09/30/ssm/activemq/2.png" alt></p>
<p>在浏览器上访问<code>ip:8161</code>地址：</p>
<p><img src="/2018/09/30/ssm/activemq/3.png" alt></p>
<p>8161端口是ActiveMQ默认的端口，点击<code>Manage ActiveMQ broker</code>，需要输入用户名密码：默认都是admin。</p>
<p><img src="/2018/09/30/ssm/activemq/4.png" alt></p>
<h1 id="JMS入门"><a href="#JMS入门" class="headerlink" title="JMS入门"></a>JMS入门</h1><p>在之前学习Solr时我们学习了Spring-Data-Solr、学习Redis的时候我们学习了Spring-Data-Redis。上面我们在服务器上部署了ActiveMQ，对应实际应用中肯定需要一个入口方式操作ActiveMQ，所以我们要学习：JMS（Java Messaging Service）。</p>
<p>JMS是Java平台上有关面向中间件的技术规范，它便于消息系统中的Java应用程序进行消息交换，并且通过提供标准的产生、发送、接收消息的接口简化企业应用的开发。</p>
<p>JMS本身定义了一系列的接口规范，可以用其访问ActiveMQ发送消息服务。JMS定义了五种不同的消息正文格式，以及调用的消息类型，允许你发送并接受一些不同形式的数据，提供现有消息格式的一些级别的兼容性：</p>
<ul>
<li>TextMessage – 一个字符串对象</li>
<li>MapMessage – 一套名称-值对</li>
<li>ObjectMessage – 一个序列化的Java对象</li>
<li>BytesMessage – 一个字节的数据流</li>
<li>StreamMessage – Java原始值的数据流</li>
</ul>
<h2 id="JMS消息传递类型"><a href="#JMS消息传递类型" class="headerlink" title="JMS消息传递类型"></a>JMS消息传递类型</h2><p>JMS有两种消息传递类型，适用于不同的情况，分别是：</p>
<ul>
<li><code>Producer--&gt;Consumer</code>点对点模式：一个生产者对应一个消费者。</li>
<li><code>Producer--&gt;Consumer/Consumer</code>发布订阅模式：一个生产者可对应多个消费者。</li>
</ul>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>先在工程中导入activemq依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.activemq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activemq-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.13.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="点对点模式"><a href="#点对点模式" class="headerlink" title="点对点模式"></a>点对点模式</h3><p>点对点模式主要建立在一个队列上面，当连接一个队列的时候，发送端不需要知道接收端是否正在接收，可以直接向ActiveMQ发送消息，发送的消息将会先进入队列中，如果有接收端监听，则会发向接受端；如果没有接收端接收，则会保存在activeMQ服务器，直到接收端接收消息。点对点消息模式可以有多个发送端，多个接收端，但是一条消息，只会被一个接收端给接收到，那个接收端先连接上ActiveMQ，则会先接收到，而后来的接收端接收不到那条消息。</p>
<p>先在工程中导入activemq依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.activemq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activemq-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.13.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>1.创建QueueProducer.java 生产者类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> JMSException </span>&#123;</span><br><span class="line">        <span class="comment">//1、创建连接工厂</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(<span class="string">"tcp://192.168.148.128:61616"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、获取连接</span></span><br><span class="line">        Connection connection = connectionFactory.createConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、启动连接</span></span><br><span class="line">        connection.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4、获取session（参数1：是否启动事务；参数2：消息确认模式）</span></span><br><span class="line">        <span class="comment">//      AUTO_ACKNOWLEDGE = 1  自动确认</span></span><br><span class="line">        <span class="comment">//      CLIENT_ACKNOWLEDGE = 2  客户端手动确认</span></span><br><span class="line">        <span class="comment">//      DUPS_OK_ACKNOWLEDGE = 3  自动批量确认</span></span><br><span class="line">        <span class="comment">//      SESSION_TRANSACTED = 0  事务提交并确认</span></span><br><span class="line">        Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5、创建消息队列对象</span></span><br><span class="line">        Queue queue = session.createQueue(<span class="string">"test-queue"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6、创建消息生产者</span></span><br><span class="line">        MessageProducer producer = session.createProducer(queue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7、创建消息</span></span><br><span class="line">        TextMessage textMessage = session.createTextMessage(<span class="string">"ActiveMQ入门"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//8、发送消息</span></span><br><span class="line">        producer.send(textMessage);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//9、关闭资源</span></span><br><span class="line">        producer.close();</span><br><span class="line">        session.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，步骤一中的连接地址根据自己的ActiveMQ服务器地址决定，但是<strong>61616是ActiveMQ默认端口</strong>，无需改变。这里我们创建了一个消息队列对象<code>text-queue</code>，并用<code>TextMessage</code>格式发送了一条消息：<code>ActiveMQ入门</code>。
如果我们理解运行着这个生产者类，在ActiveMQ控制台中会看到：</p>
<p><img src="/2018/09/30/ssm/activemq/5.png" alt></p>
<p>那么消费端是如何接受到这个消息的呢？</p>
<blockquote>
<p>2.创建QueueConsumer.java 消费者类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueConsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> JMSException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1、创建连接工厂</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(<span class="string">"tcp://192.168.148.128:61616"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、获取连接</span></span><br><span class="line">        Connection connection = connectionFactory.createConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、启动连接</span></span><br><span class="line">        connection.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4、获取session（参数1：是否启动事务；参数2：消息确认模式）</span></span><br><span class="line">        Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5、创建队列对象</span></span><br><span class="line">        Queue queue = session.createQueue(<span class="string">"test-queue"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6、创建消息消费</span></span><br><span class="line">        MessageConsumer consumer = session.createConsumer(queue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7、监听消息</span></span><br><span class="line">        consumer.setMessageListener(<span class="keyword">new</span> MessageListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">                TextMessage textMessage = (TextMessage) message;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"接收到消息："</span> + textMessage.getText());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//8、等待键盘输入</span></span><br><span class="line">        System.in.read();</span><br><span class="line">        <span class="comment">//9、关闭资源</span></span><br><span class="line">        consumer.close();</span><br><span class="line">        session.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上一共9个步骤，步骤一中创建连接地址要结合自己的ActiveMQ服务器地址。前6个步骤都是和生产者创建步骤相同的，只有第7个步骤是独特的，因为消费端要实现监听生产端的消息，如果生产端有消息就会打印出来。</p>
<p>运行<code>QueueConsumer</code>即可得到刚才发送的消息：Active入门。</p>
<p>如果我们再次运行<code>QueueConsumer</code>消费端，则不会再得到消息，因为点对点模式只能有一个消费端接收消息，第二个消费端是接收不到消息的。</p>
<h3 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布/订阅模式"></a>发布/订阅模式</h3><blockquote>
<p>1.创建生产者TopicProducer.java </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> JMSException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、创建连接工厂</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(<span class="string">"tcp://192.168.148.128:61616"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、获取连接</span></span><br><span class="line">        Connection connection = connectionFactory.createConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、启动连接</span></span><br><span class="line">        connection.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4、获取session（参数1：是否启动事务；参数2：消息确认模式）</span></span><br><span class="line">        Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5、创建主题对象</span></span><br><span class="line">        Topic topic = session.createTopic(<span class="string">"test-topic"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6、创建消息生产者</span></span><br><span class="line">        MessageProducer producer = session.createProducer(topic);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7、创建消息</span></span><br><span class="line">        TextMessage textMessage = session.createTextMessage(<span class="string">"ActiveMQ---&gt;发布订阅模式消息..."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//8、发送消息</span></span><br><span class="line">        producer.send(textMessage);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//9、关闭资源</span></span><br><span class="line">        producer.close();</span><br><span class="line">        session.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与点对点模式不同之处在与，发布/订阅模式创建的是Topic主题对象，而点对点模式创建的是Queue队列对象</p>
<blockquote>
<p>2.创建TopicConsumer.java 消费端</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> JMSException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、创建连接工厂</span></span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(<span class="string">"tcp://192.168.148.128:61616"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、获取连接</span></span><br><span class="line">        Connection connection = connectionFactory.createConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、启动连接</span></span><br><span class="line">        connection.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4、获取session（参数1：是否启动事务；参数2：消息确认模式）</span></span><br><span class="line">        Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5、创建主题对象</span></span><br><span class="line">        Topic topic = session.createTopic(<span class="string">"test-topic"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6、创建消息消费者</span></span><br><span class="line">        MessageConsumer consumer = session.createConsumer(topic);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7、监听消息</span></span><br><span class="line">        consumer.setMessageListener(<span class="keyword">new</span> MessageListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">                TextMessage textMessage = (TextMessage) message;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"接收到的消息："</span> + textMessage.getText());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//8、等待键盘输入</span></span><br><span class="line">        System.in.read();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//9、关闭资源</span></span><br><span class="line">        consumer.close();</span><br><span class="line">        session.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行生产端和消费端，发现消费端并不显示消息；然后先运行消费端再运行生产端就打印出了消息：ActiveMQ—&gt;发布订阅模式消息…</p>
<p>原因就是发布/订阅模式和点对点模式是不同的，发布订阅模式可以允许多个接收端接收同一个生产端发布的消息；你可以理解为只有订阅了消息，才能发布消息。</p>
<h1 id="Spring整合JMS"><a href="#Spring整合JMS" class="headerlink" title="Spring整合JMS"></a>Spring整合JMS</h1><p>首先要在工程中导入spring-jms依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.activemq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activemq-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.13.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jms<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="点对点模式-1"><a href="#点对点模式-1" class="headerlink" title="点对点模式"></a>点对点模式</h2><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>这里生产端和服务端是两个不同的项目。</p>
<blockquote>
<p>1.生产端jms-producer.xml</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"cn.demo"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的JMS服务厂商提供 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"targetConnectionFactory"</span> <span class="attr">class</span>=<span class="string">"org.apache.activemq.ActiveMQConnectionFactory"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"brokerURL"</span> <span class="attr">value</span>=<span class="string">"tcp://192.168.148.128:61616"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"connectionFactory"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jms.connection.SingleConnectionFactory"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 目标ConnectionFactory对应真实可以产生JMS Connection的ConnectionFactory --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"targetConnectionFactory"</span> <span class="attr">ref</span>=<span class="string">"targetConnectionFactory"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Spring提供的JMS工具类，它可以进行消息发送、接收等 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jmsTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jms.core.JmsTemplate"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 这个connectionFactory对应的是我们定义的Spring提供的那个ConnectionFactory对象 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionFactory"</span> <span class="attr">ref</span>=<span class="string">"connectionFactory"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 这个是队列的目的地，点对点 文本信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"queueTextDestination"</span> <span class="attr">class</span>=<span class="string">"org.apache.activemq.command.ActiveMQQueue"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"queue_text"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>以上了配置和之前的直接在Java代码上的配置类似，多了一个<code>jmsTemplate</code>模板工具类的配置，如同Spring-Data-Solr中有一个solrTemplate工具类、Spring-Data-Redis有一个redisTemplate工具类。<code>jmsTemplate</code>模板工具类提供了很多API供开发者操作JMS。</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>创建<code>QueueProducer.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JmsTemplate jmsTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Destination queueTextDestination;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送文本消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> text</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendTextMessage</span><span class="params">(<span class="keyword">final</span> String text)</span></span>&#123;</span><br><span class="line">        jmsTemplate.send(queueTextDestination, <span class="keyword">new</span> MessageCreator() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Message <span class="title">createMessage</span><span class="params">(Session session)</span> <span class="keyword">throws</span> JMSException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> session.createTextMessage(text);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了要注入<code>JmsTemplate</code>模板类对象，还要注入<code>Destination</code>对象，之前我们是通过<code>new Queue()</code>来创建队列对象的，而spring整合jms后是在配置文件中配置的队列对象，</p>
<blockquote>
<p>2.消费端</p>
</blockquote>
<p>创建<code>jms-consumer-queue.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的JMS服务厂商提供 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"targetConnectionFactory"</span> <span class="attr">class</span>=<span class="string">"org.apache.activemq.ActiveMQConnectionFactory"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"brokerURL"</span> <span class="attr">value</span>=<span class="string">"tcp://192.168.148.128:61616"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Spring用于真正的ConnectionFactory的ConnectionFactory --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"connectionFactory"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jms.connection.SingleConnectionFactory"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"targetConnectionFactory"</span> <span class="attr">ref</span>=<span class="string">"targetConnectionFactory"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 这个是队列的目的地，点对点  文本信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"queueTextDestination"</span> <span class="attr">class</span>=<span class="string">"org.apache.activemq.command.ActiveMQQueue"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"queue_text"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 我的监听类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myMessageListener"</span> <span class="attr">class</span>=<span class="string">"cn.demo.MyMessageListener"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 消息监听容器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.jms.listener.DefaultMessageListenerContainer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionFactory"</span> <span class="attr">ref</span>=<span class="string">"connectionFactory"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"destination"</span> <span class="attr">ref</span>=<span class="string">"queueTextDestination"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"messageListener"</span> <span class="attr">ref</span>=<span class="string">"myMessageListener"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里注入了自定义的消费端监听类MyMessageListener.java:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMessageListener</span> <span class="keyword">implements</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        TextMessage textMessage = (TextMessage) message;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"接收到的消息："</span> + textMessage.getText());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>3.在消费端工程中创建测试方法，启动监听</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(locations = <span class="string">"classpath:applicationContext-jms-consumer-queue.xml"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestQueueC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.in.read();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>4.在生产端工程中创建测试方法，发送消息：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(locations = <span class="string">"classpath:spring/applicationContext-jms-producer.xml"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestQueueP</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> QueueProducer queueProducer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queueProducer.sendTextMessage(<span class="string">"SpringJms-点对点"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动生产端，发送消息，在消费端立即点听到消息并打印出来。和之前JMS的案例是相同的。</p>
<h2 id="发布-订阅模式-1"><a href="#发布-订阅模式-1" class="headerlink" title="发布/订阅模式"></a>发布/订阅模式</h2><blockquote>
<p>1.在上面的<code>jms-producer.xml</code>中添加配置：</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这个是订阅模式  文本信息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"topicTextDestination"</span> <span class="attr">class</span>=<span class="string">"org.apache.activemq.command.ActiveMQTopic"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"topic_text"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>2.创建TopicProducer.java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JmsTemplate jmsTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Destination topicTextDestination;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendTextMessage</span><span class="params">(<span class="keyword">final</span> String text)</span></span>&#123;</span><br><span class="line">        jmsTemplate.send(topicTextDestination, <span class="keyword">new</span> MessageCreator() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Message <span class="title">createMessage</span><span class="params">(Session session)</span> <span class="keyword">throws</span> JMSException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> session.createTextMessage();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>3.在上面消费端工程中创建<code>jms-topic.xml</code></p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 真正可以产生Connection的ConnectionFactory, 由对应的JMS服务厂商提供 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"targetConnectionFactory"</span> <span class="attr">class</span>=<span class="string">"org.apache.activemq.ActiveMQConnectionFactory"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"brokerURL"</span> <span class="attr">value</span>=<span class="string">"tcp://192.168.148.128:61616"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Spring用户管理真正的ConnectionFactory的ConnectionFactory --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"connectionFactory"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jms.connection.SingleConnectionFactory"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"targetConnectionFactory"</span> <span class="attr">ref</span>=<span class="string">"targetConnectionFactory"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 这个是队列的目的地，点对点的文本信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"topicTextDestination"</span> <span class="attr">class</span>=<span class="string">"org.apache.activemq.command.ActiveMQTopic"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"topic_text"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 我的监听类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myMessageListener"</span> <span class="attr">class</span>=<span class="string">"cn.demo.MyMessageListener"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 消息监听容器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.jms.listener.DefaultMessageListenerContainer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionFactory"</span> <span class="attr">ref</span>=<span class="string">"connectionFactory"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"destination"</span> <span class="attr">ref</span>=<span class="string">"topicTextDestination"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"messageListener"</span> <span class="attr">ref</span>=<span class="string">"myMessageListener"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>监听类还是之前的MyMessageListener.java。</p>
<blockquote>
<p>4.在生产端创建测试类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(locations = <span class="string">"classpath:spring/applicationContext-jms-producer.xml"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTopicP</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TopicProducer topicProducer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendTextQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        topicProducer.sendTextMessage(<span class="string">"Spring JMS 发布订阅信息"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动消费端监听，并运行生产端发布消息，在消费端立即监听到消息并打印出来数据。</p>
<br>


<p>到此为止我们完成了基本的ActiveMQ入门学习。</p>
<p>思考：在上面我们使用ActiveMQ案例中明显就感觉到消息中间件的一大优势就是采用了一种与平台无关的数据交流方式，在分布式项目中用处很广，比如基本的增、删、改、查数据都可以通过ActiveMQ进行信息传递，ActiveMQ支持多种数据类型的传递。</p>
<p>这样我们就解决了分布式模板间的耦合关系，模块间的消息传递不再通过调用（高耦合）方式传递消息，而是通过ActiveMQ（低耦合）异步的发送消息。</p>
<br>

<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <tags>
        <tag>activemq</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot整合Mybatis实现CRUD</title>
    <url>/2018/09/30/boot/springboot-mybatis/</url>
    <content><![CDATA[<h1 id="Spring-Boot入门之CRUD"><a href="#Spring-Boot入门之CRUD" class="headerlink" title="Spring Boot入门之CRUD"></a>Spring Boot入门之CRUD</h1><p>:tada: :tada: :tada: <strong>这里有丰富的 Spring 框架学习案例</strong></p>
<p><strong>仓库地址：<a href="https://github.com/TyCoding/spring-learn" target="_blank" rel="noopener">spring-learn</a></strong><br><strong>欢迎star、fork，给作者一些鼓励</strong></p>
<p>继上篇文章：<a href="http://tycoding.cn/2018/09/28/boot/spring-boot/" target="_blank" rel="noopener">Spring-Boot入门之环境搭建</a>。这次我们整合SpringBoot-Mybatis实现简单的CRUD业务。</p>
<p><strong>项目源码</strong>请看我的Github仓库：<a href="https://github.com/TyCoding/spring-boot" target="_blank" rel="noopener">教你优雅的入门Spring Boot框架</a></p>
<p><strong>如果觉得不错就点击右上角star鼓励一下笔者吧(#^.^#)</strong></p>
<p>需求：</p>
<ul>
<li>详解SpringBoot工程的构建、与SSM项目在工程搭建上的不同。</li>
<li>实现SpringBoot-Mybatis整合征服数据库。</li>
<li>解决页面跳转，详解与SSM阶段的不同。</li>
<li>实现分页查询，使用PaheHelper插件和ElementUI分页控件。</li>
<li>实现文件上传。</li>
<li>使用Spring AOP切面编程实现简易的实现登录拦截工程。</li>
</ul>
<a id="more"></a>


<h1 id="教你优雅的入门Spring-Boot框架"><a href="#教你优雅的入门Spring-Boot框架" class="headerlink" title="教你优雅的入门Spring Boot框架"></a>教你优雅的入门Spring Boot框架</h1><p><strong>技术栈</strong></p>
<ul>
<li>后端： SpringBoot + Mybatis</li>
<li>前端： Vue.JS + ElementUI</li>
</ul>
<p><strong>测试环境</strong></p>
<ul>
<li>IDEA + SpringBoot-2.0.5</li>
</ul>
<p><strong>项目设计</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── db  -- sql文件</span><br><span class="line">├── mvnw </span><br><span class="line">├── mvnw.cmd</span><br><span class="line">├── pom.xml  -- 项目依赖</span><br><span class="line">└── src</span><br><span class="line">    ├── main</span><br><span class="line">    │   ├── java</span><br><span class="line">    │   │   └── cn</span><br><span class="line">    │   │       └── tycoding</span><br><span class="line">    │   │           ├── SpringbootApplication.java  -- Spring Boot启动类</span><br><span class="line">    │   │           ├── controller  -- MVC-WEB层</span><br><span class="line">    │   │           ├── entity  -- 实体类</span><br><span class="line">    │   │           ├── interceptor  -- 自定义拦截器</span><br><span class="line">    │   │           ├── mapper  -- mybatis-Mapper层接口</span><br><span class="line">    │   │           └── service  -- service业务层</span><br><span class="line">    │   └── resources  -- Spring Boot资源文件 </span><br><span class="line">    │       ├── application.yml  -- Spring Boot核心配置文件</span><br><span class="line">    │       ├── mapper  -- Mybatis Mapper层配置文件</span><br><span class="line">    │       ├── static  -- 前端静态文件</span><br><span class="line">    │       └── templates  -- Thymeleaf模板引擎识别的HTML页面目录</span><br><span class="line">    └── test  -- 测试文件</span><br></pre></td></tr></table></figure>

<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>开始实战Spring Boot项目，首先，你需要将Spring Boot工程搭建出来。</p>
<p>Spring Boot工程搭建请看我的博客：<a href="http://tycoding.cn/2018/09/28/boot/spring-boot/" target="_blank" rel="noopener">Spring Boot入门之工程搭建</a></p>
<h2 id="Spring-Boot应用启动器"><a href="#Spring-Boot应用启动器" class="headerlink" title="Spring Boot应用启动器"></a>Spring Boot应用启动器</h2><p>Spring Boot提供了很多应用启动器，分别用来支持不同的功能，说白了就是<code>pom.xml</code>中的依赖配置，因为Spring Boot的自动化配置特性，我们并不需再考虑项目依赖版本问题，使用Spring Boot的应用启动器，它能自动帮我们将相关的依赖全部导入到项目中。</p>
<p>我们这里介绍几个常见的应用启动器：</p>
<ul>
<li><code>spring-boot-starter</code>: Spring Boot的核心启动器，包含了自动配置、日志和YAML</li>
<li><code>spring-boot-starter-aop</code>: 支持AOP面向切面编程的功能，包括spring-aop和AspecJ</li>
<li><code>spring-boot-starter-cache</code>: 支持Spring的Cache抽象</li>
<li><code>spring-boot-starter-artermis</code>: 通过Apache Artemis支持JMS（Java Message Service）的API</li>
<li><code>spring-boot-starter-data-jpa</code>: 支持JPA</li>
<li><code>spring-boot-starter-data-solr</code>: 支持Apache Solr搜索平台，包括spring-data-solr</li>
<li><code>spring-boot-starter-freemarker</code>: 支持FreeMarker模板引擎</li>
<li><code>spring-boot-starter-jdbc</code>: 支持JDBC数据库</li>
<li><code>spring-boot-starter-Redis</code>: 支持Redis键值储存数据库，包括spring-redis</li>
<li><code>spring-boot-starter-security</code>: 支持spring-security</li>
<li><code>spring-boot-starter-thymeleaf</code>: 支持Thymeleaf模板引擎，包括与Spring的集成</li>
<li><code>spring-boot-starter-web</code>: 支持全栈式web开发，包括tomcat和Spring-WebMVC</li>
<li><code>spring-boot-starter-log4j</code>: 支持Log4J日志框架</li>
<li><code>spring-boot-starter-logging</code>: 引入Spring Boot默认的日志框架Logback</li>
</ul>
<h2 id="Spring-Boot项目结构设计"><a href="#Spring-Boot项目结构设计" class="headerlink" title="Spring Boot项目结构设计"></a>Spring Boot项目结构设计</h2><p>Spring Boot项目（即Maven项目），当然拥有最基础的Maven项目结构。除此之外：</p>
<ol>
<li><p>Spring Boot项目中不包含webapp(webroot)目录。</p>
</li>
<li><p>Spring Boot默认提供的静态资源目录需要置于classpath下，且其下的目录名称要符合一定规定。</p>
</li>
<li><p>Spring Boot默认不提倡用XML配置文件，主张使用YML作为配置文件格式，YML有更简洁的语法。当然也可以使用.properties作为配置文件格式。</p>
</li>
<li><p>Spring Boot官方推荐使用Thymeleaf作为前端模板引擎，并且Thymeleaf默认将templates作为静态页面的存放目录（由配置文件指定）。</p>
</li>
<li><p>Spring Boot默认将<code>resources</code>作为静态资源的存放目录，存放前端静态文件、项目配置文件。</p>
</li>
<li><p>Spring Boot规定<code>resources</code>下的子级目录名要符合一定规则，一般我们设置<code>resources/static</code>为前端静态（JS,CSS）的存放目录；设置<code>resources/templates</code>作为HTML页面的存放目录。</p>
</li>
<li><p>Spring Boot指定的Thymeleaf模板引擎文件目录<code>/resources/templates</code>是受保护的目录，想当与之前的WEB-INF文件夹，里面的静态资源不能直接访问，一般我们通过Controller映射访问。</p>
</li>
<li><p>建议将Mybatis-Mapper的XML映射文件放于<code>resources/</code>目录下，我这里设为<code>resources/mapper</code>目录，且<code>src/main/java/Mapper</code>下的Mapper层接口要使用<code>@Mapper</code>注解标识，不然mybatis找不到接口对应的XML映射文件。</p>
</li>
<li><p><code>SpringBootApplication.java</code>为项目的启动器类，项目不需要部署到Tomcat上，由SpringBoot提供的服务器部署项目（运行启动器类即可）；且SpringBoot会自动扫描该启动器同级和子级下用注解标识的Bean。</p>
</li>
<li><p>Spring Boot不建议使用JSP页面，如果想使用，请自行百度解决办法。</p>
</li>
<li><p>上面说了Spring Boot提供的存放HTML静态页面的目录<code>resources/templates</code>是受保护的目录，访问其中的HTML页面要通过Controller映射，这就间接规定了你需要配置Spring的视图解析器，且Controller类不能使用<code>@RestController</code>标识。</p>
</li>
</ol>
<h1 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h1><p><em>首先：</em>  <strong>我想特殊强调的是：SpringBoot不是对Spring功能上的增强，而是提供了一种快速使用Spring的方式</strong>。一定要切记这一点。</p>
<p>学习SpringBoot框架，只是为了更简便的使用Spring框架，我们在SSM阶段学习的知识现在放在Spring Boot框架上开发是完全适用的，我们学习的大多数是SpringBoot的自动化配置方式。</p>
<p>因为Spring Boot框架的一大优势就是自动化配置，从pom.xml的配置中就能明显感受到。</p>
<p>所以这里推荐一下我之前的SSM阶段整合项目： <a href="https://github.com/TyCoding/ssm" target="_blank" rel="noopener">SSM详细入门整合案例</a>    <a href="https://github.com/TyCoding/ssm-redis-solr" target="_blank" rel="noopener">SSM+Redis+Shiro+Solr+Vue.js整合项目</a></p>
<h2 id="项目依赖"><a href="#项目依赖" class="headerlink" title="项目依赖"></a>项目依赖</h2><p>本项目的依赖文件请看Github仓库：<a href="https://github.com/TyCoding/spring-boot/blob/master/pom.xml" target="_blank" rel="noopener">spring-boot/pom.xml</a></p>
<h2 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h2><p>本项目数据库表设计请看GitHub仓库：<a href="https://github.com/TyCoding/spring-boot/tree/master/db" target="_blank" rel="noopener">spring-boot/db/</a></p>
<p>请运行项目前，先把数据库表结构建好</p>
<h2 id="SpringBoot整合Mybatis"><a href="#SpringBoot整合Mybatis" class="headerlink" title="SpringBoot整合Mybatis"></a>SpringBoot整合Mybatis</h2><p>之前已经说过：<strong>SpringBoot框架不是对Spring功能上的增强，而是提供了一种快速使用Spring的方式</strong></p>
<p>所以说，SpringBoot整合Mybatis的思想和Spring整合Mybatis的思想基本相同，不同之处有两点：</p>
<ul>
<li><p>1.Mapper接口的XML配置文件变化。之前我们使用Mybatis接口代理开发，规定Mapper映射文件要和接口在一个目录下；而这里Mapper映射文件置于<code>resources/mapper/</code>下，且置于<code>src/main/java/</code>下的Mapper接口需要用<code>@Mapper</code>注解标识，不然映射文件与接口无法匹配。</p>
</li>
<li><p>2.SpringBoot建议使用YAML作为配置文件，它有更简便的配置方式。所以整合Mybatis在配置文件上有一定的区别，但最终都是那几个参数的配置。</p>
</li>
</ul>
<p>关于YAML的语法请自行百度，我这里也仅仅是满足基本的配置需求，不涉及那种不易理解的语法。</p>
<h3 id="整合配置文件"><a href="#整合配置文件" class="headerlink" title="整合配置文件"></a>整合配置文件</h3><p>本例详细代码请看GitHub仓库：<a href="https://github.com/TyCoding/spring-boot/blob/master/src/main/resources/application.yml" target="_blank" rel="noopener">spring-boot/resources/application.yml</a></p>
<p>在Spring阶段用XML配置mybatis无非就是配置：1.连接池；2.数据库url连接；3.mysql驱动；4.其他初始化配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  datasource:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">springboot</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="comment">#druid相关配置</span></span><br><span class="line"><span class="attr">    druid:</span></span><br><span class="line">      <span class="comment">#监控统计拦截的filters</span></span><br><span class="line"><span class="attr">      filter:</span> <span class="string">stat</span></span><br><span class="line">      <span class="comment">#mysql驱动</span></span><br><span class="line"><span class="attr">      driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">      <span class="comment">#基本属性</span></span><br><span class="line"><span class="attr">      url:</span> <span class="attr">jdbc:mysql://127.0.0.1:3306/springboot?useUnicode=true&amp;characterEncoding=UTF-8&amp;allowMultiQueries=true</span></span><br><span class="line"><span class="attr">      username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">      password:</span> <span class="string">root</span></span><br><span class="line">      <span class="comment">#配置初始化大小/最小/最大</span></span><br><span class="line"><span class="attr">      initial-size:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">      min-idle:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">      max-active:</span> <span class="number">20</span></span><br><span class="line">      <span class="comment">#获取连接等待超时时间</span></span><br><span class="line"><span class="attr">      max-wait:</span> <span class="number">60000</span></span><br><span class="line">      <span class="comment">#间隔多久进行一次检测，检测需要关闭的空闲连接</span></span><br><span class="line"><span class="attr">      time-between-eviction-runs-millis:</span> <span class="number">60000</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#mybatis配置</span></span><br><span class="line"><span class="attr">  mybatis:</span></span><br><span class="line"><span class="attr">    mapper-locations:</span> <span class="attr">classpath:mapper/*.xml</span></span><br><span class="line"><span class="attr">    type-aliases-package:</span> <span class="string">cn.tycoding.entity</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：空格代表节点层次；注释部分用<code>#</code>标记</strong></p>
<p><strong>解释</strong></p>
<ol>
<li><p>我们实现的是spring-mybatis的整合，包含mybatis的配置以及datasource数据源的配置当然属于spring配置中的一部分，所以需要在<code>spring:</code>下。</p>
</li>
<li><p><code>mapper-locations</code>相当于XML中的<code>&lt;property name=&quot;mapperLocations&quot;&gt;</code>用来扫描Mapper层的配置文件，由于我们的配置文件在<code>resources</code>下，所以需要指定<code>classpath:</code>。</p>
</li>
<li><p><code>type-aliases-package</code>相当与XML中<code>&lt;property name=&quot;typeAliasesPackase&quot;&gt;</code>别名配置，一般取其下实体类类名作为别名。</p>
</li>
<li><p><code>datasource</code>数据源的配置，<code>name</code>表示当前数据源的名称，类似于之前的<code>&lt;bean id=&quot;dataSource&quot;&gt;</code>id属性，这里可以任意指定，因为我们无需关注Spring是怎么注入这个Bean对象的。</p>
</li>
<li><p><code>druid</code>代表本项目中使用了阿里的druid连接池，<code>driver-class-name:</code>相当于XML中的<code>&lt;property name=&quot;driverClassName&quot;&gt;</code>；<code>url</code>代表XML中的<code>&lt;property name=&quot;url&quot;&gt;</code>；<code>username</code>代表XML中的<code>&lt;property name=&quot;username&quot;&gt;</code>；<code>password</code>代表XML中的<code>&lt;property name=&quot;password&quot;&gt;</code>；其他druid的私有属性配置不再解释。这里注意druid连接池和c3p0连接池在XML的<property>的name中就不同，在此处SpringBoot的配置中当然名称也不同。</property></p>
</li>
</ol>
<p>如果Spring整合Mybtis的配置你已经很熟悉了，那么这个配置你肯定也很眼熟，从英文名称上就很容易区分出来。这里需要注意的就是YAML语法规定不同行空格代表了不同的层级结构。</p>
<p>既然完成了SpringBoot-Mybatis基本配置下面我们实战讲解如何实现基本的CRUD。</p>
<h3 id="实现查询"><a href="#实现查询" class="headerlink" title="实现查询"></a>实现查询</h3><blockquote>
<p>1.在<code>src/main/java/cn/tycoding/entity/</code>下新建<code>User.java</code>实体类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id; <span class="comment">//编号</span></span><br><span class="line">    <span class="keyword">private</span> String username; <span class="comment">//用户名</span></span><br><span class="line">    <span class="keyword">private</span> String password; <span class="comment">//密码</span></span><br><span class="line">    <span class="comment">//getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>2.在<code>src/main/java/cn/tycoding/service/</code>下创建<code>BaseService.java</code>通用接口，目的是简化service层接口基本CRUD方法的编写。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BaseService</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询所有</span></span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据ID查询</span></span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">findById</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除（批量）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(Long... ids)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是我对Service层基本CRUD接口的简易封装，使用了泛型类，其继承接口指定了什么泛型，T就代表什么类。</p>
<blockquote>
<p>3.在<code>src/main/java/cn/tycoding/service/</code>下创建<code>UserService.java</code>接口：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> <span class="keyword">extends</span> <span class="title">BaseService</span>&lt;<span class="title">User</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>4.在<code>src/main/java/cn/tycoding/service/impl/</code>下创建<code>UserServiceImpl.java</code>实现类：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.findAll();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//其他方法省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>5.在<code>src/main/java/cn/tycoding/mapper/</code>下创建<code>UserMapper.java</code>Mapper接口类：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，我们一定要使用<code>@Mapper</code>接口标识这个接口，不然Mybatis找不到其对应的XML映射文件。</p>
<blockquote>
<p>6.在<code>src/main/resources/mapper/</code>下创建<code>UserMapper.xml</code>映射文件：</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"cn.tycoding.mapper.UserMapper"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 查询所有 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAll"</span> <span class="attr">resultType</span>=<span class="string">"cn.tycoding.entity.User"</span>&gt;</span></span><br><span class="line">        SELECT * FROM tb_user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>7.在<code>src/main/java/cn/tycoding/controller/admin/</code>下创建<code>UserController.java</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/findAll"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.findAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>8.运行<code>src/main/java/cn/tycoding/SpringbootApplication.java</code>的main方法，启动springboot</p>
</blockquote>
<p>在浏览器上访问<code>localhost:8080/findAll</code>即可得到一串JSON数据。</p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>看了上面一步步的讲解。你应该明白了，其实和SSM阶段的CRUD基本相同，这里我就不再举例其他方法。</p>
<p>下面我们讲解一下不同的地方：</p>
<h2 id="实现页面跳转"><a href="#实现页面跳转" class="headerlink" title="实现页面跳转"></a>实现页面跳转</h2><p>因为Thymeleaf指定的目录<code>src/main/resources/templates/</code>是受保护的目录，其下的资源不能直接通过浏览器访问，可以使用Controller映射的方式访问，怎么映射呢？</p>
<blockquote>
<p>1.在application.yml中添加配置</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  thymeleaf:</span></span><br><span class="line"><span class="attr">    prefix:</span> <span class="attr">classpath:/templates/</span></span><br><span class="line"><span class="attr">    check-template-location:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    suffix:</span> <span class="string">.html</span></span><br><span class="line"><span class="attr">    encoding:</span> <span class="string">UTF-8</span></span><br><span class="line"><span class="attr">    mode:</span> <span class="string">LEGACYHTML5</span></span><br><span class="line"><span class="attr">    cache:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>指定Thymeleaf模板引擎扫描<code>resources</code>下的<code>templates</code>文件夹中已<code>.html</code>结尾的文件。这样就实现了MVC中关于视图解析器的配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置视图解析器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>是不是感觉方便很多呢？但这里需要注意的是：<code>classpath:</code>后的目录地址一定要先加<code>/</code>，比如目前的<code>classpath:/templates/</code>。</p>
<blockquote>
<p>2.在Controller添加映射方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(value = &#123;<span class="string">"/"</span>, <span class="string">"/index"</span>&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"home/index"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，访问<code>localhost:8080/index</code>将直接跳转到<code>resources/templates/home/index.html</code>页面。</p>
<h2 id="实现分页查询"><a href="#实现分页查询" class="headerlink" title="实现分页查询"></a>实现分页查询</h2><p>首先我们需要在application.yml中配置pageHelper插件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pagehelper:</span></span><br><span class="line"><span class="attr">  pagehelperDialect:</span> <span class="string">mysql</span></span><br><span class="line"><span class="attr">  reasonable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  support-methods-arguments:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>我这里使用了Mybatis的PageHelper分页插件，前端使用了ElementUI自带的分页插件：具体的教程请查看我的博客：<a href="http://tycoding.cn/2018/07/30/vue/vue-6/" target="_blank" rel="noopener">SpringMVC+ElementUI实现分页查询</a></p>
<p><strong>核心配置：</strong></p>
<p><code>UserServiceImp.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PageBean <span class="title">findByPage</span><span class="params">(Goods goods, <span class="keyword">int</span> pageCode, <span class="keyword">int</span> pageSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用Mybatis分页插件</span></span><br><span class="line">    PageHelper.startPage(pageCode, pageSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用分页查询方法，其实就是查询所有数据，mybatis自动帮我们进行分页计算</span></span><br><span class="line">    Page&lt;Goods&gt; page = goodsMapper.findByPage(goods);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PageBean(page.getTotal(), page.getResult());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现文件上传"><a href="#实现文件上传" class="headerlink" title="实现文件上传"></a>实现文件上传</h2><p>这里涉及的无非就是SpringMVC的文件上传，详细的教程请参看我的博客：<a href="http://tycoding.cn/ssm/2018/05/31/Spring-6/" target="_blank" rel="noopener">SpringMVC实现文件上传和下载</a></p>
<p>因为本项目中前端使用了ElementUI+Vue.JS技术，所以前端的文件上传和回显教程请看我的博客：<a href="http://tycoding.cn/2018/08/05/vue/vue-7/" target="_blank" rel="noopener">SpringMVC+ElementUI实现图片上传和回显</a></p>
<p>除了代码的编写，这里还要在application.yml中进行配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  servlet:</span></span><br><span class="line"><span class="attr">    multipart:</span></span><br><span class="line"><span class="attr">      max-file-size:</span> <span class="number">10</span><span class="string">Mb</span></span><br><span class="line"><span class="attr">      max-request-size:</span> <span class="number">100</span><span class="string">Mb</span></span><br></pre></td></tr></table></figure>

<p>这就相当于SpringMVC的XML配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"multipartResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxUploadSize"</span> <span class="attr">value</span>=<span class="string">"500000"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="使用Spring-AOP切面编程实现简单的登录拦截器"><a href="#使用Spring-AOP切面编程实现简单的登录拦截器" class="headerlink" title="使用Spring AOP切面编程实现简单的登录拦截器"></a>使用Spring AOP切面编程实现简单的登录拦截器</h2><p>本项目，我们先不整合Shiro和Spring Security这些安全框架，使用Spring AOP切面编程思想实现简单的登录拦截：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"within (cn.tycoding.controller..*) &amp;&amp; !within(cn.tycoding.controller.admin.LoginController)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">trackInfo</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">        HttpServletRequest request = attributes.getRequest();</span><br><span class="line">        User user = (User) request.getSession().getAttribute(<span class="string">"user"</span>);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">            attributes.getResponse().sendRedirect(<span class="string">"/login"</span>); <span class="comment">//手动转发到/login映射路径</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> joinPoint.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong></p>
<p>关于Spring AOP的切面编程请自行百度，或者你也可以看我的博客：<a href="http://tycoding.cn/ssm/2018/05/25/Spring-3/" target="_blank" rel="noopener">Spring AOP思想</a>。我们需要注意以下几点</p>
<ol>
<li><p>一定要熟悉AspectJ的切点表达式，在这里：<code>..*</code>表示其目录下的所有方法和子目录方法。</p>
</li>
<li><p>如果进行了登录拦截，即在session中没有获取到用户的登录信息，我们可能需要手动转发到<code>login</code>页面，这里访问的是<code>login</code>映射。</p>
</li>
<li><p>基于2，一定要指定Object返回值，若AOP拦截的Controller return了一个视图地址，那么本来Controller应该跳转到这个视图地址的，但是被AOP拦截了，那么原来Controller仍会执行return，但是视图地址却找不到404了。</p>
</li>
<li><p>切记一定要调用proceed()方法，proceed()：执行被通知的方法，如不调用将会阻止被通知的方法的调用，也就导致Controller中的return会404。</p>
</li>
</ol>
<h1 id="Preview"><a href="#Preview" class="headerlink" title="Preview"></a>Preview</h1><p><img src="/2018/09/30/boot/springboot-mybatis/1.png" alt></p>
<p><img src="/2018/09/30/boot/springboot-mybatis/2.png" alt></p>
<p><img src="/2018/09/30/boot/springboot-mybatis/3.png" alt></p>
<p><img src="/2018/09/30/boot/springboot-mybatis/4.png" alt></p>
<br>

<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>（一）Spring-Boot入门之工程搭建</title>
    <url>/2018/09/28/boot/spring-boot/</url>
    <content><![CDATA[<h1 id="初识Spring-Boot"><a href="#初识Spring-Boot" class="headerlink" title="初识Spring Boot"></a>初识Spring Boot</h1><p>:tada: :tada: :tada: <strong>这里有丰富的 Spring 框架学习案例</strong></p>
<p><strong>仓库地址：<a href="https://github.com/TyCoding/spring-learn" target="_blank" rel="noopener">spring-learn</a></strong><br><strong>欢迎star、fork，给作者一些鼓励</strong></p>
<p>在之前我们一直使用Spring、SpringMVC进行开发，的确，Spring让我们认识到了项目开发原来可以这么方便。但是大量的配置文件却是令人头痛的，即使我们想写一个简单的请求映射并在浏览器上发送Get请求测试，那么需要：1.在web.xml中配置DispatcherServlet; 2.在application.xml中配置注解扫描、注解驱动。可以看到：虽然Spring是轻量级的，但是Spring的配置却是重量级的。并且搭建每个Spring项目我们都需要考虑依赖版本是否冲突的问题…</p>
<p>So，SpringBoot将这一切都解决了。SpringBoot提供了一种固定的、约定优于配置风格的框架，让开发者能更快的创建基于Spring的应用程序和服务。</p>
<a id="more"></a>

<p><strong>SpringBoot</strong>有如下特性：</p>
<ol>
<li>更高效的创建基于Spring的应用服务</li>
<li>无需XML配置，可以修改默认值来满足特定的需求</li>
<li>提供了一些大型项目中常见的非功能性特性，如嵌入式服务器、安全…</li>
<li>Spring Boot并不是对Spring功能上的增强，而是提供了一种快速使用Spring的方式</li>
</ol>
<h1 id="SpringBoot项目搭建"><a href="#SpringBoot项目搭建" class="headerlink" title="SpringBoot项目搭建"></a>SpringBoot项目搭建</h1><p><strong>这里我选择使用IDEA来创建SpringBoot项目</strong>：</p>
<blockquote>
<p>1.选择Spring Initializr，并选择本地的JDK版本</p>
</blockquote>
<p><img src="/2018/09/28/boot/spring-boot/1.png" alt></p>
<blockquote>
<p>2.Next，指定Group和Artifact名称，并选择本机JDK版本</p>
</blockquote>
<p><img src="/2018/09/28/boot/spring-boot/2.png" alt></p>
<blockquote>
<p>3.选择项目所需依赖</p>
</blockquote>
<p><img src="/2018/09/28/boot/spring-boot/3.png" alt></p>
<p><strong>解释</strong></p>
<p><code>devtools</code>: SpringBoot提供的热部署插件，可以避免每次修改代码都要重新启动项目。。</p>
<p><code>lomback</code>: 使用Lomback可以减少项目中很多重复代码的书写，比如getter/setter/toString等方法的书写（虽然这些可能我们都是用的快捷键生成的代码）。具体用法可以参考博文：<a href="https://blog.csdn.net/motui/article/details/79012846" target="_blank" rel="noopener">lomback介绍</a></p>
<p><code>Thymeleaf</code>: 语法的支持</p>
<p><strong>注意：</strong> 以上依赖非必选，如果仅仅想尝试一下Spring Boot-HelloWorld，只需要选择其中的<code>web</code>依赖即可。</p>
<br>

<h1 id="SpringBoot起步"><a href="#SpringBoot起步" class="headerlink" title="SpringBoot起步"></a>SpringBoot起步</h1><p><img src="/2018/09/28/boot/spring-boot/4.png" alt></p>
<p>以上是新创建的Spring Boot项目。在SpringBoot中有一个启动器（引导类）的概念，我们首先看一下<code>SpringbootApplication.java</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringbootApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，仅是一个简单的main方法，其中最核心的就是<code>@SpringBootApplication</code>注解，它是一下三个注解的总和：</p>
<ol>
<li><code>@Configuration</code>: 用于定义一个配置类。</li>
<li><code>@EnableAutoConfiguration</code>: SpringBoot会自动根据你的jar包依赖来自动配置项目。</li>
<li><code>@ComponentSacn</code>: 告诉Spring哪个packages的用注解标识的类会被Spring自动扫描并且转入Bean容器。</li>
</ol>
<p>通过以上三个注解你就应该了解到了SpringBoot的作用：自动化配置项目。之前我们要手动进行的XML配置在这里仅需要这一个注解就完成了。且SpringBoot项目不需要单独部署到Tomcat中才能启动，通过这个启动器，SpringBoot会自动构建一个web容器，并将项目部署到其中。</p>
<p>So,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Run SpringBootApplication</span><br></pre></td></tr></table></figure>

<p><img src="/2018/09/28/boot/spring-boot/5.png" alt></p>
<p>发现报错，说<code>DataSource</code>数据源的url地址没有配置。之前我们提到了SpringBoot的特性就是自动化配置，它会根据你的依赖文件来配置项目，我们再看一下我们的<code>pom.xml</code>：</p>
<p><img src="/2018/09/28/boot/spring-boot/6.png" alt></p>
<p>其中最上层的<code>&lt;parent&gt;</code>节点约束了整个下面所有spring-boot依赖的版本，即这里使用了SpringBoot-2.0.5。然后关注<code>&lt;dependencies&gt;</code>节点下的前四个依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>Spring Boot应用启动器</strong></p>
<p><code>spring-boot-starter</code>: Spring Boot的核心启动器，包含了自动配置、日志和YAML。</p>
<p><code>spring-boot-starter-jdbc</code>: 支持JDBC数据库。</p>
<p><code>spring-boot-starter-thymeleaf</code>: 支持Thymeleaf模板引擎，包括与Spring的集成。</p>
<p><code>spring-boot-starter-web</code>: 支持全栈式开发，包括Tomcat和Spring-WebMVC。</p>
<p><code>mybatis-spring-boot-starter</code>: 整合spring-mybatis依赖。</p>
<p>前面我们强调的一点是Spring Boot能实现自动化配置，那么项目的依赖就决定了Spring Boot将如何自动配置项目，Spring Boot的启动器就决定了项目会以什么样的配置启动项目；如此，我们会明白这个报错是为什么了。</p>
<p>因为我们配置配置JDBC连接的数据库，所以报错，注释掉<code>spring-boot-starter-jdbc</code>和<code>mybatis-spring-boot-starter</code>依赖，再次启动<code>SpringBootApplication</code>:</p>
<p><img src="/2018/09/28/boot/spring-boot/7.png" alt></p>
<p>启动成功。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>在<code>src/main/java/cn/tycoding/springboot/</code>下创建<code>controller</code>文件夹并创建<code>LoginController.java</code>类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/login"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(@RequestParam(<span class="string">"username"</span>)</span> String username, @<span class="title">RequestParam</span><span class="params">(<span class="string">"password"</span>)</span> String password) </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"username:"</span> + username + <span class="string">", password:"</span> + password);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上就完成了在SSM阶段一个最基本的SpringMVC Controller映射方法的书写，那么测试一下：</p>
<p>在浏览器上访问：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">localhost:8080/login?username=tycoding&amp;password=123</span><br></pre></td></tr></table></figure>

<p>后端即可接收到username和password参数。</p>
<p>这时你会发现，SpringBoot内置的Web容器默认访问地址就是8080端口，如果想改变这个默认端口，修改<code>src/main/resources/application.properties</code>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">server.port=8088</span><br></pre></td></tr></table></figure>

<p>重启<code>SpringbootApplication</code>，访问：<code>localhost:8088/login?username=tycoding&amp;password=123</code></p>
<h2 id="读取配置文件信息"><a href="#读取配置文件信息" class="headerlink" title="读取配置文件信息"></a>读取配置文件信息</h2><p>在<code>src/main/resources/application.properties</code>中添加配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url=http://www.tycoding.cn</span><br></pre></td></tr></table></figure>

<p>在<code>LoginController.java</code>中添加映射方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Environment environment;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/blog"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> environment.getProperty(<span class="string">"url"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring提供的<code>Environment</code>类用户读取配置文件中参数，访问：<code>localhost:8088/blog</code>即可得到。</p>
<br>

<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>使用SSM+Solr优雅的实现电商项目中的搜索功能</title>
    <url>/2018/09/25/ssm/ssm-redis-solr/</url>
    <content><![CDATA[<p>在学习了<a href="http://www.tycoding.cn/2018/09/24/other/redis/">Redis&amp;Spring-Data-Redis入门</a>和<a href="http://tycoding.cn/2018/09/24/other/solr/" target="_blank" rel="noopener">Solr&amp;Spring-Data-Solr入门</a>后，接下来就该是项目实战了。这次我们用Vue.JS和ElementUI写前端页面，优雅的整合SSM-Shiro-Redis-Solr框架。</p>
<p><strong>手摸手教你优雅的实现电商项目中的Solr搜索功能，整合SSM框架和Shiro安全框架；教你用Vue.JS和ElementUI写出超漂亮的页面</strong></p>
<p><strong>项目开源地址：<a href="https://github.com/TyCoding/ssm-redis-solr" target="_blank" rel="noopener">SSM整合Solr实现电商项目中的搜索功能</a></strong></p>
<a id="more"></a>

<p><strong>技术栈</strong></p>
<ul>
<li><p>后端： SSM + Shiro + Redis + Solr</p>
</li>
<li><p>前端： Vue.JS + ElementUI</p>
</li>
</ul>
<p><strong>测试环境</strong></p>
<p>IDEA + Maven + Tomcat8</p>
<p><strong>项目设计</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssm-redis-solr</span><br><span class="line">├── README</span><br><span class="line">├── README.md</span><br><span class="line">├── db</span><br><span class="line">│   ├── sys_schema.sql  -- 建表SQL</span><br><span class="line">│   └── tb_item.sql  -- 商品数据，共934条数据</span><br><span class="line">├── pom.xml</span><br><span class="line">├── src</span><br><span class="line">│   ├── main</span><br><span class="line">│   │   ├── java</span><br><span class="line">│   │   │   └── cn</span><br><span class="line">│   │   │       └── tycoding</span><br><span class="line">│   │   │           ├── controller  -- SpringMVC的控制层（web层）</span><br><span class="line">│   │   │           ├── credentials  -- shiro密码加密验证服务类CredentialsMatcher,用于登录错误次数限制</span><br><span class="line">│   │   │           ├── entity  -- javaBean实体类</span><br><span class="line">│   │   │           ├── mapper  -- mybatis-mapper层接口和XML映射文件</span><br><span class="line">│   │   │           ├── realm -- shiro自定义Realm实现类</span><br><span class="line">│   │   │           ├── service -- service服务层接口</span><br><span class="line">│   │   │           └── utils -- 通用util工具类</span><br><span class="line">│   │   ├── resources</span><br><span class="line">│   │   │   ├── mybatis -- mybatis配置文件</span><br><span class="line">│   │   │   ├── other -- 存放参数的配置文件</span><br><span class="line">│   │   │   └── spring -- spring集成shiro,myabtis,mvc,redis,solr的配置文件</span><br><span class="line">│   │   └── webapp</span><br><span class="line">│   │       ├── WEB-INF</span><br><span class="line">│   │       ├── goods.html  -- 商品列表页</span><br><span class="line">│   │       ├── index.html  -- 项目首页</span><br><span class="line">│   │       ├── login.html  -- 登录页</span><br><span class="line">│   │       └── static -- 前端静态依赖文件</span><br><span class="line">│   └── test</span><br></pre></td></tr></table></figure>

<br>

<p><strong>写在前面</strong></p>
<ol>
<li>本项目中使用的8081端口。</li>
<li>你需要在本地或服务器上配置Solr和Redis，文档中都配置在本地演示的。其中：redis占用6379端口（默认）、solr配置在Tomcat中，你可以下载我在GitHub上发布的配置好的solr，solr占用8080端口。</li>
<li>使用命令<code>redis-server &amp;</code>命令启动Redis，启动成功会显示一个大Logo。</li>
<li>启动部署了solr的Tomcat，默认使用8080端口，启动成功后用浏览器访问<code>http://localhost:8080/solr/index.html</code>，如果进入了solr的管理页面证明Solr配置、启动成功。</li>
<li>本例中将solr和redis部署在本地电脑上，如果你仔细阅读了这篇文档，启动项目应该是很容易的。如果你把solr或redis部署在其他地方，请自行修改<code>resource/spring/spring-solr.xml</code>和<code>resource/other/redis-config.properties</code>配置文件信息。</li>
<li>请修改<code>resource/other/jdbc.properties</code>中连接数据库的信息。</li>
<li>只有完成了上述步骤后再启动项目，不然项目会因为连接不上solr或redis而报错。</li>
</ol>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><h2 id="Shiro"><a href="#Shiro" class="headerlink" title="Shiro"></a>Shiro</h2><p>关于Shiro，我这里写了详细的SSM框架整合Shiro安全框架的文档，利用SSM框架+Shiro框架实现用户-角色-权限管理系统；</p>
<p>详细的文档地址：<a href="http://tycoding.cn/2018/09/18/ssm/shiro/ssm-shiro/" target="_blank" rel="noopener">SSM整合Shiro框架后的开发</a></p>
<p>项目Github源码地址：<a href="https://github.com/TyCoding/shiro" target="_blank" rel="noopener">SSM整合Shiro框架后的开发</a>， 欢迎star</p>
<br>

<h2 id="Solr-amp-Spring-Data-Solr"><a href="#Solr-amp-Spring-Data-Solr" class="headerlink" title="Solr &amp; Spring-Data-Solr"></a>Solr &amp; Spring-Data-Solr</h2><p>** 关于Solr安装配置和Spring-Data-Solr的入门Demo请查看博文：<a href="http://tycoding.cn/2018/09/24/other/solr/" target="_blank" rel="noopener">Solr和Spring-Data-Solr的入门学习</a> **</p>
<p>Solr需要单独部署到Tomcat服务器上，我这里提供自己已经安装和配置好的Tomcat和Solr: <a href="https://github.com/TyCoding/solr-tomcat" target="_blank" rel="noopener">Github</a></p>
<p><strong>注意事项：</strong></p>
<ol>
<li><p>部署Solr的Tomcat端口和本地项目的端口不能相同，会冲突。</p>
</li>
<li><p>注意<a href="https://github.com/TyCoding/solr-tomcat" target="_blank" rel="noopener">Github仓库</a>中<code>solr-tomcat/webapps/solr/WEB-INF/web.xml</code>中solrhome的位置要修改为自己的。</p>
</li>
</ol>
<br>

<h2 id="Redis-amp-Spring-Data-Redis"><a href="#Redis-amp-Spring-Data-Redis" class="headerlink" title="Redis &amp; Spring-Data-Redis"></a>Redis &amp; Spring-Data-Redis</h2><p>关于Redis安装配置和Spring-Data-Redis的入门Demo请查看博文：<a href="http://tycoding.cn/2018/09/24/other/redis/" target="_blank" rel="noopener">Redis和Spring-Data-Redis的入门学习</a></p>
<br>

<h1 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h1><h2 id="启动Solr和Redis"><a href="#启动Solr和Redis" class="headerlink" title="启动Solr和Redis"></a>启动Solr和Redis</h2><p><img src="/2018/09/25/ssm/ssm-redis-solr/5.png" alt></p>
<p>如果访问<code>localhost:8080/solr/index.html</code>出现Solr Admin页则启动成功。</p>
<br>

<h2 id="初始化表结构"><a href="#初始化表结构" class="headerlink" title="初始化表结构"></a>初始化表结构</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> ssm_redis <span class="keyword">DEFAULT</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8;</span><br></pre></td></tr></table></figure>

<p>具体的数据库约束文件和表数据请看：<a href="https://github.com/TyCoding/ssm-redis-solr/tree/master/db" target="_blank" rel="noopener">ssm-redis-solr/db</a></p>
<p>这里我们模拟添加了<strong>934条</strong>商品数据</p>
<br>

<h2 id="搭建SSM-Shiro集成环境"><a href="#搭建SSM-Shiro集成环境" class="headerlink" title="搭建SSM-Shiro集成环境"></a>搭建SSM-Shiro集成环境</h2><p>具体的SSM整合Shiro的教程请看我这个项目: <a href="https://github.com/TyCoding/shiro" target="_blank" rel="noopener">手摸手教你SSM整合Shiro</a>。这里不再说SSM整合Shiro的教程，默认认为已经大家已经完成。</p>
<br>

<h2 id="搭建SSM-Redis集成环境"><a href="#搭建SSM-Redis集成环境" class="headerlink" title="搭建SSM-Redis集成环境"></a>搭建SSM-Redis集成环境</h2><p>集成SSM-Redis开发环境，首先你需要安装Redis并启动Redis-Server，然后就是在项目中搭建Spring-Data-Redis的运行环境：</p>
<br>

<p><strong>创建redis-config.properties配置文件</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">redis.host=127.0.0.1</span><br><span class="line">redis.port=6379</span><br><span class="line">redis.pass=</span><br><span class="line">redis.database=0</span><br><span class="line">redis.maxIdle=300</span><br><span class="line">redis.maxWait=3000</span><br><span class="line">redis.testOnBorrow=true</span><br></pre></td></tr></table></figure>

<h3 id="创建spring-redis-xml"><a href="#创建spring-redis-xml" class="headerlink" title="创建spring-redis.xml"></a>创建spring-redis.xml</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:other/*.properties"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- redis 相关配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"poolConfig"</span> <span class="attr">class</span>=<span class="string">"redis.clients.jedis.JedisPoolConfig"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 最大空闲数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxIdle"</span> <span class="attr">value</span>=<span class="string">"$&#123;redis.maxIdle&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 连接时最大的等待时间（毫秒） --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxWaitMillis"</span> <span class="attr">value</span>=<span class="string">"$&#123;redis.maxWait&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 在提取一个jedis实例时，是否提前进行验证操作；如果为true，则得到的jedis实例均是可用的 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"testOnBorrow"</span> <span class="attr">value</span>=<span class="string">"$&#123;redis.testOnBorrow&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jedisConnectionFactory"</span> <span class="attr">class</span>=<span class="string">"org.springframework.data.redis.connection.jedis.JedisConnectionFactory"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hostName"</span> <span class="attr">value</span>=<span class="string">"$&#123;redis.host&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"port"</span> <span class="attr">value</span>=<span class="string">"$&#123;redis.port&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;redis.pass&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"poolConfig"</span> <span class="attr">ref</span>=<span class="string">"poolConfig"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"redisTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.data.redis.core.RedisTemplate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionFactory"</span> <span class="attr">ref</span>=<span class="string">"jedisConnectionFactory"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 序列化策略 推荐使用StringRedisSerializer --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"keySerializer"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.data.redis.serializer.StringRedisSerializer"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"valueSerializer"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.data.redis.serializer.StringRedisSerializer"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hashKeySerializer"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.data.redis.serializer.JdkSerializationRedisSerializer"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hashValueSerializer"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.data.redis.serializer.JdkSerializationRedisSerializer"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置文件我们已经在博文<a href="http://tycoding.cn/2018/09/24/other/redis/#more" target="_blank" rel="noopener">Redis&amp;Spring-Data-Redis入门</a>中介绍过了，其中最需要关注的就是<code>hashKeySerializer</code>序列化配置。</p>
<p>如果你不添加序列化配置也是没影响的，但是存入Redis数据库中的KEY和VALUE值都是乱码的，当然是用Spring-Data-Redis是毫无影响的。</p>
<p>如果添加了序列化配置：配置值类型数据用<code>StringRedisSerializer</code>序列化方式；配置Hash类型数据用<code>JdkSerializationRedisSerializer</code>序列化方式。</p>
<br>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(locations = &#123;<span class="string">"classpath:spring/spring*.xml"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRedisTemplate</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        redisTemplate.boundValueOps(<span class="string">"name"</span>).set(<span class="string">"tycoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在<code>redis-cli</code>命令行窗口中输入<code>get name</code>就能得到VALUE为：tycoding。</p>
<p>至此，SSM集成Redis已经完成。</p>
<br>

<h2 id="搭建SSM-Solr集成环境"><a href="#搭建SSM-Solr集成环境" class="headerlink" title="搭建SSM-Solr集成环境"></a>搭建SSM-Solr集成环境</h2><h3 id="创建spring-solr-xml"><a href="#创建spring-solr-xml" class="headerlink" title="创建spring-solr.xml"></a>创建spring-solr.xml</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:solr</span>=<span class="string">"http://www.springframework.org/schema/data/solr"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/data/solr</span></span></span><br><span class="line"><span class="tag"><span class="string">  		http://www.springframework.org/schema/data/solr/spring-solr-1.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- solr服务器地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">solr:solr-server</span> <span class="attr">id</span>=<span class="string">"solrServer"</span> <span class="attr">url</span>=<span class="string">"http://127.0.0.1:8080/solr/new_core"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- solr模板，使用solr模板可对索引库进行CRUD的操作 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"solrTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.data.solr.core.SolrTemplate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"solrServer"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>spring-solr配置文件我们再博文<a href="http://tycoding.cn/2018/09/24/other/solr/" target="_blank" rel="noopener">Solr&amp;Spring-Data-Solr入门</a>中我们已经介绍过了。其中最需要注意的就是solr服务器url地址的配置，组成结构一定要是：Ip + 端口 + solr项目名称 + core实例名称</p>
<h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(locations = <span class="string">"classpath:spring/spring-solr.xml"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSolrTemplate</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SolrTemplate solrTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAdd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Goods goods = <span class="keyword">new</span> Goods(<span class="number">1L</span>, <span class="string">"IPhone SE"</span>, <span class="string">"120"</span>, <span class="string">"手机"</span>, <span class="string">"Apple"</span>, <span class="string">"Apple"</span>);</span><br><span class="line">        solrTemplate.saveBean(goods);</span><br><span class="line">        solrTemplate.commit(); <span class="comment">//提交</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于Goods实体类定义，请看<a href="https://github.com/TyCoding/ssm-redis-solr/blob/master/src/main/java/cn/tycoding/entity/Goods.java" target="_blank" rel="noopener">/java/cn/tycoding/entity/Goods.java</a><br>然后我们在浏览器中访问<code>localhost:8080/solr/index.html</code>，点击Query可以看到：</p>
<p><img src="/2018/09/25/ssm/ssm-redis-solr/6.png" alt></p>
<br>

<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><h2 id="数据库数据批量导入Solr索引库"><a href="#数据库数据批量导入Solr索引库" class="headerlink" title="数据库数据批量导入Solr索引库"></a>数据库数据批量导入Solr索引库</h2><p>上面已经完成了SSM-Shiro-Redis-Solr的集成环境配置，那么思考：既然用Solr完成搜索功能，那么怎么实现呢？</p>
<p>以前我们直接请求数据库用<code>concat()</code>模糊查询实现搜索功能，但是这种方式有很大的弊端：1.给数据库造成的访问压力很大；2.无法识别用户查询的数据到底是<code>title</code>字段还是<code>price</code>字段…<br>如果用Solr完成搜索功能，就很容易解决了这些问题。那么我们需要往Solr索引库中添加数据，Sorl才能搜索出来数据呀：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SolrUtil</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> GoodsMapper goodsMapper;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SolrTemplate solrTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现将数据库中的数据批量导入到Solr索引库中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">importGoodsData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Goods&gt; list = goodsMapper.findAll();</span><br><span class="line">        System.out.println(<span class="string">"====商品列表===="</span>);</span><br><span class="line">        <span class="keyword">for</span> (Goods goods : list) &#123;</span><br><span class="line">            System.out.println(goods.getTitle());</span><br><span class="line">        &#125;</span><br><span class="line">        solrTemplate.saveBeans(list);</span><br><span class="line">        solrTemplate.commit(); <span class="comment">//提交</span></span><br><span class="line">        System.out.println(<span class="string">"====结束===="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:spring/spring*.xml"</span>);</span><br><span class="line">        SolrUtil solrUtil = (SolrUtil) context.getBean(<span class="string">"solrUtil"</span>);</span><br><span class="line">        solrUtil.importGoodsData();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的Mapper.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAll"</span> <span class="attr">resultType</span>=<span class="string">"cn.tycoding.entity.Goods"</span>&gt;</span></span><br><span class="line">    SELECT * FROM tb_item</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>目的就是查询数据库中所有数据，然后调用<code>solrTemplate.saveBean(List)</code>将查询到的List集合数据添加到Solr索引库中，之后我们在<code>localhost:8080/solr/index.html</code>中能查询出来共有934条记录数据。</p>
<br>

<h2 id="实现Solr搜索功能"><a href="#实现Solr搜索功能" class="headerlink" title="实现Solr搜索功能"></a>实现Solr搜索功能</h2><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><p>由于前端使用了<a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="noopener">Vue.JS</a>和<a href="http://element-cn.eleme.io/#/zh-CN" target="_blank" rel="noopener">ElementUI</a>，如果不了解的话请仔细阅读官方文档，或者，你可以查看我的博文记录: <a href="http://www.tycoding.cn/2018/07/27/vue/vue-5/">Vue学习学习笔记</a></p>
<p>在<a href="https://github.com/TyCoding/ssm-redis-solr/blob/master/src/main/webapp/index.html" target="_blank" rel="noopener">index.html</a>中定义：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-input</span> <span class="attr">placeholder</span>=<span class="string">"请输入内容"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"input-with-select"</span> @<span class="attr">keyup.enter.native</span>=<span class="string">"search"</span> <span class="attr">v-model</span>=<span class="string">"searchMap.keywords"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">slot</span>=<span class="string">"append"</span> <span class="attr">icon</span>=<span class="string">"el-icon-search"</span> @<span class="attr">click</span>=<span class="string">"search"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在<a href="https://github.com/TyCoding/ssm-redis-solr/blob/master/src/main/webapp/static/js/index.js" target="_blank" rel="noopener">index.js</a>中定义：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    searchMap: &#123; <span class="attr">keywords</span>: <span class="string">''</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  search() &#123;</span><br><span class="line">      <span class="keyword">this</span>.$http.post(<span class="string">'goods/search.do'</span>, <span class="keyword">this</span>.searchMap).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.goods = result.body.rows;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><p>在<a href="https://github.com/TyCoding/ssm-redis-solr/blob/master/src/main/java/cn/tycoding/controller/GoodsController.java" target="_blank" rel="noopener">GoodsController.java</a>中定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/search"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">search</span><span class="params">(@RequestBody Map&lt;String, Object&gt; searchMap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> goodsService.search(searchMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么要用Map接收前端数据？</strong></p>
<p>如果前端传来的数据不止一个，且不属于后端的任何一个实体类对象，前端传来的仅是一个自定义的对象(<code>xx:{}</code>)；那么后端势必不能通过实体类对象来接收，且是POST请求，后端必须也使用对象类型来接收数据且必须用<code>@RequestBody</code>标识对象，原因：</p>
<ol>
<li>前端传来的数据不止一种。</li>
<li>前端传来的数据封装在对象中。</li>
</ol>
<p>所以，综上，Map&lt;K, V&gt;这种数据结构最适合作为接收对象类型。</p>
<br>

<p>在<a href="https://github.com/TyCoding/ssm-redis-solr/blob/master/src/main/java/cn/tycoding/service/impl/GoodsServiceImpl.java" target="_blank" rel="noopener">GoodsServiceImpl.xml</a>中定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">search</span><span class="params">(Map searchMap)</span> </span>&#123;</span><br><span class="line">  Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">  Query query = <span class="keyword">new</span> SimpleQuery();</span><br><span class="line">  <span class="comment">//添加查询条件</span></span><br><span class="line">  Criteria criteria = <span class="keyword">new</span> Criteria(<span class="string">"item_keywords"</span>).is(searchMap.get(<span class="string">"keywords"</span>));</span><br><span class="line">  query.addCriteria(criteria);</span><br><span class="line">  ScoredPage&lt;Goods&gt; page = solrTemplate.queryForPage(query, Goods.class);</span><br><span class="line">  map.put(<span class="string">"rows"</span>, page.getContent()); <span class="comment">//返回查询到的数据</span></span><br><span class="line">  <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动项目，再搜索框中输入<code>苹果</code>回车即出现：</p>
<p><img src="/2018/09/25/ssm/ssm-redis-solr/7.png" alt></p>
<p>但是发现页面中只显示10条数据（实际我们添加的苹果手机数据不止10条），为了更优雅的显示，我们实现分页</p>
<br>

<h4 id="实现分页查询"><a href="#实现分页查询" class="headerlink" title="实现分页查询"></a>实现分页查询</h4><p>在后端中我们用<code>limit</code>方式显示分页，或者更简单的用Mybatis的<code>PageHelper</code>分页查询实现分页查询。<br>而，我们在博文<a href="http://www.tycoding.cn/2018/09/24/other/solr/">Solr&amp;Spring-Data-Solr入门学习</a>中讲了Solr分页查询的方式：</p>
<p>修改<a href="https://github.com/TyCoding/ssm-redis-solr/blob/master/src/main/java/cn/tycoding/service/impl/GoodsServiceImpl.java" target="_blank" rel="noopener">GoodsServiceImpl.java</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">search</span><span class="params">(Map searchMap)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">    Query query = <span class="keyword">new</span> SimpleQuery();</span><br><span class="line">    <span class="comment">//添加查询条件</span></span><br><span class="line">    Criteria criteria = <span class="keyword">new</span> Criteria(<span class="string">"item_keywords"</span>);</span><br><span class="line">    <span class="keyword">if</span> (searchMap.get(<span class="string">"keywords"</span>) != <span class="keyword">null</span> &amp;&amp; searchMap.get(<span class="string">"keywords"</span>) != <span class="string">""</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行了..."</span>);</span><br><span class="line">        criteria.is(searchMap.get(<span class="string">"keywords"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    query.addCriteria(criteria);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分页查询</span></span><br><span class="line">    Integer pageCode = (Integer) searchMap.get(<span class="string">"pageCode"</span>);</span><br><span class="line">    <span class="keyword">if</span> (pageCode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        pageCode = <span class="number">1</span>; <span class="comment">//默认第一页</span></span><br><span class="line">    &#125;</span><br><span class="line">    Integer pageSize = (Integer) searchMap.get(<span class="string">"pageSize"</span>);</span><br><span class="line">    <span class="keyword">if</span> (pageSize == <span class="keyword">null</span>) &#123;</span><br><span class="line">        pageSize = <span class="number">18</span>; <span class="comment">//默认18</span></span><br><span class="line">    &#125;</span><br><span class="line">    query.setOffset((pageCode - <span class="number">1</span>) * pageSize); <span class="comment">//从第几条记录开始查询：= 当前页 * 每页的记录数</span></span><br><span class="line">    query.setRows(pageSize);</span><br><span class="line">    ScoredPage&lt;Goods&gt; page = solrTemplate.queryForPage(query, Goods.class);</span><br><span class="line">    map.put(<span class="string">"rows"</span>, page.getContent()); <span class="comment">//返回查询到的数据</span></span><br><span class="line">    map.put(<span class="string">"totalPage"</span>, page.getTotalPages()); <span class="comment">//返回总页数</span></span><br><span class="line">    map.put(<span class="string">"total"</span>, page.getTotalElements()); <span class="comment">//返回总记录数</span></span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="前端-1"><a href="#前端-1" class="headerlink" title="前端"></a>前端</h5><p>ElementUI提供了分页查询的插件，我们仅需要传给它几个参数，即可实现分页，详细的文档介绍请看我这篇博文：<a href="http://www.tycoding.cn/2018/07/30/vue-6/">Vue+ElementUI实现分页</a></p>
<p>在<a href="https://github.com/TyCoding/ssm-redis-solr/blob/master/src/main/webapp/index.html" target="_blank" rel="noopener">index.html</a>中添加：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-pagination</span></span></span><br><span class="line"><span class="tag">        <span class="attr">background</span></span></span><br><span class="line"><span class="tag">        @<span class="attr">size-change</span>=<span class="string">"handleSizeChange"</span></span></span><br><span class="line"><span class="tag">        @<span class="attr">current-change</span>=<span class="string">"handleCurrentChange"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">:current-page</span>=<span class="string">"pageConf.pageCode"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">:page-sizes</span>=<span class="string">"pageConf.pageOption"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">:page-size</span>=<span class="string">"pageConf.pageSize"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">layout</span>=<span class="string">"total, sizes, prev, pager, next, jumper"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">:total</span>=<span class="string">"pageConf.totalPage"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-pagination</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在<a href="https://github.com/TyCoding/ssm-redis-solr/blob/master/src/main/webapp/static/js/index.js" target="_blank" rel="noopener">index.js</a>中添加：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    searchMap: &#123;</span><br><span class="line">        keywords: <span class="string">''</span>,</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分页选项</span></span><br><span class="line">        pageCode: <span class="string">''</span>, <span class="comment">//当前页</span></span><br><span class="line">        pageSize: <span class="string">''</span>, <span class="comment">//每页的记录数</span></span><br><span class="line">    &#125;</span><br><span class="line">    pageConf: &#123;</span><br><span class="line">        <span class="comment">//设置一些初始值(会被覆盖)</span></span><br><span class="line">        pageCode: <span class="number">1</span>, <span class="comment">//当前页</span></span><br><span class="line">        pageSize: <span class="number">18</span>, <span class="comment">//每页显示的记录数</span></span><br><span class="line">        totalPage: <span class="number">20</span>, <span class="comment">//总记录数</span></span><br><span class="line">        pageOption: [<span class="number">18</span>, <span class="number">25</span>, <span class="number">30</span>], <span class="comment">//分页选项</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">    <span class="comment">//pageSize改变时触发的函数</span></span><br><span class="line">    handleSizeChange(val) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(val);</span><br><span class="line">        <span class="keyword">this</span>.searchMap.pageSize = val;</span><br><span class="line">        <span class="keyword">this</span>.searchMap.pageCode = <span class="keyword">this</span>.pageConf.pageCode;</span><br><span class="line">        <span class="keyword">this</span>.search(<span class="keyword">this</span>.pageConf.pageCode, val);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//当前页改变时触发的函数</span></span><br><span class="line">    handleCurrentChange(val) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(val);</span><br><span class="line">        <span class="keyword">this</span>.searchMap.pageCode = val;</span><br><span class="line">        <span class="keyword">this</span>.searchMap.pageSize = <span class="keyword">this</span>.pageConf.pageSize;</span><br><span class="line">        <span class="keyword">this</span>.search(val, <span class="keyword">this</span>.searchMap.pageSize);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们只需要修改以上JavaScript代码即可，因为<code>search</code>方法传给后台的是<code>searchMap</code>这个对象数据，只要其中包含了<code>pageCode</code>和<code>pageSize</code>这两个参数，就会被封装到后端接收的Map集合中。<br>其中点击上一页，下一页按钮触发的函数在<code>&lt;el-pagination&gt;</code>中已经定义了，如果点击上一页下一页触发<code>handleCurrentChange()</code>函数，如果点击每页5条记录变成10条记录就会触发<code>handleSizeChange()</code>函数；两个函数都又调用了<code>search()</code>方法，当点击分页按钮时就发送数据给后端，其中包含当前点击的<code>pageCode</code>和<code>pageSize</code>的值，后端接收到这两个值进行分页计算，并将数据返回给前端。</p>
<p><img src="/2018/09/25/ssm/ssm-redis-solr/8.png" alt></p>
<br>

<h4 id="实现条件过滤"><a href="#实现条件过滤" class="headerlink" title="实现条件过滤"></a>实现条件过滤</h4><p>上面讲了分页查询，仅仅是单方面的查询，并没有任何条件限制。这一功能在SSM中我们直接通过<code>concat()</code>模糊条件过滤，但在Solr中提供了<code>FilterQuery()</code>实现条件过滤查询：</p>
<p>修改<a href="https://github.com/TyCoding/ssm-redis-solr/blob/master/src/main/java/cn/tycoding/service/impl/GoodsServiceImpl.java" target="_blank" rel="noopener">GoodsServiceImpl.java</a>文件，在<code>search()</code>方法中添加：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (searchMap.get(<span class="string">"category"</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!searchMap.get(<span class="string">"category"</span>).equals(<span class="string">""</span>)) &#123;</span><br><span class="line">        System.out.println(<span class="string">"执行了category"</span>);</span><br><span class="line">        FilterQuery filterQuery = <span class="keyword">new</span> SimpleFilterQuery();</span><br><span class="line">        Criteria filterCriteria = <span class="keyword">new</span> Criteria(<span class="string">"item_category"</span>).is(searchMap.get(<span class="string">"category"</span>));</span><br><span class="line">        filterQuery.addCriteria(filterCriteria);</span><br><span class="line">        query.addFilterQuery(filterQuery);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按品牌过滤</span></span><br><span class="line"><span class="keyword">if</span> (searchMap.get(<span class="string">"brand"</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!searchMap.get(<span class="string">"brand"</span>).equals(<span class="string">""</span>)) &#123;</span><br><span class="line">        System.out.println(<span class="string">"执行了brand..."</span>);</span><br><span class="line">        FilterQuery filterQuery = <span class="keyword">new</span> SimpleFilterQuery();</span><br><span class="line">        Criteria filterCriteria = <span class="keyword">new</span> Criteria(<span class="string">"item_brand"</span>).is(searchMap.get(<span class="string">"brand"</span>));</span><br><span class="line">        filterQuery.addCriteria(filterCriteria);</span><br><span class="line">        query.addFilterQuery(filterQuery);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="前端-2"><a href="#前端-2" class="headerlink" title="前端"></a>前端</h5><p>修改<a href="https://github.com/TyCoding/ssm-redis-solr/blob/master/src/main/webapp/index.html" target="_blank" rel="noopener">index.html</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-checkbox-group</span> <span class="attr">:max</span>=<span class="string">"1"</span> <span class="attr">v-model</span>=<span class="string">"change.category"</span> @<span class="attr">change</span>=<span class="string">"selectMethod"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-checkbox</span> <span class="attr">v-for</span>=<span class="string">"classify in classifyData.category"</span> <span class="attr">:label</span>=<span class="string">"classify"</span> <span class="attr">border</span> <span class="attr">size</span>=<span class="string">"mini"</span>&gt;</span>&#123;&#123;classify&#125;&#125;<span class="tag">&lt;/<span class="name">el-checkbox</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-checkbox-group</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-checkbox-group</span> <span class="attr">:max</span>=<span class="string">"1"</span> <span class="attr">v-model</span>=<span class="string">"change.brand"</span> @<span class="attr">change</span>=<span class="string">"selectMethod"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-checkbox</span> <span class="attr">v-for</span>=<span class="string">"classify in classifyData.brand"</span> <span class="attr">:label</span>=<span class="string">"classify"</span> <span class="attr">border</span> <span class="attr">size</span>=<span class="string">"mini"</span>&gt;</span>&#123;&#123;classify&#125;&#125;<span class="tag">&lt;/<span class="name">el-checkbox</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-checkbox-group</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>修改<a href="https://github.com/TyCoding/ssm-redis-solr/blob/master/src/main/webapp/static/js/index.js" target="_blank" rel="noopener">index.js</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">searchMap: &#123;</span><br><span class="line">  brand: <span class="string">''</span>,</span><br><span class="line">  price: <span class="string">''</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//checkbox选择的选项</span></span><br><span class="line">change: &#123;</span><br><span class="line">    category: [],</span><br><span class="line">    brand: [],</span><br><span class="line">    price: []</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">selectMethod(val) &#123;</span><br><span class="line">    <span class="keyword">this</span>.searchMap.category = <span class="keyword">this</span>.change.category[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">this</span>.searchMap.brand = <span class="keyword">this</span>.change.brand[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">this</span>.search(); <span class="comment">//每次点击后都进行查询</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<br>

<h4 id="实现商品价格升降过滤"><a href="#实现商品价格升降过滤" class="headerlink" title="实现商品价格升降过滤"></a>实现商品价格升降过滤</h4><p>修改<a href="https://github.com/TyCoding/ssm-redis-solr/blob/master/src/main/java/cn/tycoding/service/impl/GoodsServiceImpl.java" target="_blank" rel="noopener">GoodsServiceImpl.java</a>中的<code>search</code>方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按价格的升降序查询</span></span><br><span class="line"><span class="keyword">if</span> (searchMap.get(<span class="string">"sort"</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!searchMap.get(<span class="string">"sort"</span>).equals(<span class="string">""</span>)) &#123;</span><br><span class="line">        String sortValue = (String) searchMap.get(<span class="string">"sort"</span>);</span><br><span class="line">        String sortField = (String) searchMap.get(<span class="string">"field"</span>);</span><br><span class="line">        <span class="keyword">if</span> (sortValue != <span class="keyword">null</span> &amp;&amp; !sortValue.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sortValue.equals(<span class="string">"asc"</span>)) &#123;</span><br><span class="line">                Sort sort = <span class="keyword">new</span> Sort(Sort.Direction.ASC, <span class="string">"item_"</span> + sortField);</span><br><span class="line">                query.addSort(sort);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sortValue.equals(<span class="string">"desc"</span>)) &#123;</span><br><span class="line">                Sort sort = <span class="keyword">new</span> Sort(Sort.Direction.DESC, <span class="string">"item_"</span> + sortField);</span><br><span class="line">                query.addSort(sort);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="前端-3"><a href="#前端-3" class="headerlink" title="前端"></a>前端</h5><p>修改<a href="https://github.com/TyCoding/ssm-redis-solr/blob/master/src/main/webapp/index.html" target="_blank" rel="noopener">index.html</a>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-checkbox-group</span> <span class="attr">v-model</span>=<span class="string">"change.price"</span> <span class="attr">:max</span>=<span class="string">"1"</span> @<span class="attr">change</span>=<span class="string">"selectMethod"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-checkbox</span> <span class="attr">:label</span>=<span class="string">"'0-500'"</span> <span class="attr">border</span> <span class="attr">size</span>=<span class="string">"mini"</span>&gt;</span>0-500元<span class="tag">&lt;/<span class="name">el-checkbox</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-checkbox</span> <span class="attr">:label</span>=<span class="string">"'500-1000'"</span> <span class="attr">border</span> <span class="attr">size</span>=<span class="string">"mini"</span>&gt;</span>500-1000元<span class="tag">&lt;/<span class="name">el-checkbox</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">el-checkbox-group</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>修改<a href="https://github.com/TyCoding/ssm-redis-solr/blob/master/src/main/webapp/static/js/index.js" target="_blank" rel="noopener">index.js</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">searchMap: &#123;</span><br><span class="line">  price: <span class="string">''</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">selectMethod(val) &#123;</span><br><span class="line">  <span class="keyword">this</span>.searchMap.price = <span class="keyword">this</span>.change.sort[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2018/09/25/ssm/ssm-redis-solr/9.png" alt></p>
<br>

<h4 id="实现查询结果高亮显示"><a href="#实现查询结果高亮显示" class="headerlink" title="实现查询结果高亮显示"></a>实现查询结果高亮显示</h4><p>实现高亮显示，我们先看一下效果：</p>
<p><img src="/2018/09/25/ssm/ssm-redis-solr/10.png" alt></p>
<p>可看到根据关键字<code>苹果</code>查询出来的记录中<code>苹果</code>字样都被标记为红色斜体样式，这即是我们的目的，你可以查看淘宝的查询，也是查询字样以红色显示出来。</p>
<p>如果使用高亮查询，那么之前的<code>Query query = new SimpleQuery()</code>就不在满足需求了；高亮查询使用<code>HighlightQuery query = new SimpleHighlightQuery();</code></p>
<p>修改<a href="https://github.com/TyCoding/ssm-redis-solr/blob/master/src/main/java/cn/tycoding/service/impl/GoodsServiceImpl.java" target="_blank" rel="noopener">GoodsServiceImpl.java</a>中的<code>Search()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HighlightQuery query = <span class="keyword">new</span> SimpleHighlightQuery();</span><br><span class="line">HighlightOptions highlightOptions = <span class="keyword">new</span> HighlightOptions().addField(<span class="string">"item_title"</span>); <span class="comment">//设置高亮的域</span></span><br><span class="line">highlightOptions.setSimplePrefix(<span class="string">"&lt;em style='color: red'&gt;"</span>); <span class="comment">//设置高亮前缀</span></span><br><span class="line">highlightOptions.setSimplePostfix(<span class="string">"&lt;/em&gt;"</span>); <span class="comment">//设置高亮后缀</span></span><br><span class="line">query.setHighlightOptions(highlightOptions); <span class="comment">//设置高亮选项</span></span><br></pre></td></tr></table></figure>

<p>初始化高亮查询<code>HighlightQuery</code>类，利用其包含的<code>setSimplePerfix</code>设置查询结果的前缀html标签，利用<code>setSimplePostfix</code>设置查询结果后缀HTML标签。</p>
<p>循环高亮查询结果集合数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HighlightPage&lt;Goods&gt; page = solrTemplate.queryForHighlightPage(query, Goods.class);</span><br><span class="line"><span class="comment">//循环高亮入口集合</span></span><br><span class="line"><span class="keyword">for</span> (HighlightEntry&lt;Goods&gt; h : page.getHighlighted()) &#123;</span><br><span class="line">    Goods goods = h.getEntity(); <span class="comment">//获取原实体类</span></span><br><span class="line">    <span class="keyword">if</span> (h.getHighlights().size() &gt; <span class="number">0</span> &amp;&amp; h.getHighlights().get(<span class="number">0</span>).getSnipplets().size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        goods.setTitle(h.getHighlights().get(<span class="number">0</span>).getSnipplets().get(<span class="number">0</span>)); <span class="comment">//设置高亮的结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之前我们可以直接通过<code>query.getContent()</code>获取到查询结果，但是使用了高亮查询<code>HighlightQuery</code>就不能直接通过<code>getContent()</code>获取数据了，我们要手动遍历<code>HighlightPage</code>这个对象，他是一个层层嵌套的集合数据，详细数据结构这里不再说了。</p>
<br>

<h2 id="更新索引"><a href="#更新索引" class="headerlink" title="更新索引"></a>更新索引</h2><p>既然使用了Solr管理商品数据，查询时直接从Solr索引库中查询数据，而不是查询数据库中的数据，那么如果修改了商品的信息：添加、删除、修改。那么就必须同步使Solr索引库中的数据和数据库中的数据保持一致才能实现查询出来的数据是真实的。</p>
<p>所以我们要在对商品添加、删除、修改的时候同步更新Solr索引库数据：</p>
<p>修改<a href="https://github.com/TyCoding/ssm-redis-solr/blob/master/src/main/java/cn/tycoding/service/impl/GoodsServiceImpl.java" target="_blank" rel="noopener">GoodsServiceImpl.java</a>中<code>create</code>、<code>delete</code>、<code>update</code>方法，更新Solr索引库：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(Goods goods)</span> </span>&#123;</span><br><span class="line">    goodsMapper.create(goods);</span><br><span class="line"></span><br><span class="line">    Long id = goodsMapper.maxId(); <span class="comment">//获取根据主键自增插入的最新一条记录的ID值</span></span><br><span class="line">    goods.setId(id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新索引库</span></span><br><span class="line">    solrTemplate.saveBean(goods);</span><br><span class="line">    solrTemplate.commit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Goods goods)</span> </span>&#123;</span><br><span class="line">    goodsMapper.update(goods);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新索引库</span></span><br><span class="line">    solrTemplate.deleteById(String.valueOf(goods.getId()));</span><br><span class="line">    solrTemplate.commit();</span><br><span class="line">    List&lt;Goods&gt; list = <span class="keyword">new</span> ArrayList&lt;Goods&gt;();</span><br><span class="line">    list.add(goods);</span><br><span class="line">    solrTemplate.saveBeans(list);</span><br><span class="line">    solrTemplate.commit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Long... ids)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Long id : ids) &#123;</span><br><span class="line">        goodsMapper.delete(id);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新索引库</span></span><br><span class="line">        solrTemplate.deleteById(String.valueOf(id));</span><br><span class="line">        solrTemplate.commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，在添加商品时，传来的实体类中并不包含Id属性数据，因为我们使用了MySql的自增主键;而想要向Solr索引库中添加新数据又必须制定Id属性值，因为Solr不会自增主键呀。所以我们在<code>goodsMapper.create()</code>后调用<code>MaxId()</code>方法获取最新自增的主键值，其在Mapper.xml中定义：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"maxId"</span> <span class="attr">resultType</span>=<span class="string">"Long"</span>&gt;</span></span><br><span class="line">    SELECT MAX(id) FROM tb_item</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<br>

<h2 id="关于Redis"><a href="#关于Redis" class="headerlink" title="关于Redis"></a>关于Redis</h2><p>眼看着教程就结束了，但是为什么教程中没有解释Redis的应用呢？</p>
<p><strong>解释</strong></p>
<p>关于SSM整合Redis的教程请仔细看我的博文：<a href="http://www.tycoding.cn/2018/09/24/other/redis/">Redis和Spring-Data-Redis入门学习</a>。</p>
<p>因为Redis在本项目中并没有用到实际的应用中，为何？首先我们要考虑为什么要用Redis？</p>
<p>Redis缓存嘛，不就是缓存哪些大批量的数据减轻服务器压力的。但是，并不是说所有的大批量的数据都得去缓存，虽然我们项目中的<em>商品管理功能</em>中已经出现了900多条数据，但是这些数据都需要频繁的正删改，而缓存技术中一个难点就是缓存同步问题，你的缓存数据必须时刻和数据库（真实的数据）保持一致，如果每修改一条记录就去更新一遍缓存势必会给缓存服务器造成很大压力。</p>
<p>什么数据适合放进缓存？不常修改的数据。比如商品的分类列表数据：</p>
<p><img src="/2018/09/25/ssm/ssm-redis-solr/11.png" alt></p>
<p>但是原谅我，我只是想简单的实现以下Solr的搜索功能，真实项目中商品的分类数据肯定是存在另一张表中，由于我并没有实现，所以Redis在本项目中的应用就比较少了。</p>
<br>

<h1 id="项目截图"><a href="#项目截图" class="headerlink" title="项目截图"></a>项目截图</h1><p><img src="/2018/09/25/ssm/ssm-redis-solr/1.png" alt></p>
<p><img src="/2018/09/25/ssm/ssm-redis-solr/2.png" alt></p>
<p><img src="/2018/09/25/ssm/ssm-redis-solr/3.png" alt></p>
<p><img src="/2018/09/25/ssm/ssm-redis-solr/4.png" alt></p>
<br>

<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <tags>
        <tag>ssm</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis及Spring-Data-Redis入门学习</title>
    <url>/2018/09/24/other/redis/</url>
    <content><![CDATA[<p>继上一篇<a href="http://tycoding.cn/2018/09/24/other/solr/" target="_blank" rel="noopener">Solr和Spring Data Solr学习</a>，我们思考一个问题，使用Solr的目的是什么？肯定是为了加快服务器的相应速度。因为即使不适用Solr，通过请求数据库我们一样能完成搜索功能，但是这样会给服务器造成很大的压力。</p>
<p>而Solr仅仅是在搜索功能中用到了，但是大量请求的数据不仅仅出现在搜索中，比如用户的登录信息，虽然数据量很小，但是整个项目每刷新一次页面都要请求一次用户登录的Token信息，也会拖慢服务器的响应速度。我们通常有两中解决方式：1.数据缓存；2.网页静态化。</p>
<p>其实我们在<a href="https://github.com/TyCoding/shiro" target="_blank" rel="noopener">Shiro实现用户-角色-权限管理系统</a>中已经用到了缓存技术，今天我们了解一下Redis缓存技术。</p>
<a id="more"></a>

<h1 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h1><p>Redis是一款开源的Key-Value数据库。首先我们要去 <a href="https://redis.io/" target="_blank" rel="noopener">官网</a> 下载Redis，由于笔者使用的是MacOS系统，和Windows系统有所不同。</p>
<p>安装过程不再叙述，这里提供两个教程：</p>
<ul>
<li><p>Windows: <a href="https://blog.csdn.net/weixin_33446857/article/details/77893896" target="_blank" rel="noopener">Redis安装教程</a></p>
</li>
<li><p>MacOS&amp;Linux: <a href="https://www.cnblogs.com/feijl/p/6879929.html" target="_blank" rel="noopener">Redis安装教程</a></p>
</li>
</ul>
<br>

<h2 id="启动Redis"><a href="#启动Redis" class="headerlink" title="启动Redis"></a>启动Redis</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">redis-server </span><br><span class="line">redis-server &amp;</span><br></pre></td></tr></table></figure>

<p>建议使用第二个命令，用第二个命令启动了redis server后能继续输入命令，使用第一个命令则不行。</p>
<p>如果终端中显示如下logo表示redis启动成功：</p>
<p><img src="/2018/09/24/other/redis/1.png" alt></p>
<br>

<h2 id="操纵Redis"><a href="#操纵Redis" class="headerlink" title="操纵Redis"></a>操纵Redis</h2><p>上面仅仅是启动了Redis Server，但Redis是一种Key-Value型数据库，也包含了一些查询数据库的命令，操作redis命令的入口就是: <code>redis/bin/redis-cli</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./bin/redis-cli</span><br><span class="line"></span><br><span class="line">redis-cli</span><br></pre></td></tr></table></figure>

<p><img src="/2018/09/24/other/redis/2.png" alt></p>
<ol>
<li>查看当前(db0)数据库中所有的key值： <code>keys *</code></li>
<li>清空当前数据库中所有的数据： <code>flushall</code></li>
</ol>
<p>更多的Redis命令可以参看：<a href="http://www.redis.cn/commands.html" target="_blank" rel="noopener">redis中文文档</a></p>
<br>

<h1 id="Spring-Data-Redis"><a href="#Spring-Data-Redis" class="headerlink" title="Spring Data Redis"></a>Spring Data Redis</h1><p>之前学习Solr的时候用到了Spring Data Solr，现在学习Redis，Spring提供了Spring Data Redis用来实现通过配置文件的方式访问redis服务。Spring Data Redis对Redis底层开发包（Jedis, JRedis, and RJC）进行了高度封装，<code>RedisTemplate</code>提供了redis各种操作、异常处理及序列化。</p>
<p><strong>Jedis</strong></p>
<p>Jedis是Redis官方推出的一款面向Java的客户端，提供了很多借口供Java语言调用。</p>
<p>Spring Data Redis针对Jedis提供了如下功能：</p>
<ul>
<li>1.连接池自动管理，提供了一个高度封住的<code>RedisTemplate</code>类。</li>
<li>2.针对jedis客户端中大量api进行归类封装，将同一类型操作封装为operation接口：<pre><code>ValueOperations: 简单的K-V操作
SetOperations: set类型数据操作
ZSetOperations: zset类型数据操作
HashOperations: 针对Map类型的数据操作
ListOperations: 针对List类型的数据操作</code></pre></li>
</ul>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><h3 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">		  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">		  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">		  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">		  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">		  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">		  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="创建redis-config-properties"><a href="#创建redis-config-properties" class="headerlink" title="创建redis-config.properties"></a>创建redis-config.properties</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">redis.host=127.0.0.1 </span><br><span class="line">redis.port=6379 </span><br><span class="line">redis.pass= </span><br><span class="line">redis.database=0 </span><br><span class="line">redis.maxIdle=300 </span><br><span class="line">redis.maxWait=3000 </span><br><span class="line">redis.testOnBorrow=true</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong></p>
<ol>
<li><code>redis.host</code>是安装redis server的客户端IP地址，如果安装在本机上就是127.0.0.1，如果安装在服务器上请修改为服务器的IP地址。</li>
<li><code>redis.port</code>是redis server的默认端口，你安装了redis，就默认使用这个端口号。</li>
<li><code>redis.pass</code>是访问redis server的密码，一般我们不设置。</li>
<li><code>redis.database=0</code>代表使用的是redis默认提供的db0这个数据库。</li>
<li><code>redis-maxIdle</code>是redis server的最大空闲数。</li>
<li><code>redis-maxWait</code>是连接redis时的最大等待毫秒数。</li>
<li><code>redis-testOnBorrow</code>在提取一个redis实例时，是否提前进行验证操作；如果为true，则得到的jedis实例均是可用的。</li>
</ol>
<h2 id="创建spring-redis-xml"><a href="#创建spring-redis-xml" class="headerlink" title="创建spring-redis.xml"></a>创建spring-redis.xml</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:other/*.properties"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- redis 相关配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"poolConfig"</span> <span class="attr">class</span>=<span class="string">"redis.clients.jedis.JedisPoolConfig"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 最大空闲数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxIdle"</span> <span class="attr">value</span>=<span class="string">"$&#123;redis.maxIdle&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 连接时最大的等待时间（毫秒） --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxWaitMillis"</span> <span class="attr">value</span>=<span class="string">"$&#123;redis.maxWait&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 在提取一个jedis实例时，是否提前进行验证操作；如果为true，则得到的jedis实例均是可用的 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"testOnBorrow"</span> <span class="attr">value</span>=<span class="string">"$&#123;redis.testOnBorrow&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jedisConnectionFactory"</span> <span class="attr">class</span>=<span class="string">"org.springframework.data.redis.connection.jedis.JedisConnectionFactory"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hostName"</span> <span class="attr">value</span>=<span class="string">"$&#123;redis.host&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"port"</span> <span class="attr">value</span>=<span class="string">"$&#123;redis.port&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;redis.pass&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"poolConfig"</span> <span class="attr">ref</span>=<span class="string">"poolConfig"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"redisTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.data.redis.core.RedisTemplate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionFactory"</span> <span class="attr">ref</span>=<span class="string">"jedisConnectionFactory"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>本实例源码：<a href="https://github.com/TyCoding/ssm-redis-solr/blob/master/test/TestRedisTemplate.java" target="_blank" rel="noopener">Github</a></p>
<p>首先加载配置文件<code>spring-redis.xml</code>，注入<code>RedisTemplate</code>模板类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate redisTemplate;</span><br></pre></td></tr></table></figure>

<h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h3><p><code>RedisTemplate</code>提供的很多操作redis数据库的方法都是<code>boundxxOps</code>这种。</p>
<h4 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    redisTemplate.boundValueOps(<span class="string">"name"</span>).set(<span class="string">"tycoding"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果配置都正常的情况下，运行此方法就能向db0数据库中添加一条key为<code>name</code>的记录；那么我们在redis命令行中查看所有的key：</p>
<p><img src="/2018/09/24/other/redis/3.png" alt></p>
<p>奇怪，我添加的key明明是<code>name</code>，为什么查出来的确实一堆乱码值呢？我们再使用redis命令行单独添加一条记录：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">set testK testV</span><br></pre></td></tr></table></figure>

<p><img src="/2018/09/24/other/redis/4.png" alt></p>
<p>此时我们又发现，使用redis原生命令添加的数据是不会乱码的；那么就肯定是Spring Data Redis的原因了。经查询是因为redisTemplate模板类在操作redis序列化的原因，我们要手动配置序列化方式为：<code>StringRedisSerializer</code></p>
<p>修改之前创建的<code>spring-redis.xml</code>配置文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"redisTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.data.redis.core.RedisTemplate"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionFactory"</span> <span class="attr">ref</span>=<span class="string">"jedisConnectionFactory"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 序列化策略 推荐使用StringRedisSerializer --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"keySerializer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.data.redis.serializer.StringRedisSerializer"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"valueSerializer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.data.redis.serializer.StringRedisSerializer"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hashKeySerializer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.data.redis.serializer.JdkSerializationRedisSerializer"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hashValueSerializer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.data.redis.serializer.JdkSerializationRedisSerializer"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>再次添加数据</p>
<p><img src="/2018/09/24/other/redis/5.png" alt></p>
<h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Object name = redisTemplate.boundValueOps(<span class="string">"name"</span>).get();</span><br><span class="line">    System.out.println(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    redisTemplate.delete(<span class="string">"name"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a>Set类型</h3><h4 id="添加-1"><a href="#添加-1" class="headerlink" title="添加"></a>添加</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValueBySet</span><span class="params">()</span></span>&#123;</span><br><span class="line">    redisTemplate.boundSetOps(<span class="string">"nameset"</span>).add(<span class="string">"tycoding"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getValueBySet</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Set nameset = redisTemplate.boundSetOps(<span class="string">"nameset"</span>).members();</span><br><span class="line">    System.out.println(nameset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除Set中某一个值"><a href="#删除Set中某一个值" class="headerlink" title="删除Set中某一个值"></a>删除Set中某一个值</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteValueBySet</span><span class="params">()</span></span>&#123;</span><br><span class="line">    redisTemplate.boundSetOps(<span class="string">"nameset"</span>).remove(<span class="string">"涂陌"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除整个Set"><a href="#删除整个Set" class="headerlink" title="删除整个Set"></a>删除整个Set</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAllValueByset</span><span class="params">()</span></span>&#123;</span><br><span class="line">    redisTemplate.delete(<span class="string">"nameset"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h3><h4 id="右压栈"><a href="#右压栈" class="headerlink" title="右压栈"></a>右压栈</h4><p>右压栈，后添加的对象排在后边</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRightValueByList</span><span class="params">()</span></span>&#123;</span><br><span class="line">  redisTemplate.boundListOps(<span class="string">"namelist"</span>).rightPush(<span class="string">"tycoding"</span>);</span><br><span class="line">  redisTemplate.boundListOps(<span class="string">"namelist"</span>).rightPush(<span class="string">"涂陌"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显示右压栈集合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getRightValueByListI</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List namelist = redisTemplate.boundListOps(<span class="string">"namelist"</span>).range(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    System.out.println(namelist);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="左压栈"><a href="#左压栈" class="headerlink" title="左压栈"></a>左压栈</h4><p>左压栈，后添加的对象排在前面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeftValueByList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    redisTemplate.boundListOps(<span class="string">"namelist2"</span>).leftPush(<span class="string">"tycoding"</span>);</span><br><span class="line">    redisTemplate.boundListOps(<span class="string">"namelist2"</span>).leftPush(<span class="string">"涂陌"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显示左压栈的集合：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getLeftValueByList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List name2 = redisTemplate.boundListOps(<span class="string">"namelist2"</span>).range(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    System.out.println(name2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据索引查询集合中的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">searchByIndex</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Object namelist = redisTemplate.boundListOps(<span class="string">"namelist"</span>).index(<span class="number">1</span>);</span><br><span class="line">    System.out.println(namelist);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Hash类型"><a href="#Hash类型" class="headerlink" title="Hash类型"></a>Hash类型</h3><h4 id="添加-2"><a href="#添加-2" class="headerlink" title="添加"></a>添加</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValueByHash</span><span class="params">()</span></span>&#123;</span><br><span class="line">    redisTemplate.boundHashOps(<span class="string">"namehash"</span>).put(<span class="string">"a"</span>,<span class="string">"tycoding"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="提取所有的KEY"><a href="#提取所有的KEY" class="headerlink" title="提取所有的KEY"></a>提取所有的KEY</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getKeysByHash</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Set namehash = redisTemplate.boundHashOps(<span class="string">"namehash"</span>).keys();</span><br><span class="line">    System.out.println(namehash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="提取所有的VALUE"><a href="#提取所有的VALUE" class="headerlink" title="提取所有的VALUE"></a>提取所有的VALUE</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getValuesByHash</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List namehash = redisTemplate.boundHashOps(<span class="string">"namehash"</span>).values();</span><br><span class="line">    System.out.println(namehash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="根据KEY取值"><a href="#根据KEY取值" class="headerlink" title="根据KEY取值"></a>根据KEY取值</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getValueByHash</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Object o = redisTemplate.boundHashOps(<span class="string">"namehash"</span>).get(<span class="string">"a"</span>);</span><br><span class="line">    System.out.println(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="根据KEY移除值"><a href="#根据KEY移除值" class="headerlink" title="根据KEY移除值"></a>根据KEY移除值</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteValueByHash</span><span class="params">()</span></span>&#123;</span><br><span class="line">    redisTemplate.boundHashOps(<span class="string">"namehash"</span>).delete(<span class="string">"a"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>上面说了一大堆，没有实际的测试，着实不清楚Redis究竟效果如何，是不是真的提高了访问速度？</p>
<p>下面我们以查询数据库所有值的功能来看一下使用Redis缓存和未使用缓存直接查询数据库所用时间。</p>
<p>本例源码地址：<a href="https://github.com/TyCoding/ssm-redis-solr/blob/master/src/main/java/cn/tycoding/service/impl/GoodsServiceImpl.java" target="_blank" rel="noopener">Github</a></p>
<p><strong>未使用Redis缓存，直接请求数据库</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Goods&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> goodsMapper.findAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用了Redis缓存</strong></p>
<p>首先通过<code>boundHashOps</code>获取Redis数据库中是否存在KEY为<code>all</code>的数据，有的话就返回；没有的话就查询数据库并将查询到的数据添加到Redis数据库中，且KEY为<code>all</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Goods&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Goods&gt; contentList = (List&lt;Goods&gt;) redisTemplate.boundHashOps(<span class="string">"goods"</span>).get(<span class="string">"all"</span>);</span><br><span class="line">    <span class="keyword">if</span> (contentList == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//说明缓存中没有数据</span></span><br><span class="line">        System.out.println(<span class="string">"从数据库中读取数据放入redis..."</span>);</span><br><span class="line">        contentList = goodsMapper.findAll();</span><br><span class="line">        redisTemplate.boundHashOps(<span class="string">"goods"</span>).put(<span class="string">"all"</span>, contentList); <span class="comment">//存入redis中</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"从缓存中读取数据..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        return goodsMapper.findAll();</span></span><br><span class="line">    <span class="keyword">return</span> contentList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/TyCoding/ssm-redis-solr/blob/master/test/TestTime.java" target="_blank" rel="noopener">TestTime.java</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Long startTime = System.currentTimeMillis(); <span class="comment">//开始时间</span></span><br><span class="line">    goodsMapper.findAll();</span><br><span class="line">    Long endTime = System.currentTimeMillis(); <span class="comment">//结束时间</span></span><br><span class="line">    System.out.println(<span class="string">"查询数据库--共耗时："</span> + (endTime - startTime) + <span class="string">"毫秒"</span>); <span class="comment">//1007毫秒</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Long startTime = System.currentTimeMillis(); <span class="comment">//开始时间</span></span><br><span class="line">    goodsService.findAll();</span><br><span class="line">    Long endTime = System.currentTimeMillis(); <span class="comment">//结束时间</span></span><br><span class="line">    System.out.println(<span class="string">"从redis中读取所有数据，共耗时："</span> + (endTime - startTime) + <span class="string">"毫秒"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在测试类中调用Service层的这两个方法，得到的结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查询数据库--共耗时：1047毫秒</span><br><span class="line"></span><br><span class="line">从redis中读取所有数据，共耗时：197毫秒</span><br></pre></td></tr></table></figure>

<br>

<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Solr及Spring-Data-Solr入门学习</title>
    <url>/2018/09/24/other/solr/</url>
    <content><![CDATA[<p><strong>Solr的安装与配置</strong></p>
<p>多数搜索引擎应用都必须具有某种搜索功能，而搜索功能往往大量的消耗资源导致应用程序运行缓慢。为此，出现了各种用于构建搜索的应用程序，我们要学习的solr正是其中的一款开源搜索平台。</p>
<p>Apache Solr 是建立在Lucene(全文搜索引擎)之上，帮助我从大量的数据中寻找所需信息。不仅限于搜索，Solr也可用于储存目的。像其他NoSQL数据库一样，它是一种非关系数据储存和处理技术。</p>
<a id="more"></a>

<p>下面我们开始喜闻乐见的手摸手教学，教你优雅的整合SSM框架和Solr搜索框架。</p>
<ul>
<li>项目开源地址： <a href="https://github.com/TyCoding/ssm-redis-solr" target="_blank" rel="noopener">Github</a> </li>
</ul>
<p>项目中使用了SSM + Shiro + Redis + Solr + Vue.JS + ElementUI技术，优雅的整合了SSM框架阶段几个常见的企业框架；并用Vue.js + ElementUI写了超漂亮的前端页面；如果觉得可以，就点亮右上角star吧(#^.^#)。</p>
<p>如果你对Shiro+用户-角色-权限整合不是很懂，你或许可以看下我的这个项目： <a href="https://github.com/TyCoding/shiro" target="_blank" rel="noopener">手摸手教你SSM整合Shiro框架后的开发</a>。</p>
<p>日常学习记录，如果想支持我，希望能在Github上看到你点亮的星星(#^.^#)。</p>
<br>


<ul>
<li>本例中使用的Solr和Tomcat我已经上传到了Github，仓库地址： <a href="https://github.com/TyCoding/solr-tomcat" target="_blank" rel="noopener">Tomcat搭建Solr运行环境，集成Ik 中文分词器</a></li>
</ul>
<br>

<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>在 <a href="http://mirrors.hust.edu.cn/apache/lucene/solr/7.4.0/" target="_blank" rel="noopener">Apache Solr官网</a>  下载最新版的Solr，在 <a href="https://tomcat.apache.org/download-80.cgi" target="_blank" rel="noopener">Apache Tomcat官网</a> 下载Tomcat。</p>
<p>解压solr，发现其中有如下目录结构</p>
<p><img src="/2018/09/24/other/solr/1.png" alt></p>
<p>新版本的Solr和老版本的不同，老版本中直接提供的是war文件，新版本则是提供了直接可运行的项目；其次需要导入项目中的的文件也有所不同的。下面我们介绍一下完整的配置和Solr项目的启动：</p>
<ul>
<li>1、将<code>solr-7.4.0/server/solr-webapp/</code>下的<code>webapp</code>文件夹拷贝到Tomcat下的<code>webapps</code>目录下（并重命名为solr）。</li>
<li>2、将<code>solr-7.4.0/server/lib/ext/</code>下的所有Jar文件全部拷贝到Tomcat下<code>webapps/solr/WEB-INF/lib</code>目录下。</li>
<li>3、将<code>solr-7.4.0/server/lib</code>下所有<code>metrics</code>开头的jar文件全部拷贝到<code>webapps/solr/WEB-INF/lib</code>目录下。</li>
<li>4、将<code>solr/7.4.0/server/solr</code>文件夹复制到任意一个位置并重命名为<code>solrhome</code>。</li>
<li>5、修改<code>tomcat/webapps/solr/WEB-INF/web.xml</code>文件的第41行，指定solrhome所在的目录。</li>
</ul>
<p><img src="/2018/09/24/other/solr/2.png" alt></p>
<ul>
<li>6、在<code>webapps/solr/WEB-INF/web.xml</code>下的第125行出添加注释，也就是注释<code>&lt;security-constraint&gt;&lt;/secirity-constraint&gt;</code>节点下的配置。</li>
</ul>
<p><img src="/2018/09/24/other/solr/3.png" alt></p>
<ul>
<li>7、启动Tomcat，在浏览器中访问<code>http://localhost:8080/solr/index.html</code>即可访问到<code>solr Admin</code></li>
</ul>
<p><img src="/2018/09/24/other/solr/4.png" alt></p>
<p>如上所示，你会发现其左下角显示的是<code>No cores</code>，这和老版本的可能又有所差别，所以我们点击<code>No cores</code>，创建一个新的<code>cores</code>，那么会在我们指定的<code>solrhome</code>文件夹内产生一个<code>new_core</code>的空文件夹，并且页面会报错：<code>Can&#39;t find resource &#39;solrconfig.xml&#39; in xxx</code>，表示的就是在这个新core下的conf文件夹下没有找到solrconfig.xml文件：</p>
<p><img src="/2018/09/24/other/solr/5.png" alt></p>
<p><img src="/2018/09/24/other/solr/6.png" alt></p>
<p>我们需要将复制来的<code>configsets/_default/conf</code>这个文件夹（或者<code>solr-7.4.0/server/solr/configsets/_default/conf</code>文件夹）复制到<code>solrhome/new_core/</code>文件夹下。</p>
<ul>
<li>8、重启Tomcat服务器，发现还是没有出现新的core，点击<code>No cores</code>那里点击<code>add core</code>，此时就会完整的创建一个新的core，在<code>solrhome/new_core</code>文件夹下会生成新的文件：</li>
</ul>
<p><img src="/2018/09/24/other/solr/7.png" alt></p>
<ul>
<li>至此Solr已经安装完成。</li>
</ul>
<br>

<h1 id="中文分词器"><a href="#中文分词器" class="headerlink" title="中文分词器"></a>中文分词器</h1><p>上面我们成功的安装了solr，下面就要进行相关的配置。因为solr是一个开源的搜索平台，主要功能就是把用户输入的搜索信息分类汇总并进行数据库的查询，而中文众所周知语义比较复杂，而且中文所占的字节和英文也有所不同，所以就出现了中文分词器，实现模拟中文语义对数据进行分词衍化。IK Analyzer正是其中的一种分词器。</p>
<p>IK Analyzer在solr工程中的配置如下：</p>
<ul>
<li>1、下载ikanalyzer相关配置文件，因为Maven仓库中的ikanalyzer版本太老，solr5以上的版本都不支持，所以这里提供一个新版本： <a href="https://pan.baidu.com/s/1YtfY_Ogp2REcOxds20tlGQ" target="_blank" rel="noopener">传送门</a></li>
<li>2、将下载的jar文件copy到<code>webapps/solr/WEB-INF/lib</code>文件夹下</li>
<li>3、在<code>webapps/solr/WEB-INF/</code>下创建<code>classes</code>文件夹，将上面下载的文件夹中的<code>ext.dic</code>、<code>IKAnalyzer.cfg.xml</code>、<code>stopword.dic</code>三个文件复制到<code>webapps/solr/WEB-INF/classes/</code>文件夹下。</li>
<li>4、在<code>solrhome/conf/</code>目录下我们发现并没有schema.xml文件，这和老版本又有所不同，老版本直接生成好了schema.xml文件，在新版本中我们可以发现<code>/conf</code>文件夹中存在一个<code>managed-schema</code>文件，这个其实就是我们要的<code>schema.xml</code>文件。但是我们又不能直接用，具体原因参考 <a href="https://blog.csdn.net/jiangchao858/article/details/52518190" target="_blank" rel="noopener">博文</a></li>
<li>5、直接将<code>managed-schema</code>文件重命名为<code>schema.xml</code>。并在<code>schema.xml</code>的最后添加<code>&lt;fieldType&gt;</code>节点：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">fieldType</span> <span class="attr">name</span>=<span class="string">"text_ik"</span> <span class="attr">class</span>=<span class="string">"solr.TextField"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">analyzer</span> <span class="attr">class</span>=<span class="string">"org.wltea.analyzer.lucene.IKAnalyzer"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fieldType</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>6、重启Tomcat服务器，重新访问项目，点击<code>new_core</code>下的Schema功能，在select下拉框中输入<code>text_ik</code>如果出现刚创建的<code>text_ik</code>，说明IK中文分词器安装成功。</li>
</ul>
<p><img src="/2018/09/24/other/solr/8.png" alt></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>未使用分词器效果：</p>
<p><img src="/2018/09/24/other/solr/9.png" alt></p>
<p>使用了分词器的效果显而易见：</p>
<p><img src="/2018/09/24/other/solr/10.png" alt></p>
<br>

<h2 id="配置域"><a href="#配置域" class="headerlink" title="配置域"></a>配置域</h2><p>solr和其他NoSQL数据库一样可以实现数据存储，所以我们可以以数据库的思想想象一下solr，之前我们新创建的<code>core</code>就类似一个数据库，那么下面要配置的<code>域</code>就相当于数据库的表字段，因此要手动的去定义系统中需要的字段Field（域）。</p>
<p>通常我们创建的一种Field分别对应这一类数据，用户对同一种数据进行相同的操作。域常用的属性有：</p>
<ul>
<li>name: 指定域的名称</li>
<li>type: 指定域的类型</li>
<li>indexed: 是否索引</li>
<li>stored: 是否储存</li>
<li>required: 是否必须</li>
<li>multiValued: 是否多值</li>
</ul>
<h3 id="域的介绍"><a href="#域的介绍" class="headerlink" title="域的介绍"></a>域的介绍</h3><p>如上面的介绍，<code>域</code>类似数据库中的表字段，而我们做项目时数据库的字段都是根据项目需求创建的，所以<code>域</code>也是如此，它是根据搜索平台需要搜索的信息对应的数据库表字段来创建的。</p>
<p>比如，在淘宝商城购买商品，我们可能会搜索：1、品牌（对应数据库中<code>brand</code>字段）；2、价格（对应数据库中<code>price</code>字段）；3、商品介绍名称（对应数据库中<code>title</code>字段）等等…</p>
<p>每一中域（字段）都用<code>&lt;field&gt;</code>字段设定，比如如上的搜索数据，我们可以设置为：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"item_title"</span> <span class="attr">type</span>=<span class="string">"text_ik"</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">stored</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"item_price"</span> <span class="attr">type</span>=<span class="string">"pdouble"</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">stored</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"item_image"</span> <span class="attr">type</span>=<span class="string">"string"</span> <span class="attr">indexed</span>=<span class="string">"false"</span> <span class="attr">stored</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"item_category"</span> <span class="attr">type</span>=<span class="string">"string"</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">stored</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"item_seller"</span> <span class="attr">type</span>=<span class="string">"text_ik"</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">stored</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"item_brand"</span> <span class="attr">type</span>=<span class="string">"string"</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">stored</span>=<span class="string">"true"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>在新版本的solr中，<code>type</code>属性不能单单设置为基本的数据类型名称了，具体用法要参考<code>schema.xml</code>文件中之前已存在的配置，例如：long要写成plong，double要写为pdouble，不然就会报错。</p>
<p>注意：</p>
<ul>
<li><p>你会奇怪域的设定不就是根据用户搜索的数据分类来设定的吗，那为何还要指定indexed=”true”，原因：可能有些数据是不是用户输入的查询的，但是还是需要在用户搜索的同时检索出来。</p>
</li>
<li><p>你会奇怪为何要设定stored，原因：大多数域都是要进行存储的，但是也有不需要存储的，比如复制域。</p>
</li>
</ul>
<h4 id="复制域"><a href="#复制域" class="headerlink" title="复制域"></a>复制域</h4><p>复制域的作用在于将某一个Field中的数据复制到另一个域中。<br>由于用户输入的数据可能是查询的价格，也可能是商品的title，又或者是商品的品牌等… 我们无法预测用户要查询的是什么，由此出现了搜索引擎平台，帮助我们对查询数据进行分类。<br>所以，solr的目标是实现两种不同的域可以在同一个域中查询（发送一次请求），而<code>复制域</code>的出现正可解决这一问题。</p>
<p>如此，我们为上面要查询的字段设定复制域：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"item_keywords"</span> <span class="attr">type</span>=<span class="string">"text_ik"</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">stored</span>=<span class="string">"false"</span> <span class="attr">multiValued</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">copyField</span> <span class="attr">source</span>=<span class="string">"item_title"</span> <span class="attr">dest</span>=<span class="string">"item_keywords"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">copyField</span> <span class="attr">source</span>=<span class="string">"item_category"</span> <span class="attr">dest</span>=<span class="string">"item_keywords"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">copyField</span> <span class="attr">source</span>=<span class="string">"item_seller"</span> <span class="attr">dest</span>=<span class="string">"item_keywords"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中的<code>source</code>属性值要和<code>&lt;field&gt;</code>中的<code>name</code>保持一致。</p>
<h4 id="动态域"><a href="#动态域" class="headerlink" title="动态域"></a>动态域</h4><p>在项目中，商品的数据可能会动态的添加或减少，比如原来没有的数据，但是后来又完善添加上去了，那么就需要动态的配置从而实现用户能及时查询到。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dynamicField</span> <span class="attr">name</span>=<span class="string">"item_conf_*"</span> <span class="attr">type</span>=<span class="string">"string"</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">stored</span>=<span class="string">"true"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<br>

<h1 id="Spring-Data-Solr入门"><a href="#Spring-Data-Solr入门" class="headerlink" title="Spring Data Solr入门"></a>Spring Data Solr入门</h1><p>经过上面的安装和配置大家应该已经知道如何配置Solr，那么就会思考一个问题了：这个solr项目和我们实际的项目查询有什么关系呢？是怎么结合的呢？</p>
<p>solr官方提供了<code>solrj API</code>，就是一个jar文件，我们可以通过solr官方提供的接口来实现本地项目和solr项目的交互；而这里我们要介绍的是Spring Data Solr，它是Spring Data家族对solrj进行封装后的框架。</p>
<ul>
<li>注意<br>上面我们在Tomcat中部署的solr项目是不需要再进行位置上的变动的，也就是他必须是已经在Tomcat中部署好的，而我们自己的项目启动时不能再使用8080端口（因为solr本身就占用了Tomcat的端口，而我们的项目是可以改变运行端口的，总之两者无论是不是在同一个Tomcat服务器中部署都不能使用同一端口）。我们通过配置文件就能访问到这个指定端口的solr项目（Tomcat必须是启动着的），通过Spring Data Solr提供的接口就能实现交互：<br>所谓交互 –&gt; 等价于查询solr中以存在的数据，然后将结果返回： <ul>
<li>用户查询，请求接口将查询条件交给solr（通过Spring Data Solr提供的接口访问Solr服务），solr对自身已存在的数据进行查找</li>
</ul>
</li>
</ul>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><h3 id="导入jar文件"><a href="#导入jar文件" class="headerlink" title="导入jar文件"></a>导入jar文件</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-solr<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h3><p>既然是Spring家族的框架，当然要进行配置使用了，创建<code>spring-solr.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:solr</span>=<span class="string">"http://www.springframework.org/schema/data/solr"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/data/solr</span></span></span><br><span class="line"><span class="tag"><span class="string">  		http://www.springframework.org/schema/data/solr/spring-solr-1.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- solr服务器地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">solr:solr-server</span> <span class="attr">id</span>=<span class="string">"solrServer"</span> <span class="attr">url</span>=<span class="string">"http://127.0.0.1:8080/solr/new_core"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- solr模板，使用solr模板可对索引库进行CRUD的操作 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"solrTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.data.solr.core.SolrTemplate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"solrServer"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注意：</li>
</ul>
<p>一定要注意solr配置中solr服务器地址的配置，这个<code>url</code>一定是<code>solr项目访问地址</code> + <code>/core</code>实例名称组合的路径。一般我们新建的core实例名称就是<code>new_core</code>。</p>
<h3 id="为实体类属性添加-Field注解"><a href="#为实体类属性添加-Field注解" class="headerlink" title="为实体类属性添加@Field注解"></a>为实体类属性添加@Field注解</h3><p>上面完成了基本的环境配置，下面则需要为实体类中属性添加<code>@Field</code>注解标识。</p>
<p>一般我们定义的实体类属性名称和数据库的字段名称相似，但是，如果使用了Solr搜索，每次查询数据将不再查询数据库，那么Solr怎么获取到你要查询的是商品的title还是price呢？</p>
<p>这里就需要使用<code>@Field</code>注解，保证实体类属性名称和Solr索引库中定义的<code>Field</code>域名称对应，如果当前属性名称和Solr索引库域Field名称相同，就添加<code>@Field</code>名称，如果不相同就添加<code>@Field(&quot;域名称&quot;)</code>注解。</p>
<p>这里我们这样定义实体类 <a href="https://github.com/TyCoding/ssm-redis-solr/blob/master/src/main/java/cn/tycoding/entity/Goods.java" target="_blank" rel="noopener">Goods</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Goods</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Field</span></span><br><span class="line">    <span class="keyword">private</span> Long id; <span class="comment">//商品ID</span></span><br><span class="line">    <span class="meta">@Field</span>(<span class="string">"item_title"</span>)</span><br><span class="line">    <span class="keyword">private</span> String title; <span class="comment">//商品标题</span></span><br><span class="line">    <span class="meta">@Field</span>(<span class="string">"item_price"</span>)</span><br><span class="line">    <span class="keyword">private</span> String price; <span class="comment">//商品价格</span></span><br><span class="line">    <span class="meta">@Field</span>(<span class="string">"item_image"</span>)</span><br><span class="line">    <span class="keyword">private</span> String image; <span class="comment">//商品图片</span></span><br><span class="line">    <span class="meta">@Field</span>(<span class="string">"item_category"</span>)</span><br><span class="line">    <span class="keyword">private</span> String category; <span class="comment">//商品类别</span></span><br><span class="line">    <span class="meta">@Field</span>(<span class="string">"item_brand"</span>)</span><br><span class="line">    <span class="keyword">private</span> String brand; <span class="comment">//商品品牌</span></span><br><span class="line">    <span class="meta">@Field</span>(<span class="string">"item_seller"</span>)</span><br><span class="line">    <span class="keyword">private</span> String seller; <span class="comment">//商品卖家</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意：温馨提示一下，大家创建实体类的时候尽量养成一个习惯：实现Serializable序列化接口。不序列化迟早会遇到问题。</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>本例详细代码请参看: <a href="https://github.com/TyCoding/ssm-redis-solr/blob/master/test/TestSolrTemplate.java" target="_blank" rel="noopener">Github</a></p>
<ol>
<li><p>由于我们创建的是测试类，需要使用<code>@RunWith</code>和<code>@ContextConfiguration</code>注解加载配置文件。</p>
</li>
<li><p>在测试类中用注入Spring Data Solr操作Solr索引库的核心类<code>SolrTemplate</code></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> SolrTemplate solrTemplate;</span><br></pre></td></tr></table></figure>

<h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAdd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Goods goods = <span class="keyword">new</span> Goods(<span class="number">1L</span>, <span class="string">"IPhone SE"</span>, <span class="string">"120"</span>, <span class="string">"手机"</span>, <span class="string">"Apple"</span>, <span class="string">"Apple"</span>);</span><br><span class="line">    solrTemplate.saveBean(goods);</span><br><span class="line">    solrTemplate.commit(); <span class="comment">//提交</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现数据的添加：</p>
<ol>
<li>实例化一个实体类，并添加数据。</li>
<li>调用<code>solrTemplate</code>的<code>saveBean()</code>方法；这个<code>saveBean()</code>是用来添加普通对象类型数据到Solr索引库的，如果是List集合这种类型，使用<code>saveBeans()</code>方法。</li>
<li>调用<code>solrTemplate</code>的<code>commit()</code>方法，提交更改；类似于我们请求数据库时需要关闭连接一样，必须调用<code>commit()</code>方法才能保存修改。</li>
</ol>
<h3 id="按主键查询"><a href="#按主键查询" class="headerlink" title="按主键查询"></a>按主键查询</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindById</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Goods goods = solrTemplate.getById(<span class="number">1</span>, Goods.class);</span><br><span class="line">    System.out.println(<span class="string">"--------"</span> + goods.getTitle());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="按主键删除"><a href="#按主键删除" class="headerlink" title="按主键删除"></a>按主键删除</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDeleteById</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    solrTemplate.deleteById(<span class="string">"1"</span>);</span><br><span class="line">    solrTemplate.commit(); <span class="comment">//提交</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="批量插入数据"><a href="#批量插入数据" class="headerlink" title="批量插入数据"></a>批量插入数据</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAddList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Goods&gt; list = <span class="keyword">new</span> ArrayList&lt;Goods&gt;();</span><br><span class="line">    <span class="comment">//循环插入100条数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        Goods goods = <span class="keyword">new</span> Goods(i + <span class="number">1L</span>, <span class="string">"华为Mate"</span> + i, String.valueOf(<span class="number">2000</span> + i), <span class="string">"手机"</span>, <span class="string">"手机"</span>, <span class="string">"华为专卖店"</span>);</span><br><span class="line">        list.add(goods);</span><br><span class="line">    &#125;</span><br><span class="line">    solrTemplate.saveBeans(list); <span class="comment">//添加集合对象，调用saveBeans()；添加普通对象类型数据，使用saveBean();</span></span><br><span class="line">    solrTemplate.commit(); <span class="comment">//提交</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPageQuery</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Query query = <span class="keyword">new</span> SimpleQuery(<span class="string">"*:*"</span>);</span><br><span class="line">    query.setOffset(<span class="number">20</span>); <span class="comment">//开始索引（默认0）</span></span><br><span class="line">    query.setRows(<span class="number">20</span>); <span class="comment">//每页记录数（默认10）</span></span><br><span class="line">    ScoredPage&lt;Goods&gt; page = solrTemplate.queryForPage(query, Goods.class);</span><br><span class="line">    System.out.println(<span class="string">"总记录数："</span> + page.getTotalElements());</span><br><span class="line">    List&lt;Goods&gt; list = page.getContent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面使用<code>new SimpleQuery</code>方式是声明一个Query实例，而<code>(&quot;*:*&quot;)</code>表示查询Solr索引库中的所有数据。Solr默认查询的数据是前十条记录，也就是即便使用了<code>(&quot;*:*&quot;)</code>查询，也仅仅是查询到十条记录。<br>不过Solr提供了分页查询的方法：<code>setOffset()</code>设置开始索引位置，<code>setRows()</code>设置结束索引位置（默认10）；调用<code>solrTemplate.queryForPage(query, clazz)</code>即是分页查询。</p>
<p>分页查询到的结果存储在<code>page</code>对象中，使用<code>page.getTotalElements()</code>可以获取到查询的总记录数，使用<code>page.getContent()</code>获取到查询的数据。</p>
<h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPageQueryMutil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Query query = <span class="keyword">new</span> SimpleQuery(<span class="string">"*:*"</span>);</span><br><span class="line">    Criteria criteria = <span class="keyword">new</span> Criteria(<span class="string">"item_title"</span>).contains(<span class="string">"2"</span>);</span><br><span class="line">    criteria = criteria.and(<span class="string">"item_title"</span>).contains(<span class="string">"5"</span>);</span><br><span class="line">    query.addCriteria(criteria);</span><br><span class="line"></span><br><span class="line">    ScoredPage&lt;Goods&gt; page = solrTemplate.queryForPage(query, Goods.class);</span><br><span class="line">    System.out.println(<span class="string">"总记录数："</span> + page.getTotalElements());</span><br><span class="line">    List&lt;Goods&gt; list = page.getContent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，使用分页插件需要实例化<code>Criteria</code>类添加查询条件，查询是根据<code>schema.xml</code>中定义的<code>Field</code>域名称查询的，相当于根据数据库的字段名称查询一样。</p>
<h3 id="删除所有"><a href="#删除所有" class="headerlink" title="删除所有"></a>删除所有</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Query query = <span class="keyword">new</span> SimpleQuery(<span class="string">"*:*"</span>);</span><br><span class="line">    solrTemplate.delete(query);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <tags>
        <tag>solr</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM框架整合Shiro后的开发</title>
    <url>/2018/09/18/ssm/shiro/ssm-shiro/</url>
    <content><![CDATA[<p><strong>手摸手教你SSM框架整合Shiro后的开发</strong></p>
<p>前面，我们学习了<a href="http://tycoding.cn/2018/09/15/ssm/shiro/shiro-database/" target="_blank" rel="noopener">Shiro实现权限管理之表结构设计</a>以及<a href="http://tycoding.cn/2018/09/17/ssm/ztree/" target="_blank" rel="noopener">JQuery-Ztree.js使用范例</a> ，接下来就详细介绍一下SSM框架整合Shiro框架后的开发。同样推荐大家参看张开涛老师的 <a href="http://jinnianshilongnian.iteye.com/blog/2049092" target="_blank" rel="noopener">跟我学Shiro</a> ，或者可以看我的笔记：<a href="http://tycoding.cn/2018/07/08/ssm/shiro/shiro-3/#more" target="_blank" rel="noopener">Shiro实现授权</a>、<a href="http://tycoding.cn/2018/07/07/ssm/shiro/shiro-2/#more" target="_blank" rel="noopener">Shiro实现身份认证</a>。</p>
<p>如果你对SSM框架的整合不是很熟悉，你或许可以参看我的这个项目<a href="https://github.com/TyCoding/ssm" target="_blank" rel="noopener">SSM框架整合</a>。</p>
<p>下面我们就开始实现一个SSM+Shiro的权限管理项目吧！</p>
<p><strong>开源项目地址</strong> 请看我的Github仓库: <a href="https://github.com/TyCoding/shiro" target="_blank" rel="noopener">SSM框架整合Shiro后的开发</a></p>
<a id="more"></a>

<p><strong>测试环境</strong></p>
<blockquote>
<p>IDEA + Tomcat8 + Maven</p>
</blockquote>
<h1 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h1><p>初始化数据库，请参考<a href="https://github.com/TyCoding/shiro/tree/master/db" target="_blank" rel="noopener">/db</a>中的代码</p>
<h2 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h2><p>导入Shiro框架需要的依赖：</p>
<blockquote>
<p>shiro-core-1.3.2.jar<br>shiro-ehcache-1.3.2.jar<br>shiro-quartz-1.3.2.jar<br>shiro-spring-1.3.2.jar<br>shiro-web-1.3.2.jar</p>
</blockquote>
<p>其他依赖请参看项目中的<a href="https://github.com/TyCoding/shiro/blob/master/pom.xml" target="_blank" rel="noopener">pom.xml</a> 文件</p>
<h2 id="搭建SSM框架"><a href="#搭建SSM框架" class="headerlink" title="搭建SSM框架"></a>搭建SSM框架</h2><p>搭建SSM框架的过程这里不再详细说了，可以参看我的<a href="https://github.com/TyCoding/ssm" target="_blank" rel="noopener">SSM框架整合案例</a></p>
<br>

<h1 id="SSM框架整合Shiro"><a href="#SSM框架整合Shiro" class="headerlink" title="SSM框架整合Shiro"></a>SSM框架整合Shiro</h1><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="1-在web-xml中配置Shiro的过滤器"><a href="#1-在web-xml中配置Shiro的过滤器" class="headerlink" title="1.在web.xml中配置Shiro的过滤器"></a>1.在web.xml中配置Shiro的过滤器</h3><p>与Spring集成：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>shiroFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">async-supported</span>&gt;</span>true<span class="tag">&lt;/<span class="name">async-supported</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>targetFilterLifecycle<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>shiroFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>和SpringMVC框架类似，Shiro框架也需要在web.xml中配置一个过滤器。<code>DelegatingFilterProxy</code>会自动到Spring容器中name为<code>shiroFilter</code>的bean，并且将所有Filter的操作都委托给他管理。</p>
<p>这就要求在Spring配置中必须注入这样一个这样的Bean：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"shiroFilter"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.spring.web.ShiroFilterFactoryBean"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>此处bean的<code>id</code>和<code>web.xml</code>中Shiro过滤器的名称<code>&lt;filter-name&gt;</code>必须是相同的，否则Shiro会找不到这个Bean。</p>
<h3 id="2-spring-shiro-web-xml"><a href="#2-spring-shiro-web-xml" class="headerlink" title="2.spring-shiro-web.xml"></a>2.spring-shiro-web.xml</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:util</span>=<span class="string">"http://www.springframework.org/schema/util"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Shiro的Web过滤器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"shiroFilter"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.spring.web.ShiroFilterFactoryBean"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Shiro的安全管理器，所有关于安全的操作都会经过SecurityManager --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"securityManager"</span> <span class="attr">ref</span>=<span class="string">"securityManager"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 系统认证提交地址，如果用户退出即session丢失就会访问这个页面 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"loginUrl"</span> <span class="attr">value</span>=<span class="string">"/login.jsp"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 权限验证失败跳转的页面，需要配合Spring的ExceptionHandler异常处理机制使用 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"unauthorizedUrl"</span> <span class="attr">value</span>=<span class="string">"/unauthorized.jsp"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"filters"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">util:map</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"authc"</span> <span class="attr">value-ref</span>=<span class="string">"formAuthenticationFilter"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">util:map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 自定义的过滤器链，从上向下执行，一般将`/**`放到最下面 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"filterChainDefinitions"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 静态资源不拦截 --&gt;</span></span><br><span class="line">                /static/** = anon</span><br><span class="line">                /lib/** = anon</span><br><span class="line">                /js/** = anon</span><br><span class="line"></span><br><span class="line">                <span class="comment">&lt;!-- 登录页面不拦截 --&gt;</span></span><br><span class="line">                /login.jsp = anon</span><br><span class="line">                /login.do = anon</span><br><span class="line"></span><br><span class="line">                <span class="comment">&lt;!-- Shiro提供了退出登录的配置`logout`，会生成路径为`/logout`的请求地址，访问这个地址即会退出当前账户并清空缓存 --&gt;</span></span><br><span class="line">                /logout = logout</span><br><span class="line"></span><br><span class="line">                <span class="comment">&lt;!-- user表示身份通过或通过记住我通过的用户都能访问系统 --&gt;</span></span><br><span class="line">                /index.jsp = user</span><br><span class="line"></span><br><span class="line">                <span class="comment">&lt;!-- `/**`表示所有请求，表示访问该地址的用户是身份验证通过或RememberMe登录的都可以 --&gt;</span></span><br><span class="line">                /** = user</span><br><span class="line">            <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 基于Form表单的身份验证过滤器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"formAuthenticationFilter"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.web.filter.authc.FormAuthenticationFilter"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"usernameParam"</span> <span class="attr">value</span>=<span class="string">"username"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"passwordParam"</span> <span class="attr">value</span>=<span class="string">"password"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"loginUrl"</span> <span class="attr">value</span>=<span class="string">"/login.jsp"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 安全管理器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"securityManager"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.web.mgt.DefaultWebSecurityManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"realm"</span> <span class="attr">ref</span>=<span class="string">"userRealm"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Realm实现 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userRealm"</span> <span class="attr">class</span>=<span class="string">"cn.tycoding.realm.UserRealm"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面配置文件的核心处就是Shiro的web过滤器的配置，当然因为Shiro的所有涉及安全的操作都要经过<code>DefaultWebSecurityManager</code>安全管理器，所以<code>shiroFilter</code>首先就要将其交给<code>SecurityManager</code>管理。<code>loginUrl</code>是账户退出或者session丢失就跳转的地址；<code>unauthorizedUrl</code>是账户权限验证失败跳转的地址，比如账户权限不够等；然后就是过滤器链<code>filterChainDefinitions</code>的配置，他和我们之前配置的<code>.ini</code>文件非常相似，其中主要就是配置资源的的拦截。Shiro提供了很多默认的拦截器，比如什么验证，授权等，这里举例几个比较常用的默认拦截器：</p>
<style>
table th:first-of-type {
    width: 100px;
}
</style>

<table>
<thead>
<tr>
<th>默认拦截器名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>authc</td>
<td>基于表单的拦截器，比如若用户没有登录就会跳转到<code>loginUrl</code>的地址，其拦截的请求必须是通过登录验证的，即<code>Subject.isAuthenticated() == true</code>的账户才能访问</td>
</tr>
<tr>
<td>anon</td>
<td>匿名拦截器，和<code>authc</code>拦截器刚好作用相反。<code>anon</code>配置的请求允许用户为登录就等访问，一般我们配置登录页面和静态CSS等资源是允许匿名访问</td>
</tr>
<tr>
<td>logout</td>
<td>退出拦截器，Shiro提供了一个退出的功能，配置了<code>/logout = logout</code>，Shiro就会生成一个虚拟的映射路径，当用户访问了这个路径，Shiro会自动清空缓存并跳转到<code>loginUrl</code>页面</td>
</tr>
<tr>
<td>user</td>
<td>用户拦截器，和<code>authc</code>拦截器很类似，都是账户为登录的进行拦截并跳转到<code>loginUrl</code>地址；不同之处在于<code>authc</code>允许账户必须是通过<code>Subject.siAuthenticated() ==true</code>的；而<code>user</code>不仅允许登录账户访问，通过rememberMe登录的用户也能访问</td>
</tr>
</tbody></table>
<h2 id="Shiro实现身份认证"><a href="#Shiro实现身份认证" class="headerlink" title="Shiro实现身份认证"></a>Shiro实现身份认证</h2><p><strong>身份认证的流程</strong></p>
<p>如果用户为登录，将跳转到<code>loginUrl</code>进行登录，登录表单中，包含了两个主要参数：用户名<code>username</code>、密码<code>password</code>（这两个参数名称不是固定的，但是要和<code>FormAuthenticationFilter</code>表单过滤器的参数配置要对应）。</p>
<ol>
<li>用户输入这两个用户名和密码后提交表单，通过绑定了SecurityManager的SecurityUtils得到Subject实例，然后获取身份验证的<code>UsernamePasswordToken</code>传入用户名和密码。</li>
<li>调用<code>subject.login(token)</code>进行登录，SecurityManager会委托<code>Authenticator</code>把相应的token传给Realm，从Realm中获取身份认证信息。</li>
<li>Realm可以是自己实现的Realm，Realm会根据传入的用户名和密码去数据库进行校验（提供Service层登录接口）。</li>
<li>Shiro从Realm中获取安全数据（如用户、身份、权限等），如果校验失败，就会抛出异常，登录失败；否则就登录成功。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/login"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            @RequestParam(value = <span class="string">"username"</span>, required = <span class="keyword">false</span>)</span> String username,</span></span><br><span class="line"><span class="function">            @<span class="title">RequestParam</span><span class="params">(value = <span class="string">"password"</span>, required = <span class="keyword">false</span>)</span> String password,</span></span><br><span class="line"><span class="function">            Model model) </span>&#123;</span><br><span class="line">        String error = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (username != <span class="keyword">null</span> &amp;&amp; password != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//初始化</span></span><br><span class="line">            Subject subject = SecurityUtils.getSubject();</span><br><span class="line">            UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(username, password);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//登录，即身份校验，由通过Spring注入的UserRealm会自动校验输入的用户名和密码在数据库中是否有对应的值</span></span><br><span class="line">                subject.login(token);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"redirect:index.do"</span>;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                error = <span class="string">"未知错误，错误信息："</span> + e.getMessage();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            error = <span class="string">"请输入用户名和密码"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//登录失败，跳转到login页面，这里不做登录成功的处理，由</span></span><br><span class="line">        model.addAttribute(<span class="string">"error"</span>, error);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"login"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>拓展</strong></p>
<p>如上，当<code>login()</code>映射方法得到用户输入的用户名和密码后调用<code>subject.login(token)</code>进行登录，随后就是通过Realm进行登录校验，如果登录失败就可能抛出一系列异常，比如<code>UnknownAccountException</code>用户账户不存在异常、<code>IncorrectCredentialsException</code>用户名或密码错误异常、<code>LockedAccountException</code>账户锁定异常… 。</p>
<p>可能，你也看到有些示例中在Controller层中没有处理登录成功，而是在<code>ShiroFilterFactoryBean</code>中配置<code>successUrl</code>，很多博文中讲到：如果登录成功Shiro会自动跳转到登录前访问的地址，如果找不到登录前访问的地址，就会跳转到<code>successUrl</code>中配置的地址；But，我在测试中并没有看到这种特性，大家可以研究一波。</p>
<h3 id="认证相关的拦截器"><a href="#认证相关的拦截器" class="headerlink" title="认证相关的拦截器"></a>认证相关的拦截器</h3><p>与登录认证相关的拦截器在前面<code>spring-shiro-web</code>配置文件中已经讲到了。主要是使用Shiro提供的默认拦截器配置请求资源资源的拦截和验证，如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 静态资源不拦截 --&gt;</span></span><br><span class="line">/static/** = anon</span><br><span class="line">/lib/** = anon</span><br><span class="line">/js/** = anon</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 登录页面不拦截 --&gt;</span></span><br><span class="line">/login.jsp = anon</span><br><span class="line">/login.do = anon</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>运行项目，如果用户没有输入用户名和密码或者输入的用户名或密码有误等，将会抛出异常并重新跳转到<code>loginUrl</code>地址上，如果正确输入用户名和密码（数据库中存在的）将跳转到系统首页<code>index.do</code>。那么：我们在Controller仅仅调用了<code>subject.login(token)</code>，Shiro是怎样进行登录验证的呢？</p>
<p>那我们就要分析一下自定义的Realm了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 权限校验</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span> </span>&#123;</span><br><span class="line">        SimpleAuthorizationInfo authorizationInfo = <span class="keyword">new</span> SimpleAuthorizationInfo();</span><br><span class="line">        <span class="keyword">return</span> authorizationInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 身份校验</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        String username = (String) token.getPrincipal();</span><br><span class="line">        User user = userService.findByName(username);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnknownAccountException(); <span class="comment">//没有找到账号</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Boolean.TRUE.equals(user.getLocked())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LockedAccountException(); <span class="comment">//账号锁定</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//交给AuthenticationRealm使用CredentialsMatcher进行密码匹配</span></span><br><span class="line">        SimpleAuthenticationInfo authenticationInfo = <span class="keyword">new</span> SimpleAuthenticationInfo(</span><br><span class="line">                user.getUsername(), <span class="comment">//用户名</span></span><br><span class="line">                user.getPassword(), <span class="comment">//密码</span></span><br><span class="line">                getName() <span class="comment">//realm name</span></span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> authenticationInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Shiro从Realm中获取安全数据，我们可以自定义多个Realm实现，但都要在SecurityManager中定义。一般我们自定义实现的Realm继承AuthorizingRealm（授权）即可，它继承了AuthenticatingRealm（身份验证）；所以自定义Realm一般存在两个最主要的功能：1.身份验证；2.权限校验。</p>
<p>在用户登录后，Controller会接收到用户输入的用户名和密码，并调用<code>subject.login(token)</code>进行登录，实际上SecurityManager会委托<code>Authenticator</code>调用自定义的Realm进行身份验证。要知道，调用Realm传入的并不直接是用户名和密码，而是在Controller中绑定了用户名和密码的Token对象，那么你首先要清楚身份验证中两个重要的参数：</p>
<style>
table th:first-of-type {
    width: 100px;
}
</style>

<table>
<thead>
<tr>
<th>属性名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>principals</td>
<td>身份，主体的唯一标识，比如用户名、邮箱等，如果你将用户名和密码传给了Token对象，那么在Token对象中就能<code>getPrincipal</code>获取这个标识</td>
</tr>
<tr>
<td>credentials</td>
<td>证明、凭证。比如密码、数字证书等。但是在Shiro等安全框架中，类似于密码这种数据一般都是经过加密处理的，它肯能不单单是密码的数据，后面讲</td>
</tr>
</tbody></table>
<p>了解了上述两个参数后，下面自然是从token对象中调用<code>token.getPrincipal()</code>获取用户名，然后调用Service层方法根据这个用户名查询数据库中是否存在一个密码与其对应，根据返回的User对象，最后通过Shiro提供的<code>SimpleAuthenticationInfo</code>进行密码匹配。<code>SimpleAuthenticationInfo</code>存在多个构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SimpleAuthenticationInfo</span><span class="params">(Object principal, Object credentials, String realmName)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SimpleAuthenticationInfo</span><span class="params">(Object principal, Object hashedCredentials, ByteSource credentialsSalt, String realmName)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SimpleAuthenticationInfo</span><span class="params">(PrincipalCollection principals, Object credentials)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SimpleAuthenticationInfo</span><span class="params">(PrincipalCollection principals, Object hashedCredentials, ByteSource credentialsSalt)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><code>SimpleAuthenticationInfo</code>类提供了多个构造方法，但是一般而言我们的密码是经过加密的（后面讲）；如此Shiro会自动根据token中的用户名和密码与从数据库中查询到的数据进行匹配，如果匹配成功就登录成功，否者就抛出异常。</p>
<h3 id="注销（退出）"><a href="#注销（退出）" class="headerlink" title="注销（退出）"></a>注销（退出）</h3><p>注销登录就简单很多了，在以前我们都是手动写一个请求映射方法，当用户调用这个请求的时候，手动清空Session，但是在Shiro中，这些步骤都省略了，我们只需要在配置文件Shiro的过滤器<code>shiroFilter</code>中过滤器链<code>filterChainDefinitions</code>中的<code>&lt;value&gt;</code>标签中配置这一行：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">/logout = logout</span><br></pre></td></tr></table></figure>

<p>即可。Shiro会根据这个配置生成一个虚拟的请求映射路径，当用户请求<code>localhost:8080/logout</code>这个接口的时候，Shiro会自动清空Session，并跳转到<code>loginUrl</code>指定的地址。</p>
<h2 id="Shiro实现密码加密和解密"><a href="#Shiro实现密码加密和解密" class="headerlink" title="Shiro实现密码加密和解密"></a>Shiro实现密码加密和解密</h2><p>常见的加密方式有很多，这里我们介绍Shiro中提供的一套散列算法加密方式。散列算法，是一种不可逆的算法（自然是要不可逆的，因为可逆的算法破解起来也很容易，所以不可逆的算法更安全），常见的散列算法如MD5，、SHA，但是我们再网上看到很多破解MD5加密的网站，不是说散列算法是不可逆的吗？为什么还存在那么多破解密码的网站？其实散列算法确实是不可逆的，即使是常见的MD5加密也是不可逆的加密方式，而网上的破解网站并不是能够逆向算出这个加密密码，而是通过大数据的方式得出来的，相当于，MD5解密的网站中存在一个很大的数据库，里面存放了用户常见的加密密码，然后当用户再用此密码解密时，再从数据库中比对加密后的MD5密码，如果存在就能得到原密码了。为了避免这种情况，引入了盐<code>salt</code>的概念，如果能通过大数据的方式破解MD5的加密，但如果在加密的密码中再添加一组数据进行混淆，破解起来就相当难了，因为添加的<code>salt</code>只有我们自己知道是什么。</p>
<p>自定义一套散列算法：</p>
<ol>
<li>实例化一个RandomNumberGenerator对象生成随机数，可以用来设置盐值。</li>
<li>设定散列算法的名称和散列迭代次数。</li>
<li>调用<code>SimpleHash()</code>构造方法，将算法名称、用户输入的密码、盐值、迭代次数传入。</li>
<li>通过<code>SimpleHash()</code>构造方法，Shiro能自动帮我们对密码进行加密，并调用实体类对象的<code>setter</code>方法将密码设置进去。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PasswordHelper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实例化RandomNumberGenerator对象，用于生成一个随机数</span></span><br><span class="line">    <span class="keyword">private</span> RandomNumberGenerator randomNumberGenerator = <span class="keyword">new</span> SecureRandomNumberGenerator();</span><br><span class="line">    <span class="comment">//散列算法名称</span></span><br><span class="line">    <span class="keyword">private</span> String algorithName = <span class="string">"MD5"</span>;</span><br><span class="line">    <span class="comment">//散列迭代次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hashInterations = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//加密算法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encryptPassword</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (user.getPassword() != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//对user对象设置盐：salt；这个盐值是randomNumberGenerator生成的随机数，所以盐值并不需要我们指定</span></span><br><span class="line">            user.setSalt(randomNumberGenerator.nextBytes().toHex());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//调用SimpleHash指定散列算法参数：1、算法名称；2、用户输入的密码；3、盐值（随机生成的）；4、迭代次数</span></span><br><span class="line">            String newPassword = <span class="keyword">new</span> SimpleHash(</span><br><span class="line">                    algorithName,</span><br><span class="line">                    user.getPassword(),</span><br><span class="line">                    ByteSource.Util.bytes(user.getCredentialsSalt()),</span><br><span class="line">                    hashInterations).toHex();</span><br><span class="line">            user.setPassword(newPassword);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getter/setter ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，在<code>encryptPassword</code>中进行了核心的密码加密过程，我们只需要调用<code>SimpleHash()</code>传入需要加密的参数即可，但是在这里你应该会注意到两个地方：<code>user.setSalt()</code>和<code>user.getCredentialsSalt()</code>。
其实，在实体类中我们的确定义了一个属性<code>private String salt;</code>，这里调用的<code>setSalt()</code>正是向其中设置<code>RandomNumberGenerator</code>生成的随机数作为盐值；但是又矛盾了，为什么还存在一个<code>getCredentialsSalt()</code>方法？</p>
<p>那么我们看一下<code>SimpleHash</code>的构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SimpleHash</span><span class="params">(String algorithmName, Object source, Object salt, <span class="keyword">int</span> hashIterations)</span> <span class="keyword">throws</span> CodecException, UnknownAlgorithmException </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>其中也需要一个参数<code>salt</code>。但是，要注意此salt非彼salt；我们先看一下User实体类中定义的<code>getCredentialsSalt()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String salt; <span class="comment">//盐</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getCredentialsSalt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> username + salt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//getter/setter...</span></span><br></pre></td></tr></table></figure>

<p>意义就是指定之后要使用的盐值<code>salt</code>实际上是<code>username</code>和<code>salt</code>的组合体，但是你肯定好奇，为什么又定义<code>getCredentialsSalt()</code>呢？<br>要区分：<code>setSalt()</code>是为User实体了设置salt参数的值，salt的值本就是<code>RandomNumberGenerator</code>生成的随机数；但是<code>getCredentialsSalt()</code>得到的盐值是<code>用户名+随机数</code>，这个值最终成为了<code>SimpleHash</code>加密密码的一个重要组成部分，那么最终通过指定加密方式（这里是MD5）加密的密码由<code>用户名+随机数+密码</code>组合而得。</p>
<h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>上面介绍了核心的加密流程，那么如何使用？什么时候需要加密呢？</p>
<p>固然是在创建新用户的时候加密用户密码了，那么我们来看下创建用户的Service层：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//加密密码</span></span><br><span class="line">  passwordHelper.encryptPassword(user);</span><br><span class="line">  userDao.create(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建用户时，要调用<code>passwordHelper</code>的<code>encryptPassword()</code>方法对传入的User对象进行密码加密和设定盐值处理。那么在数据库中保存的数据就如：</p>
<p><img src="/2018/09/18/ssm/shiro/ssm-shiro/1.png" alt></p>
<p>除了创建用户，更新用户数据的时候也要重新加密密码（只要更新了User表的用户名或密码）都必须调用<code>encryptPassword()</code>重新加密密码和设置盐值，因为最终存在数据库表中的密码是<code>用户名+密码+盐值</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//加密密码</span></span><br><span class="line">    passwordHelper.encryptPassword(user);</span><br><span class="line">    userDao.update(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h3><p>上面讲了半天的加密过程，下面说一下解密实现。之前已经说过，散列算法是不可逆的，所以一旦密码被加密是无法算出来的，但是我们可以用另外一种方式：比对。就是将散列算法的加密方式传给Realm，当用户登录系统时，获取用户输入的密码根据已定义的加密方式对此密码进行加密，然后交给<code>SimpleAuthenticationInfo</code>将用户登录输入的加密密码和数据库中根据username得到的加密密码进行比对，如果比对成功就证明你的登录密码是正确的，从而实现解密。</p>
<p>那么应该怎么实现？很简单，在Realm中我们应该调用<code>SimpleAuthenticationInfo</code>的这个构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SimpleAuthenticationInfo</span><span class="params">(Object principal, Object hashedCredentials, ByteSource credentialsSalt, String realmName)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>那么我们要更改Realm中的<code>SimpleAuthenticationInfo</code>的这个实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SimpleAuthenticationInfo authenticationInfo = <span class="keyword">new</span> SimpleAuthenticationInfo(</span><br><span class="line">    user.getUsername(), <span class="comment">//用户名</span></span><br><span class="line">    user.getPassword(), <span class="comment">//密码</span></span><br><span class="line">    ByteSource.Util.bytes(user.getCredentialsSalt()), <span class="comment">//salt=username+salt</span></span><br><span class="line">    getName() <span class="comment">//realm name</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>如果使用了散列算法进行密码加密和验证服务，你必须在Spring配置文件中注入<code>credentialsMatcher</code>来实现密码验证服务。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"credentialsMatcher"</span> <span class="attr">class</span>=<span class="string">"cn.tycoding.credentials.RetryLimitHashedCredentialsMatcher"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"cacheManager"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hashAlgorithmName"</span> <span class="attr">value</span>=<span class="string">"md5"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hashIterations"</span> <span class="attr">value</span>=<span class="string">"2"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"storedCredentialsHexEncoded"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>创建一个<code>RetryLimitHashedCredentialsMatcher</code>类，继承<code>HashedCredentialsMathcer</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RetryLimitHashedCredentialsMatcher</span> <span class="keyword">extends</span> <span class="title">HashedCredentialsMatcher</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RetryLimitHashedCredentialsMatcher</span><span class="params">(CacheManager cacheManager)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doCredentialsMatch</span><span class="params">(AuthenticationToken token, AuthenticationInfo info)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就能获取到加密密码的盐值，然后<code>SimpleAuthenticationInfo</code>会结合这个盐值进行密码比对实现解密。</p>
<br>

<h2 id="Shiro实现授权"><a href="#Shiro实现授权" class="headerlink" title="Shiro实现授权"></a>Shiro实现授权</h2><p>授权，即赋予用户一定的操作权限，这时，就该参考一下项目的表设计了： <a href="http://tycoding.cn/2018/09/15/ssm/shiro/shiro-database/#more" target="_blank" rel="noopener">Shiro实现权限管理系统之表结构设计</a> 。结合数据库的表设计我们似乎就清楚了为什么那样设计表，根据什么进行权限校验和授权，想必你也有一些思路了。</p>
<p>在授权中需要了解几个关键对象：</p>
<style>
table th:first-of-type {
    width: 100px;
}
</style>

<table>
<thead>
<tr>
<th>对象名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>主体(Subject)</td>
<td>即代表当前登录的用户</td>
</tr>
<tr>
<td>资源(Resource)</td>
<td>即用户登录成功后允许访问的东西，比如某个页面，某个文件；它可以精确到某个按钮等..</td>
</tr>
<tr>
<td>权限(Permission)</td>
<td>即代表用户操作系统功能的权利，如果拥有了这个权限才能操作该功能，和资源关联，有权限就意味着有访问资源的权利</td>
</tr>
<tr>
<td>角色(Role)</td>
<td>代表了操作（资源）集合，可以理解为权限的集合，和权限关联，角色对应的权限，权限关联着资源</td>
</tr>
</tbody></table>
<p>所以，我们要清楚：用户和角色间是一对多的关系；角色和权限是多对多的关系；权限和资源是多对多的关系。但是在我们设计的表：<a href="http://tycoding.cn/2018/09/15/ssm/shiro/shiro-database/#more" target="_blank" rel="noopener">Shiro实现权限管理系统之表结构的设计</a>中，我并没有设置单独设置资源表，而是仅用了权限表。<br>当然你可以再写一个资源表(Resource)，建立权限和资源间的关系，这样权限管理能精确到对每个按钮的管理。</p>
<h3 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h3><p>实现授权前，首先，用户得拥有权限，那么就要建立用户-角色的关系、角色-权限的关系；具体操作步骤请参看我的这篇博文：<a href="http://tycoding.cn/2018/09/15/ssm/shiro/shiro-database/#more" target="_blank" rel="noopener">Shiro实现权限管理系统之表结构设计</a>中介绍的sql。</p>
<p>Shiro提供了多种授权方式，比如我们可以看subject实例拥有的授权方法：</p>
<p><img src="/2018/09/18/ssm/shiro/ssm-shiro/2.png" alt></p>
<p>从方法名上就能看出<code>subject</code>提供了哪些授权方式；那么这里我们不讲用<code>subject</code>实例授权的方式，我们讲一种更简便的方式：Shiro注解、Shiro-Spring注解的方式。</p>
<p>Shiro结合Spring提供了相应的注解用户权限控制，我们先来看一下都有哪些注解：</p>
<style>
table th:first-of-type {
    width: 400px;
}
</style>

<table>
<thead>
<tr>
<th>注解名称</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>@RequiresAuthentication</td>
<td>表示当前Subject已经通过login身份验证；即Subject.isAuthenticated() == true；否则就拦截</td>
</tr>
<tr>
<td>@RequiresUser</td>
<td>表示当前Subject已经通过login身份验证或通过记住我登录；否则就拦截</td>
</tr>
<tr>
<td>@RequiresGuest</td>
<td>表示当前Subject没有身份验证或通过记住我登录过，即是游客身份</td>
</tr>
<tr>
<td>@RequiresRoles(value ={“admin”, “user”}, logical=Logical.AND)</td>
<td>表示当前Subject需要同时（由Logical.AND体现）拥有admin和user角色；否则拦截</td>
</tr>
<tr>
<td>@RequiresPermissions(vale={“user:a”,”user:b”}, logical=Logical.OR)</td>
<td>表示当前Subject需要拥有<code>user:a</code>或者（由Logical.OR体现）<code>user:b</code>角色；否则拦截</td>
</tr>
</tbody></table>
<p>因为Shiro的某些权限注解需要AOP的功能进行判断，所以需要开启AOP功能的支持；项目中使用了Spring AOP，Shiro提供了Spring AOP的集成用于权限注解的解析和验证。<br>在SpringMVC的配置文件中开启Shiro Spring AOP 的支持：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"securityManager"</span> <span class="attr">ref</span>=<span class="string">"securityManager"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="在Controller映射方法上添加注解"><a href="#在Controller映射方法上添加注解" class="headerlink" title="在Controller映射方法上添加注解"></a>在Controller映射方法上添加注解</h3><p>创建用户的方法上添加权限注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/create"</span>)</span><br><span class="line"><span class="meta">@RequiresRoles</span>(value=&#123;<span class="string">"admin"</span>,<span class="string">"personnel-resource"</span>&#125;, logical = Logical.OR)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">create</span><span class="params">(@RequestBody User user)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>删除用户信息的方法上添加权限注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/delete"</span>)</span><br><span class="line"><span class="meta">@RequiresRoles</span>(value = &#123;<span class="string">"admin"</span>, <span class="string">"personnel-resource"</span>&#125;, logical = Logical.OR)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">delete</span><span class="params">(@RequestParam(<span class="string">"id"</span>)</span> Long id)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>根据用户名查找其角色的方法上添加权限注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/findRoles"</span>)</span><br><span class="line"><span class="meta">@RequiresRoles</span>(value = &#123;<span class="string">"admin"</span>&#125;, logical = Logical.OR)</span><br><span class="line"><span class="meta">@RequiresPermissions</span>(value = &#123;<span class="string">"role:view"</span>, <span class="string">"role:*"</span>&#125;, logical = Logical.OR)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Role&gt; <span class="title">findRoles</span><span class="params">(String username)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>…</p>
<h3 id="JSP页面授权"><a href="#JSP页面授权" class="headerlink" title="JSP页面授权"></a>JSP页面授权</h3><p>Shiro提供了JSTL标签用于在JSP/GSP页面进行权限控制；首先需要导入标签库：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">taglib</span> <span class="attr">prefix</span>=<span class="string">"c"</span> <span class="attr">uri</span>=<span class="string">"http://java.sun.com/jsp/jstl/core"</span> %&gt;</span></span><br></pre></td></tr></table></figure>

<style>
table th:first-of-type {
    width: 200px;
}
</style>

<table>
<thead>
<tr>
<th>标签名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;shiro:guest&gt;</code></td>
<td>用户没有身份验证时显示相应的信息，即游客访问信息</td>
</tr>
<tr>
<td><code>&lt;shiro:user&gt;</code></td>
<td>用户已经身份验证、记住我登录后显示相应的信息，未登录用户将会拦截</td>
</tr>
<tr>
<td><code>&lt;shiro:authenticated&gt;</code></td>
<td>用户已经身份验证通过，即Subject.isAuthenticated() == true；未登录或记住我登录的都会拦截</td>
</tr>
<tr>
<td><code>&lt;shiro:notAuthenticated&gt;</code></td>
<td>用户已经身份验证通过，但是Subject.isAuthenticated() == false，即可能是通过记住我登录的</td>
</tr>
<tr>
<td><code>&lt;shiro:principal&gt;</code></td>
<td>显示用户身份信息，默认调用Subject.getPrincipal()获取用户登录信息</td>
</tr>
<tr>
<td><code>&lt;shiro:hasRole&gt;</code></td>
<td>如：<code>&lt;shiro:hasRole name=&quot;admin&quot;&gt;</code>，如果当前Subject有admin角色就显示数据，类似于<code>@RequiresRoles()</code>注解；否则就拦截</td>
</tr>
<tr>
<td><code>&lt;shiro:hasAnyRole&gt;</code></td>
<td>如：<code>&lt;shiro:hasAnyRole name=&quot;admin,user&quot;&gt;</code>，如果当前Subject有admin或user角色就显示数据，类似于<code>@RequireRoles(Logical=Logical.OR)</code>注解；否则将就拦截</td>
</tr>
<tr>
<td><code>&lt;shiro:lackRole&gt;</code></td>
<td>如果当前Subject没有角色就显示数据</td>
</tr>
<tr>
<td><code>&lt;shiro:hasPermission&gt;</code></td>
<td>如：<code>&lt;shiro:hasPermission name=&quot;user:create&quot;&gt;</code>，如果当前Subject有<code>user:create</code>权限，就显示数据；否则就拦截</td>
</tr>
<tr>
<td><code>&lt;shiro:lacksPermission&gt;</code></td>
<td>如：<code>&lt;shiro:lacksPermission name=&quot;user:create&quot;&gt;</code>，如果当前Subject没有<code>user:create</code>权限，就显示数据；否则拦截</td>
</tr>
</tbody></table>
<br>

<h2 id="Shiro实现会话管理"><a href="#Shiro实现会话管理" class="headerlink" title="Shiro实现会话管理"></a>Shiro实现会话管理</h2><p>会话：用户登录后直至注销（Session丢失）前称为一次会话，即用户访问应用时保持的连接关系，可以保证在多次交互中应用能够识别出当前访问的用户是谁，且可在多次交互中保存一些数据。常见的应用实例如：登录时记住我的功能、单点登录的功能…</p>
<p>Shiro提供了会话管理器：<code>sessionManager</code>，管理着所有会话的创建、维护、删除、等工作。在web环境中使用Shiro的会话管理器，我们需要在Spring的配置文件中注入<code>DefaultWebSessionManager</code>:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sessionManager"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.web.session.mgt.DefaultWebSessionManager"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置全局会话过期时间：默认30分钟 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"globalSessionTimeout"</span> <span class="attr">value</span>=<span class="string">"1800000"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 是否启用sessionIdCookie，默认是启用的 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sessionIdCookieEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 会话Cookie --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sessionIdCookie"</span> <span class="attr">ref</span>=<span class="string">"sessionIdCookie"</span>/&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 会话Cookie模板 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sessionIdCookie"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.web.servlet.SimpleCookie"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"sid"</span>/&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 如果设置为true，则客户端不会暴露给服务端脚本代码，有助于减少某些类型的跨站脚本攻击 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"httpOnly"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxAge"</span> <span class="attr">value</span>=<span class="string">"-1"</span>/&gt;</span><span class="comment">&lt;!-- maxAge=-1表示浏览器关闭时失效此Cookie --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>还要将<code>sessionManager</code>注入到<code>SecurityManager</code>中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"securityManager"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.web.mgt.DefaultWebSecurityManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"realm"</span> <span class="attr">ref</span>=<span class="string">"userRealm"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注入sessionManager --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sessionManager"</span> <span class="attr">ref</span>=<span class="string">"sessionManager"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Shiro缓存实现"><a href="#Shiro缓存实现" class="headerlink" title="Shiro缓存实现"></a>Shiro缓存实现</h2><p>Shiro也集成了缓存机制，例如Shiro提供了CachingRealm，提供了一些基础的缓存实现。Shiro默认是禁用缓存的，首先我们要开启Shiro的缓存管理，在XML中进行如下配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cacheManager"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.cache.ehcache.EhCacheManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cacheManagerConfigFile"</span> <span class="attr">value</span>=<span class="string">"classpath:other/ehcache.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在自定义的Realm实现中配置缓存的实现：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Realm实现 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userRealm"</span> <span class="attr">class</span>=<span class="string">"cn.tycoding.realm.UserRealm"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用credentialsMatcher实现密码验证服务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"credentialsMatcher"</span> <span class="attr">ref</span>=<span class="string">"credentialsMatcher"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 是否启用缓存 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cachingEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 是否启用身份验证缓存 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"authenticationCachingEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 缓存AuthenticationInfo信息的缓存名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"authenticationCacheName"</span> <span class="attr">value</span>=<span class="string">"authenticationCache"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 是否启用授权缓存，缓存AuthorizationInfo信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"authorizationCachingEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 缓存AuthorizationInfo信息的缓存名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"authorizationCacheName"</span> <span class="attr">value</span>=<span class="string">"authorizationCache"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在<code>resources/other/</code>文件夹下创建配置文件<code>ehcache.xml</code>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ehcache</span> <span class="attr">name</span>=<span class="string">"shirocache"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span> <span class="attr">name</span>=<span class="string">"shiro-activeSessionCache"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">maxEntriesLocalHeap</span>=<span class="string">"2000"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">eternal</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">timeToIdleSeconds</span>=<span class="string">"3600"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">timeToLiveSeconds</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">overflowToDisk</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">statistics</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>设置SecurityManager的cacheManager：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"securityManager"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.web.mgt.DefaultWebSecurityManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cacheManager"</span> <span class="attr">ref</span>=<span class="string">"cacheManager"</span>/&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="实现Remember功能"><a href="#实现Remember功能" class="headerlink" title="实现Remember功能"></a>实现Remember功能</h2><p>在Shiro会话管理时我们就讲到会话的功能，例如：Shiro实现了RememberMe记住我的功能，当用户在登录页面中勾选了记住我，再浏览器关闭后再次访问系统发现是可以直接登录的；但是如果没有实现这一功能，Shiro默认设置浏览器关闭后立即清除缓存，那么再次打开浏览器要重新进行登录。</p>
<ul>
<li>拓展</li>
</ul>
<p>RememberMe和使用<code>Subject.login(token)</code>登录是有所不同的，RememberMe是使用缓存Cookie的技术实现的登录，在前面讲到的一些权限注解中就说到了两者的区别。</p>
<ul>
<li>RememberMe的配置实现</li>
</ul>
<p>在配置文件中写入：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 会话Cookie模板 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sessionIdCookie"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.web.servlet.SimpleCookie"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"sid"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 如果设置为true，则客户端不会暴露给服务端脚本代码，有助于减少某些类型的跨站脚本攻击 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"httpOnly"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxAge"</span> <span class="attr">value</span>=<span class="string">"-1"</span>/&gt;</span><span class="comment">&lt;!-- maxAge=-1表示浏览器关闭时失效此Cookie --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"rememberMeCookie"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.web.servlet.SimpleCookie"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"rememberMe"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"httpOnly"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxAge"</span> <span class="attr">value</span>=<span class="string">"2592000"</span>/&gt;</span><span class="comment">&lt;!-- 30天 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- rememberMe管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"rememberMeManager"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.web.mgt.CookieRememberMeManager"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- cipherKey是加密rememberMe Cookie的密匙，默认AES算法 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cipherKey"</span> <span class="attr">value</span>=<span class="string">"#&#123;T(org.apache.shiro.codec.Base64).decode('4AvVhmFLUs0KTA3Kprsdag==')&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cookie"</span> <span class="attr">ref</span>=<span class="string">"rememberMeCookie"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在<code>sessionIdCookie</code>中设置<code>maxAge=-1</code>表示浏览器关闭后即失效此Cookie在<code>rememberMeCookie</code>中设置<code>maxAge=2592000</code>表示记住此Cookie，保存30天。</p>
<p>在<code>SecurityManager</code>中设置<code>rememberMeManager</code>:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"securityManager"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.web.mgt.DefaultWebSecurityManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"rememberMeManager"</span> <span class="attr">ref</span>=<span class="string">"rememberMeManager"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ol>
<li>修改login登录页面：</li>
</ol>
<p>在登录表单中添加一个checkbox：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"remember"</span>&gt;</span>请记住我</span><br></pre></td></tr></table></figure>

<p>如果用户勾选了这个复选框，点击登录按钮提交后台的参数中会多一个<code>remember</code>参数，且值是<code>on</code>（如果用户没有勾选，提交表单中就不存在这个参数）；所以我们修改Controller的登录方法：</p>
<ol start="2">
<li>修改Controller</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            @RequestParam(value = <span class="string">"username"</span>, required = <span class="keyword">false</span>)</span> String username,</span></span><br><span class="line"><span class="function">            @<span class="title">RequestParam</span><span class="params">(value = <span class="string">"password"</span>, required = <span class="keyword">false</span>)</span> String password,</span></span><br><span class="line"><span class="function">            @<span class="title">RequestParam</span><span class="params">(value = <span class="string">"remember"</span>, required = <span class="keyword">false</span>)</span> String remember,</span></span><br><span class="line"><span class="function">            Model model) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (username != <span class="keyword">null</span> &amp;&amp; password != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//初始化</span></span><br><span class="line">      Subject subject = SecurityUtils.getSubject();</span><br><span class="line">      UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(username, password);</span><br><span class="line">      <span class="keyword">if</span> (remember != <span class="keyword">null</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span> (remember.equals(<span class="string">"on"</span>)) &#123;</span><br><span class="line">              <span class="comment">//说明选择了记住我</span></span><br><span class="line">              token.setRememberMe(<span class="keyword">true</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              token.setRememberMe(<span class="keyword">false</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          token.setRememberMe(<span class="keyword">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//登录，即身份校验，由通过Spring注入的UserRealm会自动校验输入的用户名和密码在数据库中是否有对应的值</span></span><br><span class="line">          subject.login(token);</span><br><span class="line">          <span class="keyword">return</span> <span class="string">"redirect:index.do"</span>;</span><br><span class="line">      &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">          error = <span class="string">"未知错误，错误信息："</span> + e.getMessage();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      error = <span class="string">"请输入用户名和密码"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//登录失败，跳转到login页面</span></span><br><span class="line">  model.addAttribute(<span class="string">"error"</span>, error);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"login"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建一个测试页面</li>
</ol>
<p>创建一个<code>authenticated.jsp</code>页面，随便写一段文字<code>此页面必须是Subject.isAuthenticated() == true才能访问</code>。然后在配置文件的<code>filterChainDefinitions</code>中定义</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">/authenticated.jsp = authc</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>测试</li>
</ol>
<p>启动项目，访问<code>localhost:8080/</code>自动跳转到登录页面，勾选登录表单中的记住我复选框，成功登录系统后，关闭浏览器。再次打开浏览器，直接访问<code>localhost:8080/index.do</code>发现直接就能登录系统。但是直接在浏览器中输入<code>localhost:8080/authenticated.jsp</code>发现确是不能访问的，并且被拦截道登录页面，原因就是rememberMe登录系统并不是通过<code>Subject.login(token)</code>的方式，而<code>authc</code>拦截器拦截的资源要求必须是<code>Subject.isAuthenticated() == true</code>才能访问。</p>
<p>重新启动项目（或者注销账户），重新进入登录页面，此次不勾选记住我复选框，成功进入系统后关闭浏览器，再次打开浏览器输入<code>localhost:8080/index.do</code>发现会再次被拦截跳转到<code>loginUrl</code>地址。</p>
<h2 id="项目截图"><a href="#项目截图" class="headerlink" title="项目截图"></a>项目截图</h2><p><img src="/2018/09/18/ssm/shiro/ssm-shiro/4.png" alt></p>
<br>

<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <tags>
        <tag>shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>Shiro实现权限管理之表结构设计</title>
    <url>/2018/09/15/ssm/shiro/shiro-database/</url>
    <content><![CDATA[<p><strong>权限框架Shiro学习之表结构设计</strong></p>
<p>Shiro是一款优秀的开源安全框架，学习Shiro大家可以参考张开涛老师的博客:<a href="http://jinnianshilongnian.iteye.com/blog/2049092" target="_blank" rel="noopener">跟我学Shiro</a>，当然也可参考我之前的笔记：<a href="http://tycoding.cn/2018/07/07/ssm/shiro/shiro-2/" target="_blank" rel="noopener">Shiro实现身份认证</a>、<a href="http://tycoding.cn/2018/07/08/ssm/shiro/shiro-3/" target="_blank" rel="noopener">Shiro实现授权</a>。</p>
<p>在学习完基础的Shiro入门知识，我们可以动手写一个小Demo了，这次我们将以一个用户-角色-权限管理的Demo来进一步学习Shiro。</p>
<a id="more"></a>

<h1 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h1><h2 id="表设计"><a href="#表设计" class="headerlink" title="表设计"></a>表设计</h2><p>开发用户-角色-权限管理系统，首先我们需要知道<code>用户-角色-权限</code>管理系统的表结构设计。</p>
<p>在<code>用户-角色-权限</code>管理系统找那个一般会涉及5张表，分别为：</p>
<ul>
<li>1.<code>sys_users</code>用户表</li>
<li>2.<code>sys_roles</code>角色表</li>
<li>3.<code>sys_permissions</code>权限表（或资源表）</li>
<li>4.<code>sys_users_roles</code>用户-角色关联表 </li>
<li>5.<code>sys_roles_permissions</code>角色-权限关联表（或角色-资源关联表）</li>
</ul>
<p><strong>详细的建表信息如下</strong></p>
<ul>
<li><code>sys_users</code></li>
</ul>
<p><img src="/2018/09/15/ssm/shiro/shiro-database/1.png" alt></p>
<p><strong>解释</strong><br>用户表中至少包含以上的字段，主键id、用户名username、密码password、盐值salt（因为密码是经过Shiro加密的，需要通过盐值校验，由Shiro生成，不需要用户手动填写）、角色列表roleId（这个字段不是必须的，仅实现在展示用户信息的时候能同时展示用户当前角色）、是否锁定locked（决定当前账户是否是锁定的）。<br>创建新的用户，仅需要输入用户名和密码即可，盐值由Shiro生成，角色列表和是否锁定都可以在后期管理。</p>
<p>其中是否锁定字段类型为<code>tinyint(1)</code>，设置这种类型，数据库中实际存储的是int类型数据，一般是0和1，在使用Mybatis取这个字段的数据时，Mybatis会自动将<code>tinyint(1)</code>字段值为0的转换成false，将字段值为1以上的转换为true。</p>
<ul>
<li><code>sys_roles</code></li>
</ul>
<p><img src="/2018/09/15/ssm/shiro/shiro-database/2.png" alt></p>
<p><strong>解释</strong><br>角色表中role角色名称一般为存储着类似<code>user:create</code>这种格式，Shiro在Realm中校验用户身份的时候会通过<code>role</code>这个字段值进行校验；<code>description</code>是此角色的描述信息，比如<code>用户创建</code>。
其中<code>pid</code>表示父节点，就是说，当前的角色可能有上级节点，比如<code>老师</code>，这个角色可能就有父节点<code>计科教师</code>，如果存在父节点，这个字段值就是父级节点的ID，根据这个ID，在展示数据的时候就很方便的展示出其在哪个父节点下。<br><code>available</code>表示当前节点是否锁定，同样是<code>tinyint(1)</code>类型，如果为false就说明没有锁定。</p>
<ul>
<li><code>sys_users_roles</code></li>
</ul>
<p><img src="/2018/09/15/ssm/shiro/shiro-database/3.png" alt></p>
<p><strong>解释</strong><br>用户角色表就比较简单了，仅仅包含了主键<code>id</code>、用户ID<code>user_id</code>、角色ID<code>role_id</code>；这张表主要描述指定用户与角色间的依赖关系。其中用户表与角色表是一对多的关系，一个用户可以拥有多个角色。</p>
<ul>
<li><code>sys_permissions</code></li>
</ul>
<p><img src="/2018/09/15/ssm/shiro/shiro-database/4.png" alt></p>
<p><strong>解释</strong><br>权限表和角色表类似，其中不同的字段是<code>rid</code>，这个字段表示此权限关联的角色的id值，当然不是必要的，但是后端角色更新时用到了，后面会介绍。</p>
<ul>
<li><code>sys_roles_permissions</code></li>
</ul>
<p><img src="/2018/09/15/ssm/shiro/shiro-database/5.png" alt></p>
<p><strong>解释</strong><br>角色-权限表和用户-角色表类似，包含了主键<code>id</code>、角色ID<code>role_id</code>、权限ID<code>permission_id</code>，主要描述角色和权限间的依赖关系，同样，角色和权限间也是一对多的关系，一个角色会关联多个权限。</p>
<br>

<h2 id="schema-sql"><a href="#schema-sql" class="headerlink" title="schema.sql"></a>schema.sql</h2><p>上述表设计的源码如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- create database shiro default character set utf8;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> sys_users;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> sys_roles;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> sys_permissions;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> sys_users_roles;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> sys_roles_permissions;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> sys_users (</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">bigint</span> auto_increment <span class="keyword">comment</span> <span class="string">'编号'</span>,</span><br><span class="line">  username <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">comment</span> <span class="string">'用户名'</span>,</span><br><span class="line">  <span class="keyword">password</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">comment</span> <span class="string">'密码'</span>,</span><br><span class="line">  <span class="keyword">salt</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">comment</span> <span class="string">'盐值'</span>,</span><br><span class="line">  role_id <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">comment</span> <span class="string">'角色列表'</span>,</span><br><span class="line">  <span class="keyword">locked</span> <span class="built_in">bool</span> <span class="keyword">default</span> <span class="literal">false</span> <span class="keyword">comment</span> <span class="string">'是否锁定'</span>,</span><br><span class="line">  <span class="keyword">constraint</span> pk_sys_users primary <span class="keyword">key</span>(<span class="keyword">id</span>)</span><br><span class="line">) <span class="keyword">charset</span>=utf8 <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> <span class="keyword">index</span> idx_sys_users_username <span class="keyword">on</span> sys_users(username);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> sys_roles (</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">bigint</span> auto_increment <span class="keyword">comment</span> <span class="string">'角色编号'</span>,</span><br><span class="line">  <span class="keyword">role</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">comment</span> <span class="string">'角色名称'</span>,</span><br><span class="line">  description <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">comment</span> <span class="string">'角色描述'</span>,</span><br><span class="line">  pid <span class="built_in">bigint</span> <span class="keyword">comment</span> <span class="string">'父节点'</span>,</span><br><span class="line">  available <span class="built_in">bool</span> <span class="keyword">default</span> <span class="literal">false</span> <span class="keyword">comment</span> <span class="string">'是否锁定'</span>,</span><br><span class="line">  <span class="keyword">constraint</span> pk_sys_roles primary <span class="keyword">key</span>(<span class="keyword">id</span>)</span><br><span class="line">) <span class="keyword">charset</span>=utf8 <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> <span class="keyword">index</span> idx_sys_roles_role <span class="keyword">on</span> sys_roles(<span class="keyword">role</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> sys_permissions (</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">bigint</span> auto_increment <span class="keyword">comment</span> <span class="string">'编号'</span>,</span><br><span class="line">  permission <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">comment</span> <span class="string">'权限编号'</span>,</span><br><span class="line">  description <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">comment</span> <span class="string">'权限描述'</span>,</span><br><span class="line">  rid <span class="built_in">bigint</span> <span class="keyword">comment</span> <span class="string">'此权限关联角色的id'</span>,</span><br><span class="line">  available <span class="built_in">bool</span> <span class="keyword">default</span> <span class="literal">false</span> <span class="keyword">comment</span> <span class="string">'是否锁定'</span>,</span><br><span class="line">  <span class="keyword">constraint</span> pk_sys_permissions primary <span class="keyword">key</span>(<span class="keyword">id</span>)</span><br><span class="line">) <span class="keyword">charset</span>=utf8 <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> <span class="keyword">index</span> idx_sys_permissions_permission <span class="keyword">on</span> sys_permissions(permission);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> sys_users_roles (</span><br><span class="line">  <span class="keyword">id</span>  <span class="built_in">bigint</span> auto_increment <span class="keyword">comment</span> <span class="string">'编号'</span>,</span><br><span class="line">  user_id <span class="built_in">bigint</span> <span class="keyword">comment</span> <span class="string">'用户编号'</span>,</span><br><span class="line">  role_id <span class="built_in">bigint</span> <span class="keyword">comment</span> <span class="string">'角色编号'</span>,</span><br><span class="line">  <span class="keyword">constraint</span> pk_sys_users_roles primary <span class="keyword">key</span>(<span class="keyword">id</span>)</span><br><span class="line">) <span class="keyword">charset</span>=utf8 <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> sys_roles_permissions (</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">bigint</span> auto_increment <span class="keyword">comment</span> <span class="string">'编号'</span>,</span><br><span class="line">  role_id <span class="built_in">bigint</span> <span class="keyword">comment</span> <span class="string">'角色编号'</span>,</span><br><span class="line">  permission_id <span class="built_in">bigint</span> <span class="keyword">comment</span> <span class="string">'权限编号'</span>,</span><br><span class="line">  <span class="keyword">constraint</span> pk_sys_roles_permissions primary <span class="keyword">key</span>(<span class="keyword">id</span>)</span><br><span class="line">) <span class="keyword">charset</span>=utf8 <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure>

<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>上面就是当前<code>用户-角色-权限</code>系统的表设计。细心的你可能会发现这些表中并不包含外键约束。</p>
<p>为什么不设计外键呢？</p>
<p>可能你会跟我一样有这样的疑问。比如用户表和角色表间，我们这里创建了用户-角色表来实现两者的关联；并没有通过给两张表建立外键来实现一对多、多对多的关联关系。<br>因为如果你要建立外键来关联两张表，你需要遇到如下：</p>
<ol>
<li>如果两张表之间存在一对多的关系，在给<code>一</code>的一方新增数据的时候，你要考虑<code>多</code>的一方是否存在指定的id。</li>
<li>如果两张表之间存在一对多的关系，在删除<code>多</code>的一方时你要先删除其关联的<code>一</code>的一方，再删除<code>多</code>的一方。</li>
<li>…</li>
</ol>
<p>也就是说如果使用了外键关联，那么在对表进行数据操作时就<strong>必须</strong>考虑另一张关联的表，相当于两张表就绑在一起了，操作这张表就必须考虑另一张关联表。</p>
<p>但是实际中，我们不想立即就修改或更新关联表的数据，我可能一会再去更新另一张关联表的数据，那么就产生了这种方式：通过单独建立一张关联来实现两张表的数据关联。</p>
<p>所以，我建议大家在设计表时尽量减少表与表直接的外键约束，这样能避免很多麻烦，并且两张表之间的关联关系也会格外清晰。</p>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>上面创建了用户-角色-权限表以及其关联表，下面就介绍一些实际的案例吧！</p>
<h2 id="初始化表"><a href="#初始化表" class="headerlink" title="初始化表"></a>初始化表</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into sys_users values(1,&apos;TyCoding&apos;,&apos;123&apos;,&apos;salt&apos;,&apos;管理员&apos;,0);</span><br><span class="line">insert into sys_roles values(21,&apos;user:create&apos;,&apos;用户创建&apos;,0,0);</span><br><span class="line">insert into sys_permissions values(31,&apos;user:create&apos;,&apos;用户创建&apos;,0,0);</span><br><span class="line">insert into sys_users_roles values(1,1,21);</span><br><span class="line">insert into sys_roles_permissions values(1,21,31);</span><br></pre></td></tr></table></figure>

<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><h3 id="根据用户名查询其角色"><a href="#根据用户名查询其角色" class="headerlink" title="根据用户名查询其角色"></a>根据用户名查询其角色</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[mysql&gt; SELECT r.id, r.role, r.description FROM sys_users u, sys_roles r, sys_users_roles ur WHERE u.username = 'TyCoding' AND u.id = ur.user_id AND r.id = ur.role_id;</span><br><span class="line">+<span class="comment">----+-------+-------------+</span></span><br><span class="line">| id | role  | description |</span><br><span class="line">+<span class="comment">----+-------+-------------+</span></span><br><span class="line">| 21 | admin | 管理员      |</span><br><span class="line">+<span class="comment">----+-------+-------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>从上面的SQL中足以看出，通过关联表查询另一张关联的数据要点在于WHERE条件中添加关联表与两张表的关系，在这里即是关联表中存在两张表的主键id，所以把相同的字段加入WHERE条件过滤就能查询到了。</p>
<h3 id="根据用户名查询其权限"><a href="#根据用户名查询其权限" class="headerlink" title="根据用户名查询其权限"></a>根据用户名查询其权限</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[mysql&gt; SELECT p.id, p.permission, p.description FROM sys_users u, sys_roles r, sys_users_roles ur, sys_permissions p, sys_roles_permissions rp WHERE u.username = 'TyCoding' AND u.id = ur.user_id AND r.id = ur.role_id AND r.id = rp.role_id AND p.id = rp.permission_id;</span><br><span class="line">+<span class="comment">----+-------------+--------------+</span></span><br><span class="line">| id | permission  | description  |</span><br><span class="line">+<span class="comment">----+-------------+--------------+</span></span><br><span class="line">| 31 | user:<span class="keyword">create</span> | 用户创建     |</span><br><span class="line">+<span class="comment">----+-------------+--------------+</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<h3 id="根据角色id查询其权限"><a href="#根据角色id查询其权限" class="headerlink" title="根据角色id查询其权限"></a>根据角色id查询其权限</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[mysql&gt; SELECT p.id, p.description FROM sys_permissions p, sys_roles r, sys_roles_permissions rp WHERE r.id = 21 AND rp.role_id = r.id AND rp.permission_id = p.id;</span><br><span class="line">+<span class="comment">----+--------------+</span></span><br><span class="line">| id | description  |</span><br><span class="line">+<span class="comment">----+--------------+</span></span><br><span class="line">| 31 | 用户创建     |</span><br><span class="line">+<span class="comment">----+--------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<h3 id="更新user表中role-id字段"><a href="#更新user表中role-id字段" class="headerlink" title="更新user表中role_id字段"></a>更新user表中<code>role_id</code>字段</h3><p>我们设计的<code>sys_users</code>表中，存在一个字段<code>role_id</code>，目的是用来展示当前用户关联的角色名称，但是我们直接更新<code>sys_roles</code>表的<code>description</code>字段时，又不会更新<code>sys_users</code>表中的<code>role_id</code>字段。</p>
<p>所以，这里我们要通过更新的角色数据来更新<code>sys_users</code>表中的<code>role_id</code>字段。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[mysql&gt; UPDATE sys_users u, sys_users_roles ur SET u.role_id = '管理员-更新' WHERE ur.role_id = 21 AND u.id = ur.user_id;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM sys_users;</span><br><span class="line">+<span class="comment">----+----------+----------+------+------------------+--------+</span></span><br><span class="line">| id | username | password | salt | role_id          | locked |</span><br><span class="line">+<span class="comment">----+----------+----------+------+------------------+--------+</span></span><br><span class="line">|  1 | TyCoding | 123      | salt | 管理员-更新      |      0 |</span><br><span class="line">+<span class="comment">----+----------+----------+------+------------------+--------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<h3 id="根据权限ID查询其角色"><a href="#根据权限ID查询其角色" class="headerlink" title="根据权限ID查询其角色"></a>根据权限ID查询其角色</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[mysql&gt; SELECT r.id, r.description, r.pid FROM sys_permissions p, sys_roles r, sys_roles_permissions rp WHERE p.id = 31 AND p.id = rp.permission_id AND r.id = rp.role_id;</span><br><span class="line">+<span class="comment">----+-------------+------+</span></span><br><span class="line">| id | description | pid  |</span><br><span class="line">+<span class="comment">----+-------------+------+</span></span><br><span class="line">| 21 | 管理员      |    0 |</span><br><span class="line">+<span class="comment">----+-------------+------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<br>

<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <tags>
        <tag>shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>FastDFS系统搭建</title>
    <url>/2018/08/29/ssm/fastdfs/</url>
    <content><![CDATA[<h1 id="手摸手教你搭建FasfDFS分布式文件系统"><a href="#手摸手教你搭建FasfDFS分布式文件系统" class="headerlink" title="手摸手教你搭建FasfDFS分布式文件系统"></a>手摸手教你搭建FasfDFS分布式文件系统</h1><p>由于正在学习的分布式项目中用到了<code>FastDFS</code>文件系统，因为各种原因就只好手动搭建环境。搭建过程确实很复杂，我也是折腾了好长时间才解决的，看了网上的教程，但很少有直接就能搭建成功得博文教程，所以这里自己写了一个完成的教程，并附带了所需的配置文件。</p>
<p>需要注意的是Linux系统、版本的问题，我这里使用的是CentOS7的版本，如果大家搭建请尽量保证版本一致。</p>
<a id="more"></a>

<h2 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、下载Linux系统（以CentOS为例）</span><br><span class="line">  [CentOS7-Minimal](http://isoredirect.centos.org/centos/7/isos/x86_64/CentOS-7-x86_64-Minimal-1804.iso)</span><br><span class="line">  </span><br><span class="line">2、安装SecureCRT</span><br><span class="line">  因为实际的服务器并不存在桌面，所以我们安装Minimal版本的CentOS即可，但是在CentOS的黑窗口中操作并不方便，所以下载SecureCRT操纵服务器。</span><br></pre></td></tr></table></figure>

<br>

<h3 id="安装CentOS"><a href="#安装CentOS" class="headerlink" title="安装CentOS"></a>安装CentOS</h3><p>本例中用VMware安装的CentOS系统，在安装时需要注意一个问题：</p>
<p><img src="/2018/08/29/ssm/fastdfs/1.png" alt></p>
<p>如上图所示，在安装CentOS时不要创建新用户，设置个ROOT密码即可，这样登录进去系统后默认就是ROOT权限，避免了权限不够的问题。（登录用户名密码默认都是<code>root</code>）</p>
<p><strong>1、登录系统并配置连接网络</strong></p>
<p>输入命令：<code>cd /etc/sysconfig/network-scripts/ &amp;&amp; ls</code>，编辑列表中的第一个文件（因为文件名称可能不相同）</p>
<p><img src="/2018/08/29/ssm/fastdfs/2.png" alt></p>
<p>将最后行的<code>no</code>改成<code>yes</code>即可</p>
<p><img src="/2018/08/29/ssm/fastdfs/3.png" alt></p>
<p>修改点击键盘的<code>i</code>键进入编辑模式，修改完成后按下ESC键，再输入<code>:wq!</code>保存退出即可；然后执行命令<code>service network restart</code>重启服务。</p>
<p>此时已经完成了CentOS的联网，输入命令<code>ip addr</code>查看服务器的IP地址（如果联网成功，会出现192.168.xx.xx类似这样的IP地址）：</p>
<p><img src="/2018/08/29/ssm/fastdfs/4.png" alt></p>
<p>这个IP地址即使此服务器的外网IP，即我们要用SecureCRT连接的服务器的IP</p>
<p><strong>2、使用SecureCRT连接服务器</strong></p>
<p>SecureCRT的使用方法不在说了，就是简单的创建一个连接，输入服务器的IP地址、账户、密码即可完成连接。</p>
<p><strong>3、关闭CentOS7的防火墙</strong></p>
<p>作为我们测试用的本地服务器，加一个防火墙实在是没有必要的，所以索性关闭防火墙。<br>输入命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld.service #停止firewall</span><br><span class="line">systemctl disable firewalld.service #禁止firewall开机启动</span><br><span class="line">firewall-cmd --state #查看默认防火墙状态（关闭后显示notrunning，开启后显示running）</span><br></pre></td></tr></table></figure>

<br>

<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="安装所需命令"><a href="#安装所需命令" class="headerlink" title="安装所需命令"></a>安装所需命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# yum install make cmake gcc gcc-c++ </span><br><span class="line">[root@localhost ~]# yum install vim-enhanced</span><br><span class="line">[root@localhost ~]# yum install zip unzip</span><br><span class="line">[root@localhost ~]# yum install -y pcre pcre-devel</span><br><span class="line">[root@localhost ~]# yum install -y zlib zlib-devel</span><br><span class="line">[root@localhost ~]# yum install -y openssl openssl-devel</span><br><span class="line">[root@localhost ~]# yum install net-tools</span><br><span class="line">[root@localhost ~]# yum install git</span><br></pre></td></tr></table></figure>

<br>

<h3 id="clone所需的安装文件"><a href="#clone所需的安装文件" class="headerlink" title="clone所需的安装文件"></a>clone所需的安装文件</h3><p>我将所需的安装文件都上传到了我的 <a href="https://github.com/TyCoding/build-fastdfs" target="_blank" rel="noopener">GitHub</a> 上，大家只需要clone下载即可，这些版本我测试过是可用的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GitHub地址： https://github.com/TyCoding/build-fastdfs</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# git clone https://github.com/TyCoding/build-fastdfs.git</span><br><span class="line">[root@localhost ~]# mv build-fastdfs/* /root/ &amp;&amp; rm -rf build-fastdfs</span><br><span class="line">[root@localhost ~]# cd software</span><br></pre></td></tr></table></figure>

<br>

<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h3 id="安装libfastcommon"><a href="#安装libfastcommon" class="headerlink" title="安装libfastcommon"></a>安装libfastcommon</h3><p>将<code>libfastcommon-master.zip</code>解压到<code>/usr/local/fast</code>目录下，并编译安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost software]# unzip libfastcommon-master.zip -d /usr/local/fast/</span><br><span class="line">[root@localhost software]# cd /usr/local/fast/libfastcommon-master/</span><br><span class="line">[root@localhost libfastcommon-master]# ./make.sh &amp;&amp; ./make.sh install</span><br></pre></td></tr></table></figure>

<p>由于libfastcommon安装好后悔自动将库文件拷贝至<code>/usr/lib64</code>目录下，又因为FastDFS程序引用<code>/usr/lib</code>目录，所以我们可以通过创建软连接的方式来解决FastDFS的引用路径问题，当然通过将<code>/usr/lib64</code>下的库文件拷贝到<code>/usr/lib</code>下也行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost libfastcommon-master]# ln -s /usr/lib64/libfastcommon.so /usr/local/lib/libfastcommon.so  </span><br><span class="line">[root@localhost libfastcommon-master]# ln -s /usr/lib64/libfastcommon.so /usr/lib/libfastcommon.so </span><br><span class="line">[root@localhost libfastcommon-master]# ln -s /usr/lib64/libfdfsclient.so /usr/local/lib/libfdfsclient.so  </span><br><span class="line">[root@localhost libfastcommon-master]# ln -s /usr/lib64/libfdfsclient.so /usr/lib/libfdfsclient.so</span><br></pre></td></tr></table></figure>

<br>

<h3 id="安装FastDFS"><a href="#安装FastDFS" class="headerlink" title="安装FastDFS"></a>安装FastDFS</h3><p>将<code>FastDFS_v5.05.tar.gz</code>解压到<code>/usr/local/fast</code>目录下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost libfastcommon-master]# cd ~/software</span><br><span class="line">[root@localhost software]# tar -zxvf FastDFS_v5.05.tar.gz -C /usr/local/fast/</span><br><span class="line">[root@localhost software]# cd /usr/local/fast/FastDFS/</span><br><span class="line">[root@localhost FastDFS]# ./make.sh &amp;&amp; ./make.sh install</span><br></pre></td></tr></table></figure>

<p>因为FastDFS服务器脚本设置的bin目录为<code>/usr/local/bin</code>目录下，但是实际我们安装在<code>usr/bin</code>下面，所以我们要修改FastDFS配置文件中的路径，需要修改配置文件：<code>/etc/init.d/fdfs_storaged</code>以及<code>/etc/init.d/fdfs_trackerd</code>，修改方式如下：<br>输入命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost FastDFS]# vi /etc/init.d/fdfs_storaged </span><br><span class="line"></span><br><span class="line">--这里涉及到了vim的语法，进入这个文件的编辑页面后，直接将输入法切换至英文状态，输入</span><br><span class="line">:%s+/usr/local/bin+/usr/bin</span><br><span class="line"></span><br><span class="line">--当输入完成上面的指令后直接回车会看到：7 substitutions on 7 lines，输入</span><br><span class="line">:wq!</span><br><span class="line">--保存并退出</span><br></pre></td></tr></table></figure>

<p><img src="/2018/08/29/ssm/fastdfs/5.png" alt></p>
<p>一定要<strong>注意</strong>的是，这里并不是在文件中增加这一行代码，如上图，我们是给vim输入了一串指令，这个指令的作用是批量修改一些代码，当回车后会显示：<code>7 substitutions on 7 lines</code>，然后我们输入<code>:wq!</code>保存并退出文件的编辑</p>
<p>同样的方式，修改<code>/etc/init.d/fdfs_trackerd</code>，输入命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost FastDFS]# vi /etc/init.d/fdfs_trackerd</span><br><span class="line"></span><br><span class="line">:%s+/usr/local/bin+/usr/bin</span><br><span class="line"></span><br><span class="line">:wq!</span><br></pre></td></tr></table></figure>

<br>

<h3 id="配置tracker"><a href="#配置tracker" class="headerlink" title="配置tracker"></a>配置tracker</h3><p>进入<code>/etc/fdfs</code>目录并复制一份<code>tracker.conf.sample</code>并命名为<code>tracker.conf</code>，并修改<code>tracker.conf</code>，将其中的<code>base_path</code>参数的值修改为<code>/fastdfs/tracker</code>，并使用<code>makir -p /fastdfs/tracker</code>创建两个目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost FastDFS]# cd /etc/fdfs &amp;&amp; ll</span><br><span class="line">[root@localhost fdfs]# cp tracker.conf.sample tracker.conf</span><br><span class="line">[root@localhost fdfs]# vi tracker.conf</span><br></pre></td></tr></table></figure>

<p>点击键盘的<code>i</code>键进入vim的编辑模式，如果编辑完成后要先点击键盘的<code>ESC</code>键退出vim的编辑模式再点击键盘的键<code>:wq!</code>直接会在左下角写入</p>
<p><img src="/2018/08/29/ssm/fastdfs/6.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:wq!</span><br><span class="line"></span><br><span class="line">[root@localhost fdfs]# mkdir -p /fastdfs/tracker</span><br></pre></td></tr></table></figure>

<p>启动tracker：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost fdfs]# /etc/init.d/fdfs_trackerd start</span><br></pre></td></tr></table></figure>

<br>

<h3 id="配置storage"><a href="#配置storage" class="headerlink" title="配置storage"></a>配置storage</h3><p>进入<code>/etc/fdfs</code>目录，赋值一份<code>storage.conf.sample</code>并命名为<code>storage.conf</code>，并修改<code>storage.conf</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost fdfs]# cp storage.conf.sample storage.conf</span><br><span class="line">[root@localhost fdfs]# vi storage.conf</span><br></pre></td></tr></table></figure>

<p>修改如下几个参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">base_path=/fastdfs/storage</span><br><span class="line">store_path0=/fastdfs/storage</span><br><span class="line">tracker_server=192.168.148.131:22122  #这个IP地址是你服务器的IP，输入命令`ip addr`即可查看到服务器的IP</span><br></pre></td></tr></table></figure>

<p>保存退出并创建<code>/fastdfs/storage</code>目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:wq!</span><br><span class="line"></span><br><span class="line">[root@localhost fdfs]# mkdir /fastdfs/storage</span><br></pre></td></tr></table></figure>

<p>启动storage</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/etc/init.d/fdfs_storaged start</span><br></pre></td></tr></table></figure>

<p>查看tracker和storage是否启动成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -ef | grep fdfs</span><br></pre></td></tr></table></figure>

<p><img src="/2018/08/29/ssm/fastdfs/7.png" alt></p>
<p>出现如上的显示才证明tracker和storage都正常启动了。<br><strong>注意</strong> 这个地方要吐槽一下啦，要是你输入<code>ps -ef | grep fdfs</code>出现的不是这三行，而是两行或其他，就证明肯定有一个服务没有启动成功，一般就是你的配置有错误；<br>那么你有下面两个选择来解决这一错误情况：</p>
<blockquote>
<p>1、执行<code>/etc/init.d/fdfs_storaged stop</code>和<code>/etc/init.d/fdfs_trackerd stop</code>关闭服务，然后先启动tracker服务再执行storage服务，一般就可以解决<br>2、如果上面的办法还是不行，就重新安装FastDFS（从新直接编译方法即可）；其次还要重新删除<code>tracker.conf</code>和<code>storage.conf</code>重新配置；最后再重新启动服务（尽量重启一下服务器）</p>
</blockquote>
<p>如上我们就完成了FastDFS的配置。</p>
<br>

<h3 id="测试文件上传"><a href="#测试文件上传" class="headerlink" title="测试文件上传"></a>测试文件上传</h3><p>进入<code>/etc/fdfs</code>目录并复制一份<code>client.conf.sample</code>并命名为<code>client.conf</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost fdfs]# cp client.conf.sample client.conf</span><br><span class="line">[root@localhost fdfs]# vi client.conf</span><br></pre></td></tr></table></figure>

<p>编辑下列两项内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">base_path=/fastdfs/tracker  </span><br><span class="line">tracker_server=192.168.148.131:22122  #这个IP地址是你服务器的IP地址，输入命令`ip addr`即可查看到。不要盲目复制</span><br></pre></td></tr></table></figure>

<p><img src="/2018/08/29/ssm/fastdfs/8.png" alt></p>
<p>下面使用<code>fdfs_upload_file</code>脚本进行文件上传操作。先创建测试文件，输入命令<code>vi test.txt</code>，回车后点击<code>i</code>键进入编辑模式，输入<code>Hello TyCoding!</code>，点击<code>ESC</code>键，输入<code>:wq!</code>保存并退出，通过</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vi test.txt</span><br><span class="line">Hello TyCoding!</span><br><span class="line"></span><br><span class="line">/usr/bin/fdfs_upload_file /etc/fdfs/client.conf ~/test.txt</span><br></pre></td></tr></table></figure>

<p>如果出现类似下面的返回地址证明上传成功</p>
<p><img src="/2018/08/29/ssm/fastdfs/9.png" alt></p>
<br>

<h3 id="FastDFS与Nginx结合"><a href="#FastDFS与Nginx结合" class="headerlink" title="FastDFS与Nginx结合"></a>FastDFS与Nginx结合</h3><p>解压<code>nginx-1.6.2.tar.gz</code>到<code>/usr/local</code>目录下；解压<code>fastdfs-nginx-module_v1.16.tar.gz</code>到<code>/usr/local</code>目录下，编译和安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# cd ~/software</span><br><span class="line">[root@localhost software]# tar -zxvf nginx-1.6.2.tar.gz -C /usr/local/ </span><br><span class="line">[root@localhost software]# tar -zxvf fastdfs-nginx-module_v1.16.tar.gz -C /usr/local/fast/</span><br></pre></td></tr></table></figure>

<p>进入<code>/usr/local/fast/fastdfs-nginx-module/src/</code>目录下，修改其中的<code>config</code>文件，把其中第四行的<code>usr/local/include</code>都改为<code>/usr/include</code></p>
<p><img src="/2018/08/29/ssm/fastdfs/10.png" alt></p>
<br>

<h4 id="编译nginx"><a href="#编译nginx" class="headerlink" title="编译nginx"></a>编译nginx</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost src]# cd /usr/local/ &amp;&amp; ll</span><br><span class="line">[root@localhost local]# cd nginx-1.6.2 &amp;&amp; ./configure --prefix=/usr/local/nginx --add-module=../fast/fastdfs-nginx-module/src/</span><br></pre></td></tr></table></figure>

<p>正常情况下，会显示如下信息证明编译成功，因为这里需要为nginx添加<code>fastdfs-nginx-module</code>模块，和平常安装的nginx是不同的，如果不显示如下页面就重新进行编译</p>
<p><img src="/2018/08/29/ssm/fastdfs/11.png" alt></p>
<p>安装，并copy <code>/usr/local/fast/fastdfs-nginx-module/src/mod_fastdfs.conf</code> 到<code>/etc/fdfs</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost nginx-1.6.2]# make &amp;&amp; make install </span><br><span class="line">[root@localhost nginx-1.6.2]# cd /usr/local/fast/fastdfs-nginx-module/src/</span><br><span class="line">[root@localhost src]# cp /usr/local/fast/fastdfs-nginx-module/src/mod_fastdfs.conf /etc/fdfs/</span><br><span class="line">[root@localhost src]# cd /etc/fdfs &amp;&amp; ll</span><br><span class="line">[root@localhost fdfs]# vi mod_fastdfs.conf</span><br></pre></td></tr></table></figure>

<p>修改如下部分</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">connect_timeout=10</span><br><span class="line">tracker_server=192.168.148.131:22122  #IP地址还是根据自己的服务器IP地址来定</span><br><span class="line">url_have_group_name = true</span><br><span class="line">store_path0=/fastdfs/storage</span><br></pre></td></tr></table></figure>

<p>赋值FastDFS里的2个文件，到<code>/etc/fdfs</code>目录中，创建一个软连接，在<code>/fastdfs/storage</code>文件储存目录下创建软连接，将其连接到实际存放数据的目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost fdfs]# cd /usr/local/fast/FastDFS/conf/ &amp;&amp; ll</span><br><span class="line">[root@localhost conf]# cp http.conf mime.types /etc/fdfs/ </span><br><span class="line">[root@localhost conf]# ln -s /fastdfs/storage/data/ /fastdfs/storage/data/M00</span><br></pre></td></tr></table></figure>

<p>修改nginx的配置文件<code>nginx-conf</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost conf]# cd /usr/local/nginx/conf &amp;&amp; ll</span><br><span class="line">[root@localhost conf]# vi nginx.conf</span><br></pre></td></tr></table></figure>

<p>修改如下部分</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location ~/group([0-9])/M00 &#123;</span><br><span class="line">  ngx_fastdfs_module;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2018/08/29/ssm/fastdfs/12.png" alt></p>
<p>启动nginx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost conf]# /usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure>

<p><img src="/2018/08/29/ssm/fastdfs/13.png" alt></p>
<p>如果出现以上显示证明nginx启动成功，否者的话启动失败，要重新编译安装nginx，一般都是<code>fastdfs-nginx-module</code>模块注入到nginx失败。</p>
<p>以上我们已经完成了全部的配置，测试各个端口的启动情况，输入<code>netstat -ntlp</code>，可以看到如下信息：</p>
<p><img src="/2018/08/29/ssm/fastdfs/14.png" alt></p>
<p>出现上述信息证明各个配置都正常</p>
<br>

<h3 id="通过http的方式访问上传文件"><a href="#通过http的方式访问上传文件" class="headerlink" title="通过http的方式访问上传文件"></a>通过http的方式访问上传文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost conf]# /usr/bin/fdfs_upload_file /etc/fdfs/client.conf ~/test.txt</span><br></pre></td></tr></table></figure>

<p><img src="/2018/08/29/ssm/fastdfs/15.png" alt></p>
<p><img src="/2018/08/29/ssm/fastdfs/16.png" alt></p>
<br>

<h3 id="设置服务开机自启动"><a href="#设置服务开机自启动" class="headerlink" title="设置服务开机自启动"></a>设置服务开机自启动</h3><p>经过上面的环境配置，我们一共需要启动三个服务才能实现最终的效果，那么每次启动服务器都手动去启动这些服务未免显得太过于麻烦了，所以我们配置这些服务开机自启动即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]#  vi /etc/rc.d/rc.local</span><br></pre></td></tr></table></figure>

<p>向其中添加需要开机自启动服务的脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/etc/init.d/fdfs_trackerd start</span><br><span class="line">/etc/init.d/fdfs_storaged start</span><br><span class="line">/usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure>

<p><img src="/2018/08/29/ssm/fastdfs/17.png" alt></p>
<p>其次，我们还要给<code>rc.local</code>文件赋予权限才能实现开机自启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# chmod +x /etc/rc.d/rc.local</span><br></pre></td></tr></table></figure>

<p><img src="/2018/08/29/ssm/fastdfs/18.png" alt></p>
<p>输入命令<code>reboot</code>重启服务器，再输入<code>netstat -ntlp</code>查看当前启动的服务，可以看到<code>storage</code>, <code>tracker</code>, <code>nginx</code>三个服务都自启动了。</p>
<p><img src="/2018/08/29/ssm/fastdfs/19.png" alt></p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><blockquote>
<p>参考文章：<a href="https://qq52o.me/2077.html" target="_blank" rel="noopener">https://qq52o.me/2077.html</a><br>  我也是根据上述文章中的介绍搭建的系统，但是并没有成功，于是我改变了其中的一些步骤（命令行），参看了网上其他的文章，最终成功搭建！</p>
</blockquote>
<ul>
<li><p>教程中使用的系统版本是CentOS7</p>
</li>
<li><p>如果你在配置tracker和storage完成后启动服务，两个服务并没有都启动，请先执行<code>xxx stop</code>的命令关闭服务，然后按照先启动tracker再启动storage的顺序启动服务；如果还是没有启动成功，最好重新安装FastDFS（直接重新执行命令即可），重新配置相关的文件，然后重启服务器，再重启服务，一般就解决了。</p>
</li>
<li><p>如果你在安装nginx时添加<code>fastdfs-nginx-module</code>模块时出现<code>error</code>，请重新编译nginx，重新配置相关的文件，一般就能解决了。</p>
</li>
</ul>
<p>最后祝愿大家都能成功的搭建FastDFS系统。</p>
<br>

<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue+ElementUI+SpringMVC实现图片上传和回显</title>
    <url>/2018/08/05/vue/vue-7/</url>
    <content><![CDATA[<p>Vue+ElementUI+SpringMVC实现图片上传和table回显</p>
<p>在之前我们已经讲过了 <a href="http://tycoding.cn/2018/07/30/vue-6/#more" target="_blank" rel="noopener">Vue+ElementUI+SpringMVC实现分页</a> 。</p>
<p>而我们也常遇到表单中包含图片上传的需求，并且需要在table中显示图片，所以这里我就讲一下结合后端的SpringMVC框架如何实现图片上传并提交到表单中，在table表格中回显照片。</p>
<p>本案例对应的<strong>开源项目地址</strong>请看我的GitHub仓库：</p>
<ul>
<li><p><a href="https://github.com/TyCoding/spring-boot" target="_blank" rel="noopener">优雅的入门SpringBoot+Mybatis，实现简单的CRUD </a></p>
</li>
<li><p><a href="https://github.com/TyCoding/ssm-redis-solr" target="_blank" rel="noopener">优雅的实现电商项目中搜索功能，整合SSM+Redis+Shiro+Solr框架，教你使用Vue+ElementUI写一个炫酷的后端页面 </a></p>
</li>
</ul>
<a id="more"></a>

<br>

<p><strong>写在前面</strong></p>
<p>本篇博文主要讲Vue.js+ElementUI如何实现图片上传和提交表单，前端技术会讲多一点，因此：</p>
<ul>
<li>如果你对SpringMVC文件上传和下载不是很清楚，请查看我这篇博文： <a href="http://tycoding.cn/2018/05/31/Spring-6/#more" target="_blank" rel="noopener">SpringMVC实现文件上传和下载</a></li>
<li>因为案例基于SSM框架，如果你你对SSM框架不是很清楚，请查看我这篇博文：<a href="http://tycoding.cn/2018/06/05/ssm-2/#more" target="_blank" rel="noopener">SSM框架整合</a>  <a href="https://github.com/TyCoding/ssm" target="_blank" rel="noopener">GitHub</a></li>
</ul>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p><strong>首先</strong>，请一定阅读一下我的 <a href="http://tycoding.cn/2018/05/31/Spring-6/" target="_blank" rel="noopener">SpringMVC实现文件上传和下载</a> 本篇博文将不在详细讲这部分内容。</p>
<p><strong>前端：</strong></p>
<blockquote>
<p>你会用到以下技术：</p>
<p>Vue.js</p>
<p>Vue-resource.js</p>
<p>ElementUI</p>
</blockquote>
<p>我们将实现的效果是什么呢？</p>
<p><em>图片上传：</em></p>
<p><img src="/2018/08/05/vue/vue-7/1.png" alt></p>
<p><em>table展示：</em></p>
<p><img src="/2018/08/05/vue/vue-7/2.png" alt></p>
<h1 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h1><p>想要实现图片上传和table的回显，让我们先分析以下实现思路：</p>
<h2 id="图片上传和表单提交"><a href="#图片上传和表单提交" class="headerlink" title="图片上传和表单提交"></a>图片上传和表单提交</h2><p>那么你就要明白图片上传和表单提交是两个功能，其对应不同的接口，表单中并不是保存了这个图片，而仅仅是保存了储存图片的路径地址。我们需要分析以下几点：</p>
<p><strong>1、图片如何上传，什么时候上传？</strong></p>
<p>图片应该在点击upload上传组件的时候就触发了对应的事件，当选择了要上传的图片，点击确定的时候就请求了后端的接口保存了图片。也就是说你在浏览器中弹出的选择框中选择了要上传的图片，当你点击确定的一瞬间就已将图片保存到了服务器上；而再点击提交表单的时候，储存在表单中的图片数据仅仅是刚才上传的图片存储地址。</p>
<p><strong>2、如何获取到已经上传的图片的储存地址？</strong></p>
<p>因为在浏览器上传选择框被确定选择的瞬间已经请求了后端接口保存了图片，我们该怎么知道图片在哪里储存呢？</p>
<ul>
<li><strong>前端：</strong> 比如我们使用了ElementUI提供的上传组件，其就存在一个上传成功的回调函数：<code>on-success</code>，这个回调函数被触发的时间点就是图片成功上传后的瞬间，我们就是要在这个回调函数触发的时候获取到图片储存的地址。</li>
<li><strong>后端：</strong> 上面讲了获取地址，这个<strong>地址</strong>就是后端返回给前端的数据（JSON格式）。因为后端图片上传接口配置图片储存的地址，如果图片上传成功，就将图片储存的地址以JSON格式返回给前端。</li>
</ul>
<p><strong>3、如何提交表单</strong></p>
<p>说如何提交表单，这就显得很简单了，因为上面我们已经完成了：1、图片成功上传；2、获取到了图片在服务器上的储存地址。利用Vue的双向绑定思想，在图片成功上传的回调函数<code>on-success</code>中获取到后端返回的图片储存地址，将这个地址赋值给Vue实例<code>data(){}</code>中定义的表单对象。这样在提交表单的时候仅需要将这个表单对象发送给后端，保存到数据库就行了。</p>
<h2 id="图片在table的回显"><a href="#图片在table的回显" class="headerlink" title="图片在table的回显"></a>图片在table的回显</h2><p>想要将图片回显到table表格中其实很简单，前提只要你在数据库中保存了正确的图片储存地址；在table表格中我们仅需要在<code>&lt;td&gt;</code>列中新定义一列<code>&lt;td&gt;&lt;img src=&quot;图片的地址&quot;/&gt;&lt;/td&gt;</code>即可完成图片回显。渲染table数据的时候循环给<code>&lt;img&gt;</code>中的<code>src</code>赋值数据库中保存的图片url即可。</p>
<br>

<h1 id="后端实现"><a href="#后端实现" class="headerlink" title="后端实现"></a>后端实现</h1><br>

<h2 id="图片上传接口"><a href="#图片上传接口" class="headerlink" title="图片上传接口"></a>图片上传接口</h2><p><strong>注意：</strong> 关于SpringMVC如何实现文件上传和下载，请看我的博文： <a href="http://tycoding.cn/2018/05/31/Spring-6/" target="_blank" rel="noopener">SpringMVC实现文件上传和下载</a> 。这里我给出代码，就不再解释了(#^.^#)：</p>
<p>这里我将文件上传和下载接口单独抽离在一个Controller类中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.instrument.entity.Result;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UploadDownController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件上传</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> picture</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/upload"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">upload</span><span class="params">(@RequestParam(<span class="string">"picture"</span>)</span> MultipartFile picture, HttpServletRequest request) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取文件在服务器的储存位置</span></span><br><span class="line">        String path = request.getSession().getServletContext().getRealPath(<span class="string">"/upload"</span>);</span><br><span class="line">        File filePath = <span class="keyword">new</span> File(path);</span><br><span class="line">        System.out.println(<span class="string">"文件的保存路径："</span> + path);</span><br><span class="line">        <span class="keyword">if</span> (!filePath.exists() &amp;&amp; !filePath.isDirectory()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"目录不存在，创建目录:"</span> + filePath);</span><br><span class="line">            filePath.mkdir();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取原始文件名称(包含格式)</span></span><br><span class="line">        String originalFileName = picture.getOriginalFilename();</span><br><span class="line">        System.out.println(<span class="string">"原始文件名称："</span> + originalFileName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取文件类型，以最后一个`.`为标识</span></span><br><span class="line">        String type = originalFileName.substring(originalFileName.lastIndexOf(<span class="string">"."</span>) + <span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"文件类型："</span> + type);</span><br><span class="line">        <span class="comment">//获取文件名称（不包含格式）</span></span><br><span class="line">        String name = originalFileName.substring(<span class="number">0</span>, originalFileName.lastIndexOf(<span class="string">"."</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置文件新名称: 当前时间+文件名称（不包含格式）</span></span><br><span class="line">        Date d = <span class="keyword">new</span> Date();</span><br><span class="line">        SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMddHHmmss"</span>);</span><br><span class="line">        String date = sdf.format(d);</span><br><span class="line">        String fileName = date + name + <span class="string">"."</span> + type;</span><br><span class="line">        System.out.println(<span class="string">"新文件名称："</span> + fileName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在指定路径下创建一个文件</span></span><br><span class="line">        File targetFile = <span class="keyword">new</span> File(path, fileName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将文件保存到服务器指定位置</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            picture.transferTo(targetFile);</span><br><span class="line">            System.out.println(<span class="string">"上传成功"</span>);</span><br><span class="line">            <span class="comment">//将文件在服务器的存储路径返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="keyword">true</span>,<span class="string">"/upload/"</span> + fileName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"上传失败"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="keyword">false</span>, <span class="string">"上传失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么返回一个Result数据类型？</strong></p>
<p>注意这个<code>Result</code>是我自己声明的一个实体类，用于封装返回的结果信息，配合<code>@RestController</code>注解实现将封装的信息以JSON格式return给前端，最后看下我定义的<code>Result</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Result</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断结果</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> success;</span><br><span class="line">    <span class="comment">//返回信息</span></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Result</span><span class="params">(<span class="keyword">boolean</span> success, String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.success = success;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSuccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> success;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    setter/getter...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="表单提交接口"><a href="#表单提交接口" class="headerlink" title="表单提交接口"></a>表单提交接口</h2><p>表单提交大家都比较熟悉了，配合图片上传，仅仅是在实体类中多了一个字段存放图片的URL地址：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/instrument"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstrumentController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注入</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> InstrumentService instrumentService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> instrument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/save"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">save</span><span class="params">(Instrument instrument)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instrument != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                instrumentService.save(instrument);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="keyword">true</span>,<span class="string">"添加成功"</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="keyword">false</span>, <span class="string">"发生未知错误"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如上</strong></p>
<p>大家可能会疑惑这个为什么返回Result类型的数据？ 答：为了前端方便判断接口执行成功与否。因为我前端使用的是<strong>HTML页面</strong>，想要从后端域对象中取数据显然就有点不现实了。</p>
<p>我写Controller的时候定义了全局的<code>@RestController</code>注解，和<code>@Controller</code>注解的区别是，前者多了<code>@ResponseBody</code>注解，这样整合Controller类返回的数据都将给自动转换成JSON格式。</p>
<br>

<h1 id="前端实现"><a href="#前端实现" class="headerlink" title="前端实现"></a>前端实现</h1><br>

<h2 id="实现图片上传"><a href="#实现图片上传" class="headerlink" title="实现图片上传"></a>实现图片上传</h2><p>这里我使用了ElementUI的文件上传组件： <a href="http://element-cn.eleme.io/#/zh-CN/component/upload" target="_blank" rel="noopener">官方文档</a> </p>
<p>配合ElementUI的上传组件，我们会这样定义(这是form表单中的一部分)：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">label</span>=<span class="string">"图片"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-upload</span></span></span><br><span class="line"><span class="tag">               <span class="attr">ref</span>=<span class="string">"upload"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">action</span>=<span class="string">"/upload.do"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">name</span>=<span class="string">"picture"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">list-type</span>=<span class="string">"picture-card"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">:limit</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">:file-list</span>=<span class="string">"fileList"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">:on-exceed</span>=<span class="string">"onExceed"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">:before-upload</span>=<span class="string">"beforeUpload"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">:on-preview</span>=<span class="string">"handlePreview"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">:on-success</span>=<span class="string">"handleSuccess"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">:on-remove</span>=<span class="string">"handleRemove"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"el-icon-plus"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-upload</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-dialog</span> <span class="attr">:visible.sync</span>=<span class="string">"dialogVisible"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">width</span>=<span class="string">"100%"</span> <span class="attr">:src</span>=<span class="string">"dialogImageUrl"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-dialog</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意，我这里仅展示了文件上传的<code>form-item</code>，ElementUI的表单声明是：<code>&lt;el-form&gt;</code> <strong>注意</strong> 表单中不需要指定<code>enctype=&quot;multipart/form-data&quot;</code>这个参数，与我们普通的文件上传表单是不同的。</p>
<p>了解几个参数：</p>
<ul>
<li><strong>ref</strong> <code>ref</code>是Vue原生参数，用来给组件注册引用信息。引用信息将会注册到父组件的<code>$refs</code>对象上，如果定义在普通的DOM元素上，那么<code>$refs</code>指向的就是DOM元素。</li>
</ul>
<ul>
<li><strong>action</strong> <code>action</code>表示此上传组件对应的上传接口，此时我们使用的是后端Controller定义的接口</li>
</ul>
<ul>
<li><strong>name</strong> <code>name</code>表示当前组件上传的文件字段名，需要和后端的上传接口字段名相同 。</li>
</ul>
<ul>
<li><strong>list-type</strong> 文件列表的类型，主要是文件列表的样式定义。这里是卡片化。</li>
</ul>
<ul>
<li><strong>:limit</strong> 最大允许上传的文件个数。</li>
</ul>
<ul>
<li><strong>file-list</strong> 上传的文件列表，这个参数用于在这个上传组件中回显图片，包含两个参数：<code>name、url</code>如果你想在这个文件上传组件中咱叔图片，赋值对应的参数即可显示，比如更新数据时，其表单样式完全和添加表单是相同的。但是table中回显图片是完全不需要用这个方式的。</li>
</ul>
<ul>
<li><strong>:on-exceed</strong> 上传文件超出个数时的钩子函数。</li>
</ul>
<ul>
<li><strong>:before-upload</strong> 上传文件前的钩子函数，参数为上传的文件，返回false，就停止上传。</li>
</ul>
<ul>
<li><strong>:on-preview</strong> 点击文件列表中已上传的文件时的钩子函数</li>
</ul>
<ul>
<li><strong>:on-success</strong> 文件上传成功的钩子函数</li>
</ul>
<ul>
<li><strong>:on-remove</strong> 文件列表移除时的钩子函数</li>
</ul>
<ul>
<li><strong>:src</strong> 图片上传的URL。</li>
</ul>
<p><strong>JS部分</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置全局表单提交格式</span></span><br><span class="line">Vue.http.options.emulateJSON = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    data()&#123;</span><br><span class="line">        <span class="keyword">return</span>&#123;</span><br><span class="line">            <span class="comment">//文件上传的参数</span></span><br><span class="line">            dialogImageUrl: <span class="string">''</span>,</span><br><span class="line">            dialogVisible: <span class="literal">false</span>,</span><br><span class="line">            <span class="comment">//图片列表（用于在上传组件中回显图片）</span></span><br><span class="line">            fileList: [&#123;<span class="attr">name</span>: <span class="string">''</span>, <span class="attr">url</span>: <span class="string">''</span>&#125;],</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods()&#123;</span><br><span class="line">   		<span class="comment">//文件上传成功的钩子函数</span></span><br><span class="line">        handleSuccess(res, file) &#123;</span><br><span class="line">            <span class="keyword">this</span>.$message(&#123;</span><br><span class="line">                type: <span class="string">'info'</span>,</span><br><span class="line">                message: <span class="string">'图片上传成功'</span>,</span><br><span class="line">                duration: <span class="number">6000</span></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">if</span> (file.response.success) &#123;</span><br><span class="line">                <span class="keyword">this</span>.editor.picture = file.response.message; <span class="comment">//将返回的文件储存路径赋值picture字段</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//删除文件之前的钩子函数</span></span><br><span class="line">        handleRemove(file, fileList) &#123;</span><br><span class="line">            <span class="keyword">this</span>.$message(&#123;</span><br><span class="line">                type: <span class="string">'info'</span>,</span><br><span class="line">                message: <span class="string">'已删除原有图片'</span>,</span><br><span class="line">                duration: <span class="number">6000</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//点击列表中已上传的文件事的钩子函数</span></span><br><span class="line">        handlePreview(file) &#123;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//上传的文件个数超出设定时触发的函数</span></span><br><span class="line">        onExceed(files, fileList) &#123;</span><br><span class="line">            <span class="keyword">this</span>.$message(&#123;</span><br><span class="line">                type: <span class="string">'info'</span>,</span><br><span class="line">                message: <span class="string">'最多只能上传一个图片'</span>,</span><br><span class="line">                duration: <span class="number">6000</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//文件上传前的前的钩子函数</span></span><br><span class="line">        <span class="comment">//参数是上传的文件，若返回false，或返回Primary且被reject，则停止上传</span></span><br><span class="line">        beforeUpload(file) &#123;</span><br><span class="line">            <span class="keyword">const</span> isJPG = file.type === <span class="string">'image/jpeg'</span>;</span><br><span class="line">            <span class="keyword">const</span> isGIF = file.type === <span class="string">'image/gif'</span>;</span><br><span class="line">            <span class="keyword">const</span> isPNG = file.type === <span class="string">'image/png'</span>;</span><br><span class="line">            <span class="keyword">const</span> isBMP = file.type === <span class="string">'image/bmp'</span>;</span><br><span class="line">            <span class="keyword">const</span> isLt2M = file.size / <span class="number">1024</span> / <span class="number">1024</span> &lt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!isJPG &amp;&amp; !isGIF &amp;&amp; !isPNG &amp;&amp; !isBMP) &#123;</span><br><span class="line">                <span class="keyword">this</span>.$message.error(<span class="string">'上传图片必须是JPG/GIF/PNG/BMP 格式!'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!isLt2M) &#123;</span><br><span class="line">                <span class="keyword">this</span>.$message.error(<span class="string">'上传图片大小不能超过 2MB!'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (isJPG || isBMP || isGIF || isPNG) &amp;&amp; isLt2M;</span><br><span class="line">        &#125;,     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong></p>
<p>如上的JS代码，主要是定义一些钩子函数，这里我么里梳理一下逻辑：</p>
<p>1、点击ElementUI的上传组件，浏览器自动弹出文件上传选择窗口，我们选择要上传的图片。</p>
<p>2、选择好了要上传的图片，点击弹窗右下角的确定按钮触发JS中定义的钩子函数。</p>
<p>3、首先触发的钩子函数是<code>beforeUpload(file)</code>函数，其中的参数<code>file</code>即代表当前上传的文件对象，<code>beforeUpload()</code>定义了对上传文件格式校验。如果不是允许的格式就弹出错误信息，并阻止文件上传，若我那件格式允许，则继续执行。</p>
<p>4、通过了<code>beforeUpload()</code>函数的校验，文件开始调用后端接口将数据发送给后端。文件的字段名：<code>picture</code>，格式：<code>multipart/form-data</code>，虽然我们的表单没有定义<code>enctype=&quot;multipart/form-data&quot;</code>属性，但是HTTP请求头会自动设置为<code>multipart/form-data</code>类型。</p>
<p><img src="/2018/08/05/vue/vue-7/3.png" alt></p>
<p>5、这时，如果后端逻辑没有错误，已经正常的将图片上传到服务器上了，可以在指定文件夹中查看到已上传的图片，那么此时JS中会自动调用<code>handleSuccess()</code>钩子函数，因为我们设置后端上传接口上传成功返回的数据是文件的保存路径：</p>
<p><img src="/2018/08/05/vue/vue-7/4.png" alt></p>
<p>那我们就将这个路径通过Vue的双向绑定，赋值给表单对象的字段<code>picture</code>，那么提交表单的时候，该字段对应的值就是这个路径了。</p>
<p>6、如果我们再点击上传文件按钮，就会触发<code>onExceed()</code>函数，因为我们设置的<code>limit</code>最多上传一个。</p>
<p>7、如果点击图片中的删除按钮，就会触发<code>handleRemove()</code>函数，并删除此图片。</p>
<p>8、如果点击了已上传的文件列表，就会触发<code>handlePreview()</code>函数。</p>
<h2 id="实现表单提交"><a href="#实现表单提交" class="headerlink" title="实现表单提交"></a>实现表单提交</h2><p>表单提交就比较简单了，就是触发对应的click事件，触发其中定义的函数，将已在<code>data(){}</code>中定义的表单数据发送给后端接口：</p>
<p><img src="/2018/08/05/vue/vue-7/5.png" alt></p>
<p>提交数据：</p>
<p><img src="/2018/08/05/vue/vue-7/6.png" alt></p>
<p><strong>后端接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/save"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">save</span><span class="params">(Instrument instrument)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(instrument != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            instrumentService.save(instrument);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="keyword">true</span>,<span class="string">"添加成功"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="keyword">false</span>, <span class="string">"发生未知错误"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数据库中保存的数据：</p>
<p><img src="/2018/08/05/vue/vue-7/7.png" alt></p>
<br>

<h1 id="实现table回显图片"><a href="#实现table回显图片" class="headerlink" title="实现table回显图片"></a>实现table回显图片</h1><p>table回显图片也是很简单的，仅需要在列中增加一列：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-table</span> <span class="attr">:data</span>=<span class="string">"instrument"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">label</span>=<span class="string">"图片"</span> <span class="attr">width</span>=<span class="string">"130"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">scope</span>=<span class="string">"scope"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">"scope.row.picture"</span> <span class="attr">class</span>=<span class="string">"picture"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-table-column</span></span></span><br><span class="line"><span class="tag">         <span class="attr">label</span>=<span class="string">"运行状态"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">width</span>=<span class="string">"80"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">prop</span>=<span class="string">"operatingStatus"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>因为使用Vue，根据其双向绑定的思想，再结合Element-UI提供渲染表格的方式是在<code>&lt;el-table&gt;</code>的<code>:data</code>中指定对应要渲染的数据即可。</p>
<p><strong>注意</strong> ElementUI渲染table的方式是：1、<code>&lt;el-table&gt;</code>中定义<code>:data</code>；2、<code>&lt;el-table-column&gt;</code>中定义<code>prop=&quot;data中的参数&quot;</code>。但是因为我们要显示的是图片而不是文本数据，所以要在<code>&lt;img&gt;</code>中定义<code>:src=&quot;data中的变量&quot;</code>即可实现渲染。</p>
<br>

<p><strong>后端</strong>就是正常的查询数据库数据即可了，为什么数据库中保存了这个URL图片就能直接显示到HTML中，请看我这篇博文： <a href="http://tycoding.cn/2018/05/31/Spring-6/" target="_blank" rel="noopener">SpringMVC实现文件上传和下载</a> </p>
<br>

<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue+ElementUI+SpringMVC实现分页</title>
    <url>/2018/07/30/vue/vue-6/</url>
    <content><![CDATA[<h1 id="Vue-ElementUI-SpringMVC实现分页"><a href="#Vue-ElementUI-SpringMVC实现分页" class="headerlink" title="Vue + ElementUI + SpringMVC实现分页"></a>Vue + ElementUI + SpringMVC实现分页</h1><p>这一段时间写项目用到了Vue+ElementUI，这里记录一下使用ElementUI内置分页插件结合后端SSM框架的实现思路和实现过程。</p>
<p>其中遇到了很多坑，我会尽量把见到的坑都记录下来，希望对你有所帮助。</p>
<p>本案例对应的<strong>开源项目地址</strong>请看我的GitHub仓库：</p>
<ul>
<li><p><a href="https://github.com/TyCoding/spring-boot" target="_blank" rel="noopener">优雅的入门SpringBoot+Mybatis，实现简单的CRUD </a></p>
</li>
<li><p><a href="https://github.com/TyCoding/ssm-redis-solr" target="_blank" rel="noopener">优雅的实现电商项目中搜索功能，整合SSM+Redis+Shiro+Solr框架，教你使用Vue+ElementUI写一个炫酷的后端页面 </a></p>
</li>
</ul>
<a id="more"></a>

<p><strong>首先</strong> 让我们看一下最终效果：</p>
<p><img src="/2018/07/30/vue/vue-6/1.png" alt></p>
<h1 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h1><p>本博文的主要讲一下Vue+ElementUI结合后端SpringMVC实现分页的实现思路，基本的elementUI用法请自行百度；</p>
<p>Vue的常用语法可以看我的 <a href="http://tycoding.cn/2018/07/25/vue-4/#more" target="_blank" rel="noopener">博文</a> 。</p>
<p>关于SSM的整合教程可以看我的这篇 <a href="http://tycoding.cn/2018/06/05/ssm-2/#more" target="_blank" rel="noopener">博文</a>； <a href="https://github.com/TyCoding/ssm" target="_blank" rel="noopener">GitHub</a>。</p>
<br>

<p><strong>介绍</strong></p>
<p>本案例中设计到的技术栈：</p>
<ul>
<li><p><a href="http://element-cn.eleme.io/#/zh-CN" target="_blank" rel="noopener">ElementUI</a></p>
</li>
<li><p><a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="noopener">Vue.js</a></p>
</li>
<li><p><a href="https://www.npmjs.com/package/vue-resource" target="_blank" rel="noopener">vue-resource.js</a></p>
</li>
<li><p><a href="http://tycoding.cn/2018/06/05/ssm-2/#more" target="_blank" rel="noopener">SSM框架</a></p>
</li>
<li><p>PageHelper: Mybatis的分页插件</p>
</li>
</ul>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>1、SSM框架的整合教程可以参考我的这篇博文：<a href="http://tycoding.cn/2018/06/05/ssm-2/#more" target="_blank" rel="noopener">手摸手带你整合SSM框架</a>; <a href="https://github.com/TyCoding/ssm" target="_blank" rel="noopener">GitHub</a>。</p>
<p>2、在后端项目中导入<code>PageHelper.jar</code>的依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.0.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p><strong>***注意</strong><br>使用PageHelper分页插件除了要导入依赖，还需要在Mybatis配置文件中进行相关配置，并交给Spring进行管理。如下配置即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;plugins&gt;</span><br><span class="line">    &lt;!-- com.github.pagehelper 为 PageHelper 类所在包名 --&gt;</span><br><span class="line">    &lt;plugin interceptor=&quot;com.github.pagehelper.PageHelper&quot;&gt;</span><br><span class="line">        &lt;!-- 设置数据库类型 Oracle,Mysql,MariaDB,SQLite,Hsqldb,PostgreSQL 六种数据库--&gt;</span><br><span class="line">        &lt;property name=&quot;dialect&quot; value=&quot;mysql&quot;/&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br></pre></td></tr></table></figure>

<p>这里还要注意的是PageHelper5.X版本和PageHelper4.X版本PageHelper类所在的包名是不同的。<br>在Spring配置文件中扫描此配置文件即可：<br><img src="/2018/07/30/vue/vue-6/3.png" alt></p>
<p>3、在HTML中导入<code>vue.js</code> and <code>element-ui</code> 。</p>
<p>好的，至此，我们把基本的环境已经讲过了，下面看下相关前端代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 列表 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-table</span></span></span><br><span class="line"><span class="tag">        <span class="attr">ref</span>=<span class="string">"user"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">:data</span>=<span class="string">"user"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tooltip-effect</span>=<span class="string">"dark"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">style</span>=<span class="string">"width: 100%"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-table-column</span></span></span><br><span class="line"><span class="tag">            <span class="attr">prop</span>=<span class="string">"id"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">sortable</span></span></span><br><span class="line"><span class="tag">            <span class="attr">label</span>=<span class="string">"编号"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">width</span>=<span class="string">"80"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-table-column</span></span></span><br><span class="line"><span class="tag">            <span class="attr">prop</span>=<span class="string">"username"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">sortable</span></span></span><br><span class="line"><span class="tag">            <span class="attr">label</span>=<span class="string">"联系人"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">width</span>=<span class="string">"120"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-table-column</span></span></span><br><span class="line"><span class="tag">            <span class="attr">prop</span>=<span class="string">"phone"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">sortable</span></span></span><br><span class="line"><span class="tag">            <span class="attr">label</span>=<span class="string">"联系电话"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">width</span>=<span class="string">"120"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-table-column</span></span></span><br><span class="line"><span class="tag">            <span class="attr">prop</span>=<span class="string">"mailbox"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">label</span>=<span class="string">"电子邮箱"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">width</span>=<span class="string">"150"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-table-column</span></span></span><br><span class="line"><span class="tag">            <span class="attr">prop</span>=<span class="string">"postalCode"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">sortable</span></span></span><br><span class="line"><span class="tag">            <span class="attr">label</span>=<span class="string">"邮政编码"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">width</span>=<span class="string">"120"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-table-column</span></span></span><br><span class="line"><span class="tag">            <span class="attr">prop</span>=<span class="string">"date"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">sortable</span></span></span><br><span class="line"><span class="tag">            <span class="attr">label</span>=<span class="string">"注册时间"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">width</span>=<span class="string">"200"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-table-column</span></span></span><br><span class="line"><span class="tag">            <span class="attr">prop</span>=<span class="string">"address"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">label</span>=<span class="string">"通讯地址"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">width</span>=<span class="string">"200"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">show-overflow-tooltip</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-table</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 分页 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pagination"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-pagination</span></span></span><br><span class="line"><span class="tag">            <span class="attr">background</span></span></span><br><span class="line"><span class="tag">            @<span class="attr">size-change</span>=<span class="string">"handleSizeChange"</span></span></span><br><span class="line"><span class="tag">            @<span class="attr">current-change</span>=<span class="string">"handleCurrentChange"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">:current-page</span>=<span class="string">"pageConf.pageCode"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">:page-sizes</span>=<span class="string">"pageConf.pageOption"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">:page-size</span>=<span class="string">"pageConf.pageSize"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">layout</span>=<span class="string">"total, sizes, prev, pager, next, jumper"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">:total</span>=<span class="string">"pageConf.totalPage"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-pagination</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p>注意我们上面前端HTML样式用使用Vue绑定的数据：</p>
<p>1、列表数据</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//注意这部分代码是在Vue实例中的data属性中定义的</span><br><span class="line"></span><br><span class="line">data() &#123;</span><br><span class="line">	//用户信息</span><br><span class="line">    //element-ui的table需要的参数必须是Array类型的</span><br><span class="line">    user: [&#123;</span><br><span class="line">        username: '',</span><br><span class="line">        phone: '',</span><br><span class="line">        mailbox: '',</span><br><span class="line">        postalCode: '',</span><br><span class="line">        date: '',</span><br><span class="line">        address: ''</span><br><span class="line">    &#125;],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面ElementUI表格中<code>&lt;el-table&gt;</code>中用Vue绑定的<code>:data=&quot;user&quot;</code>就是这个数据，<strong>注意：</strong>这里的user对象中的数据需要是<strong>Array</strong>类型的，不要问为什么，请去看ElementUI源码；</p>
<p>2、分页数据</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//注意这部分代码是在Vue实例中的data属性中定义的</span><br><span class="line"></span><br><span class="line">data() &#123;</span><br><span class="line">	//定义分页Config</span><br><span class="line">	pageConf: &#123;</span><br><span class="line">	    //设置一些初始值(会被覆盖)</span><br><span class="line">	    pageCode: 1, //当前页</span><br><span class="line">	    pageSize: 4, //每页显示的记录数</span><br><span class="line">	    totalPage: 12, //总记录数</span><br><span class="line">	    pageOption: [4, 10, 20], //分页选项</span><br><span class="line">	    handleCurrentChange: function () &#123;</span><br><span class="line">	        console.log("页码改变了");</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">	//pageSize改变时触发的函数</span><br><span class="line">    handleSizeChange(val) &#123;&#125;,</span><br><span class="line">    //当前页改变时触发的函数</span><br><span class="line">    handleCurrentChange(val) &#123;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面<code>&lt;el-pagination&gt;</code>中绑定的数据就来自这个对象:<code>pageConf</code>，那么下面你需要关注<code>&lt;el-pagination&gt;</code>中的几个配置参数（方法通过Vue的<code>@</code>绑定，数据通过Vue的<code>:</code>绑定）：</p>
<ul>
<li><p><code>@size-change</code>: 表示每页记录的个数发生变化时触发的函数，如：原来是每页/3条，变为每页/6条；<code>handleSizeChange</code>中包含一个参数表示当前是每页显示几条记录。</p>
</li>
<li><p><code>@current-change</code>: 表示当前页发生变化时触发的函数，如：点击下一页；<code>handleCurrentChange</code>中包含一个参数表示当前是第几页。</p>
</li>
<li><p><code>:current-page</code>: 当前页，即我们命名的<code>pageCode</code>，表示当前页面上展示的第几页。</p>
</li>
<li><p><code>:page-sizes</code>: 分页选项，即页面提供一个列表让你选择每页显示多少条记录，注意这个参数的第一个值表示当前页是<code>每页/记录</code>，你写上即生效。</p>
</li>
<li><p><code>:page-size</code>: 表示每页显示的记录数，即我们命名的<code>pageSize</code>。</p>
</li>
<li><p><code>:total</code>: 表示总记录数，即我们这个表格中一共要显示多少条数据。</p>
</li>
</ul>
<br>

<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><ul>
<li><p>以上代码可能与截图中样式不符，因为我把这篇博文中不涉及的都删除了。</p>
</li>
<li><p>表格中的数据来自<code>:data</code>这个绑定的<strong>对象数组</strong>中，即我们再Vue实例data中定义的<code>user: [{}]</code>，前提是你在每一个<code>&lt;el-table-column&gt;</code>中都定义了<code>prop</code>并标识了<code>user:[{}]</code>中定义的变量，不然element-ui不知道你想在表格的这一行显示什么，当然这已经比我们常用的表格渲染数据方便很多了。</p>
</li>
<li><p>element-ui自带的分页插件需要提供数据才能正常显示分页信息，这些数据都应该是动态的，所以我们绑定在<code>pageConf</code>对象中；因为这些数据应该是后端读取出来的，即通过得到后端传来的分页数据，我们才知道这里的分页信息应该怎样定义。</p>
</li>
<li><p>在data中定义的<code>pageConf</code>是初始化参数，最后会被覆盖掉，但是要注意<code>pageOption</code>这个参数，一定要和初始的<code>pageSize</code>配合服用。</p>
</li>
<li><p>以上涉及两个函数<code>handleSizeChange</code>、<code>handleCurrentChange</code>，我们要在其触发时自动改变对应的<code>pageOption</code>参数。</p>
</li>
</ul>
<br>

<h3 id="会遇到的坑"><a href="#会遇到的坑" class="headerlink" title="会遇到的坑"></a>会遇到的坑</h3><p>1、<code>&lt;el-table&gt;</code>中需要渲染的数据仅需要传入<code>:data=&quot;user&quot;</code>即可，但是这个数据<code>user</code>必须是一个<strong>对象数组</strong>，一定是<strong>数组</strong></p>
<p>2、想要<code>&lt;el-table&gt;</code>正确渲染你<code>user</code>中定义的数据，你必须为每个<code>&lt;el-table-column&gt;</code>定义<code>prop</code>属性，绑定对应你想展示的数据，不然ElementUI不知道你想展示什么。</p>
<p>3、<code>pageOption</code>分页选项一定要注意，要配合<code>pageSize</code>的默认值，不要乱定义，比如：<code>pageSize: 2, pageOption: [10,20,30]</code>，这样你就会发现页码根本不能正确显示，因为你设置<code>pageSize:2</code>表示你想每页展示2条数据，但是你又定义<code>pageOption: [10,20,30]</code>第一个参数即是默认被选中的，即你又想每页显示10条数据，那么ElementUI就蒙蔽了，不知道你到底想每页显示几条数据。</p>
<p>3、根据上面的参数，以及<code>handleSizeChange</code>、<code>handleCurrentChange</code>这两个函数的参数你就应该想到分页的实现其实是<code>pageCode</code>(当前页)和<code>pageSize</code>(每页显示的记录数)和后端进行数据交换的。在前端你需要关心的怎样把<code>pageSize</code>和<code>pageCode</code>传给后端进行分页查询；在后端你需要关心的是怎样调用<code>pageHelper</code>插件将分页的记录数据（包括<code>totalPage</code>、<code>user</code>数据等）return 给前端。</p>
<br>

<h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><p>定义请求映射路径：<code>findByPage</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;/findByPage&quot;)</span><br><span class="line">public PageBean findByPage(@RequestParam(&quot;pageCode&quot;) int pageCode, @RequestParam(&quot;pageSize&quot;) int pageSize) &#123;</span><br><span class="line">    System.out.println(&quot;分页的数据：&quot; + userService.findByPage(pageCode, pageSize));</span><br><span class="line">    return userService.findByPage(pageCode, pageSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>如上是我们在Controller中定义的请求映射路径，其中需要接收两个参数：<code>pageCode</code>和<code>pageSize</code>分别表示当前页、每页显示的记录数；即前端请求这个方法时只需要将<code>pageCode</code>和<code>pageSize</code>传进来就行，后端使用<code>pageHelper</code>分页插件将查询到的数据进行分页，并将结果返回给前端。</p>
<p>对于请求映射中包含多个参数的，应该使用<code>@RequestParam()</code>进行标记，不然可能报错400等。</p>
<br>

<h1 id="逻辑思路"><a href="#逻辑思路" class="headerlink" title="逻辑思路"></a>逻辑思路</h1><h2 id="后端-1"><a href="#后端-1" class="headerlink" title="后端"></a>后端</h2><p>首先我们需要定义分页实体类：<code>PageBean.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">PageBean</span><span class="params">()</span> implements Serialization </span>&#123;</span><br><span class="line">	<span class="comment">//当前页</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> total;</span><br><span class="line">    <span class="comment">//当前页记录</span></span><br><span class="line">    <span class="keyword">private</span> List rows;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为我们使用了mybatis的分页插件：<code>PageHelper</code>，所以<code>PageHelper</code>最终为我们封装在<code>PageBean</code>的数据应该是这个样子的：</p>
<p><img src="/2018/07/30/vue/vue-6/2.png" alt></p>
<p><strong>注意：</strong>需要返回JSON格式数据。可以看到里面主要包含两个参数：<code>total</code>、<code>rows</code></p>
<ul>
<li><code>total</code>表示当前数据的分页得到的总页数，相当于我们前端定义的<code>pageCode</code>。</li>
<li><code>rows</code>表示当前查询到数据的集合体。</li>
</ul>
<p>即后端的逻辑比较简单，因为最麻烦的分页逻辑，<code>PageHelper</code>已经帮我们完成了，我们需要做的：</p>
<p>1、在Controller中定义请求映射方法：<code>PageBean findByPage(@RequestParam(&quot;pageCode&quot;)int pageCode, @RequestParam(&quot;pageSize&quot;)int pageSize){}</code></p>
<p>2、Controller调用Service，通过<code>PageHelper</code>分页插件获取到这两个参数pageCode,pageSize，自动进行分页计算。</p>
<p>3、Service调用Dao，指定对应的SQL<code>SELECT * FROM user</code>，可以看到这个SQL仅仅需要查询所有数据即可，返回的数据类型是<code>com.github.pagehelper.Page</code></p>
<p>4、Controller需要返回给前端的数据类型是：<code>PageBean</code>(我们自定义的)，其中有两个参数：<code>com.github.pagehelper.Page.getTotal()</code>和<code>com.github.pagehelper.Page.getResult()</code>。</p>
<p>5、综上，我们基本已经获取到了数据，然后通过SpringMVC提供的注解：<code>@RsponseBody</code>(局部标识方法)或<code>@RestController</code>(全局标识类)，自动将返回的数据转换为JSON格式，然后再发送给前端。</p>
<br>

<h2 id="前端-1"><a href="#前端-1" class="headerlink" title="前端"></a>前端</h2><p>前端逻辑相对复杂一些，我们主要需要关注两点：</p>
<blockquote>
<p>1.进入页面触发的事件方法、以及点击分页相关的按钮怎样和后端交互？<br>2.如何将后端交互返回的数据赋值给表格中的绑定的数据、以及分页组件中绑定的数据，并实现HTML页面的渲染？</p>
</blockquote>
<h3 id="第一点"><a href="#第一点" class="headerlink" title="第一点"></a>第一点</h3><p><strong>进入页面触发的事件方法、以及点击分页相关的按钮怎样和后端交互？</strong></p>
<blockquote>
<p>1.有哪些可能被触发的事件和方法？</p>
</blockquote>
<ul>
<li><p>findByPage(pageCode,pageSize)<br>这个是分页的核心方法，会被多次触发。又因为进入页面就应该理解渲染表格中的数据，所以分页方法应在渲染页面时就执行，所以需要在<code>created</code>声明周期函数中调用<code>findByPage(this.pageConf.pageCode,this.pageConf.pageSize)</code>(传入默认的值)。对应的HTML代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">findByPage(pageCode, pageSize) &#123;&#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><p>handleSizeChange(val)<br>这个函数是当pageSize（每页显示的记录数）改变时被触发，通过HTML中的<code>@size-change</code>属性绑定。比如：原来4条/每页改变为6条/每页，就将触发这个函数；其中的参数<code>val</code>表示当前页每页显示几条记录<code>pageSize = val</code>。对应的HTML代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">handleSizeChange(val) &#123;</span><br><span class="line">    this.findByPage(this.pageConf.pageCode, val);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>每当pageSize改变就需要重新调用<code>findByPage(this.pageConf.pageCode, val)</code>函数重新计算页面需要渲染的数据。</p>
<ul>
<li>handleCurrentChange(val)<br>这个函数是当pageCode(当前页)改变时触发的函数，通过HTML中的<code>@current-change</code>属性绑定。比如：点击下一页、上一页，就会触发这个函数；其中的参数<code>val</code>表示当前是第几页<code>pageCode = val</code>。对应的HTML代码：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">handleCurrentChange(val) &#123;</span><br><span class="line">    this.findByPage(val, this.pageConf.pageSize);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>每当pageCode改变时就需要重新调用<code>findByPage(val, this.pageConf.pageSize)</code>函数从新计算页面需要渲染的数据。</p>
<blockquote>
<p>2.分页相关按钮是什么鬼？</p>
</blockquote>
<p>在传统没有每页插件的时候，我们通常会手写分页逻辑，那么就需要为每一个页面绑定一个触发方法，而使用了element-ui提供的分页插件，大大简化了分页逻辑，其中点击的下一页、上一页、点击每页显示记录选项、去第几页等这些功能都是ElementUI自动帮我们绑定了事件。</p>
<blockquote>
<p>3.怎样和后端交互？</p>
</blockquote>
<p>和后端实现交互的方法主要是<code>findByPage()</code>这个核心方法，其相关JS代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">findByPage(pageCode, pageSize) &#123;</span><br><span class="line">    this.$http.post('/user/findByPage.do', &#123;pageCode: pageCode, pageSize: pageSize&#125;).then(result =&gt; &#123;</span><br><span class="line">        this.pageConf.totalPage = result.body.total;</span><br><span class="line">        this.user = result.body.rows;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>如上，findByPage()是我们定义的分页的核心方法，所有其他分页中触发的方法都会调用这个方法重新和后端交互，获取到最新的数据并返回给页面。其中你需要注意：</p>
<ul>
<li><p>findByPage()中包含两个参数：pageCode、pageSize。</p>
</li>
<li><p>调用vue-resource提供的post请求方法，其中传入两个参数pageCode、pageSize；在<code>then()</code>回调函数中可获取请求返回的数据。</p>
</li>
<li><p>注意Controller返回的数据就在<code>result</code>这个参数中，但是实际的数据是在<code>result.body</code>中的，所以你直接<code>result.total</code>是获取不到数据的。</p>
</li>
<li><p>前面已经看到了，后端主要返回两个封装了数据的参数：<code>total</code>(总页数)、<code>rows</code>(核心数据)</p>
</li>
<li><p>findByPage方法请求后端得到了<code>total</code>和<code>rows</code>，就应该分别赋值给<code>this.pageConf.totalPage</code>和<code>this.user</code>；根据Vue双向绑定的功能，页面新的数据会直接渲染出来。</p>
</li>
</ul>
<h3 id="第二点"><a href="#第二点" class="headerlink" title="第二点"></a>第二点</h3><p><strong>如何将后端交互返回的数据赋值给表格中的绑定的数据、以及分页组件中绑定的数据，并实现HTML页面的渲染？</strong></p>
<p>其实第一点中我们已经讲到了，因为Vue有一个双向绑定的功能，即我们请求后端将数据赋值给<code>data:{}</code>中的对象后，HTML页面会立即渲染新的<code>data</code>数据。</p>
<blockquote>
<p>如何将后端返回的数据赋值给页面需要展示的数据？</p>
</blockquote>
<p>首先是<code>&lt;el-table&gt;</code>中要渲染的数据，其来自<code>:data=&quot;user&quot;</code>绑定的user对象，我们需要将后端返回的数据赋值给这个<code>user</code>根据双向绑定思想即会更新表格中的数据。</p>
<p>其次就是<code>&lt;el-pagination&gt;</code>中定义的分页参数，由于element-ui分页插件已经帮我们完成了很多逻辑计算，我们需要交互改变的参数只有三个：<code>pageCode</code>当前页、<code>pageSize</code>每页显示的记录数、<code>totalPage</code>总记录条数，而后端返回的数据我们也看过，综上：我们只需要将后端返回的总页数<code>total</code>赋值给<code>user</code>对象中的属性<code>totalPage</code>即可。</p>
<p>主要JavaScript代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">findByPage(pageCode, pageSize) &#123;</span><br><span class="line">    <span class="keyword">this</span>.$http.post(<span class="string">'/user/findByPage.do'</span>, &#123;<span class="attr">pageCode</span>: pageCode, <span class="attr">pageSize</span>: pageSize&#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.pageConf.totalPage = result.body.total;</span><br><span class="line">        <span class="keyword">this</span>.user = result.body.rows;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<br>

<h1 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h1><p>经过上面的分析，其实很多代码已经展示出来了，下面我们看看完整的代码：</p>
<h2 id="后端-2"><a href="#后端-2" class="headerlink" title="后端"></a>后端</h2><p><strong>实体类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageBean</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当前页</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> total;</span><br><span class="line">    <span class="comment">//当前页记录</span></span><br><span class="line">    <span class="keyword">private</span> List rows;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id; <span class="comment">//用户编号</span></span><br><span class="line">    <span class="keyword">private</span> String username; <span class="comment">//用户名</span></span><br><span class="line">    <span class="keyword">private</span> String password; <span class="comment">//密码</span></span><br><span class="line">    <span class="keyword">private</span> String phone; <span class="comment">//联系电话</span></span><br><span class="line">    <span class="keyword">private</span> String mailbox; <span class="comment">//邮箱</span></span><br><span class="line">    <span class="keyword">private</span> String address; <span class="comment">//地址</span></span><br><span class="line">    <span class="keyword">private</span> String postalCode; <span class="comment">//邮政编码</span></span><br><span class="line">    <span class="keyword">private</span> String date; <span class="comment">//注册日期</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Controller</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/findByPage"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> PageBean <span class="title">findByPage</span><span class="params">(@RequestParam(<span class="string">"pageCode"</span>)</span> <span class="keyword">int</span> pageCode, @<span class="title">RequestParam</span><span class="params">(<span class="string">"pageSize"</span>)</span> <span class="keyword">int</span> pageSize) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userService.findByPage(pageCode, pageSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Service</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.github.pagehelper.Page;</span><br><span class="line"><span class="keyword">import</span> com.github.pagehelper.PageHelper;</span><br><span class="line"><span class="keyword">import</span> com.instrument.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> com.instrument.entity.PageBean;</span><br><span class="line"><span class="keyword">import</span> com.instrument.entity.User;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> PageBean <span class="title">findByPage</span><span class="params">(<span class="keyword">int</span> pageCode, <span class="keyword">int</span> pageSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用Mybatis分页插件</span></span><br><span class="line">    PageHelper.startPage(pageCode,pageSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用分页查询方法，其实就是查询所有数据，mybatis自动帮我们进行分页计算</span></span><br><span class="line">    Page&lt;User&gt; page = userDao.findByPage();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PageBean(page.getTotal(),page.getResult());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里dao层调用的<code>findByPage()</code>对应的SQL仅仅是<code>SELECT * FROM 表</code>。而分页是调用的<code>startPage()</code>和<code>Page</code>函数两者共同完成的分页逻辑计算，其返回的数据主要是在<code>total</code>和<code>rows</code>中封装着。</p>
<p><strong>mapper.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 分页查询 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findByPage"</span> <span class="attr">resultType</span>=<span class="string">"com.instrument.entity.User"</span>&gt;</span></span><br><span class="line">    SELECT * FROM user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="前端-2"><a href="#前端-2" class="headerlink" title="前端"></a>前端</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"#app"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">el-table</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">ref</span>=<span class="string">"user"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">:data</span>=<span class="string">"user"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">tooltip-effect</span>=<span class="string">"dark"</span></span></span><br><span class="line"><span class="tag">	    <span class="attr">style</span>=<span class="string">"width: 100%"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">el-table-column</span></span></span><br><span class="line"><span class="tag">		        <span class="attr">prop</span>=<span class="string">"id"</span></span></span><br><span class="line"><span class="tag">		        <span class="attr">sortable</span></span></span><br><span class="line"><span class="tag">		        <span class="attr">label</span>=<span class="string">"编号"</span></span></span><br><span class="line"><span class="tag">		        <span class="attr">width</span>=<span class="string">"80"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">el-table-column</span></span></span><br><span class="line"><span class="tag">		        <span class="attr">prop</span>=<span class="string">"username"</span></span></span><br><span class="line"><span class="tag">		        <span class="attr">sortable</span></span></span><br><span class="line"><span class="tag">		        <span class="attr">label</span>=<span class="string">"联系人"</span></span></span><br><span class="line"><span class="tag">		        <span class="attr">width</span>=<span class="string">"120"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">el-table-column</span></span></span><br><span class="line"><span class="tag">		        <span class="attr">prop</span>=<span class="string">"phone"</span></span></span><br><span class="line"><span class="tag">		        <span class="attr">sortable</span></span></span><br><span class="line"><span class="tag">		        <span class="attr">label</span>=<span class="string">"联系电话"</span></span></span><br><span class="line"><span class="tag">		        <span class="attr">width</span>=<span class="string">"120"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">el-table-column</span></span></span><br><span class="line"><span class="tag">		        <span class="attr">prop</span>=<span class="string">"mailbox"</span></span></span><br><span class="line"><span class="tag">		        <span class="attr">label</span>=<span class="string">"电子邮箱"</span></span></span><br><span class="line"><span class="tag">		        <span class="attr">width</span>=<span class="string">"150"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">el-table-column</span></span></span><br><span class="line"><span class="tag">		        <span class="attr">prop</span>=<span class="string">"postalCode"</span></span></span><br><span class="line"><span class="tag">		        <span class="attr">sortable</span></span></span><br><span class="line"><span class="tag">		        <span class="attr">label</span>=<span class="string">"邮政编码"</span></span></span><br><span class="line"><span class="tag">		        <span class="attr">width</span>=<span class="string">"120"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">el-table-column</span></span></span><br><span class="line"><span class="tag">		        <span class="attr">prop</span>=<span class="string">"date"</span></span></span><br><span class="line"><span class="tag">		        <span class="attr">sortable</span></span></span><br><span class="line"><span class="tag">		        <span class="attr">label</span>=<span class="string">"注册时间"</span></span></span><br><span class="line"><span class="tag">		        <span class="attr">width</span>=<span class="string">"200"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">el-table-column</span></span></span><br><span class="line"><span class="tag">		        <span class="attr">prop</span>=<span class="string">"address"</span></span></span><br><span class="line"><span class="tag">		        <span class="attr">label</span>=<span class="string">"通讯地址"</span></span></span><br><span class="line"><span class="tag">		        <span class="attr">width</span>=<span class="string">"200"</span></span></span><br><span class="line"><span class="tag">		        <span class="attr">show-overflow-tooltip</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">el-table</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 分页 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pagination"</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">el-pagination</span></span></span><br><span class="line"><span class="tag">	            <span class="attr">background</span></span></span><br><span class="line"><span class="tag">	            @<span class="attr">size-change</span>=<span class="string">"handleSizeChange"</span></span></span><br><span class="line"><span class="tag">	            @<span class="attr">current-change</span>=<span class="string">"handleCurrentChange"</span></span></span><br><span class="line"><span class="tag">	            <span class="attr">:current-page</span>=<span class="string">"pageConf.pageCode"</span></span></span><br><span class="line"><span class="tag">	            <span class="attr">:page-sizes</span>=<span class="string">"pageConf.pageOption"</span></span></span><br><span class="line"><span class="tag">	            <span class="attr">:page-size</span>=<span class="string">"pageConf.pageSize"</span></span></span><br><span class="line"><span class="tag">	            <span class="attr">layout</span>=<span class="string">"total, sizes, prev, pager, next, jumper"</span></span></span><br><span class="line"><span class="tag">	            <span class="attr">:total</span>=<span class="string">"pageConf.totalPage"</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;/<span class="name">el-pagination</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"../vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">	el: <span class="string">'#app'</span></span></span><br><span class="line">	data()&#123;</span><br><span class="line"><span class="javascript">		<span class="comment">//用户信息</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//element-ui的table需要的参数必须是Array类型的</span></span></span><br><span class="line">        user: [&#123;</span><br><span class="line"><span class="javascript">            username: <span class="string">''</span>,</span></span><br><span class="line"><span class="javascript">            phone: <span class="string">''</span>,</span></span><br><span class="line"><span class="javascript">            mailbox: <span class="string">''</span>,</span></span><br><span class="line"><span class="javascript">            postalCode: <span class="string">''</span>,</span></span><br><span class="line"><span class="javascript">            date: <span class="string">''</span>,</span></span><br><span class="line"><span class="javascript">            address: <span class="string">''</span></span></span><br><span class="line">        &#125;],</span><br><span class="line"><span class="javascript">        <span class="comment">//定义分页Config</span></span></span><br><span class="line">        pageConf: &#123;</span><br><span class="line"><span class="javascript">            <span class="comment">//设置一些初始值(会被覆盖)</span></span></span><br><span class="line"><span class="javascript">            pageCode: <span class="number">1</span>, <span class="comment">//当前页</span></span></span><br><span class="line"><span class="javascript">            pageSize: <span class="number">4</span>, <span class="comment">//每页显示的记录数</span></span></span><br><span class="line"><span class="javascript">            totalPage: <span class="number">12</span>, <span class="comment">//总记录数</span></span></span><br><span class="line"><span class="javascript">            pageOption: [<span class="number">4</span>, <span class="number">10</span>, <span class="number">20</span>], <span class="comment">//分页选项</span></span></span><br><span class="line"><span class="javascript">            handleCurrentChange: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"页码改变了"</span>);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">	methods:&#123;</span><br><span class="line">		findByPage(pageCode, pageSize) &#123;</span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.$http.post(<span class="string">'/user/findByPage.do'</span>, &#123;<span class="attr">pageCode</span>: pageCode, <span class="attr">pageSize</span>: pageSize&#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.pageConf.totalPage = result.body.total;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.user = result.body.rows;</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        <span class="comment">//pageSize改变时触发的函数</span></span></span><br><span class="line">        handleSizeChange(val) &#123;</span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.findByPage(<span class="keyword">this</span>.pageConf.pageCode, val);</span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        <span class="comment">//当前页改变时触发的函数</span></span></span><br><span class="line">        handleCurrentChange(val) &#123;</span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.findByPage(val, <span class="keyword">this</span>.pageConf.pageSize);</span></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 获取所有数据</span></span></span><br><span class="line">        findAll() &#123;</span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.$http.post(<span class="string">'/user/findAll.do'</span>).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.user = result.body;</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	created()&#123;</span><br><span class="line"><span class="javascript">		<span class="keyword">this</span>.findAll();</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.findByPage(<span class="keyword">this</span>.pageConf.pageCode, <span class="keyword">this</span>.pageConf.pageSize);</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>以上代码我们基本已经解释过了，唯一没有提到的就是<code>findAll()</code>这个方法，要知道，进入到页面后，首先就是展示所有数据（即使有没有分页）；那么就需要在生命周期函数<code>created</code>中执行<code>findAll()</code>获取所有数据直接渲染到页面上<code>this.user=result.body</code>即可。其次又因为我们使用了分页查询功能，进入页面后展示的数据应该是分页查询后的数据（因为我们设置有默认的分页参数值）。</p>
<br>

<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue实现前后端分离项目的初体验</title>
    <url>/2018/07/27/vue/vue-5/</url>
    <content><![CDATA[<p><strong>Vue实现前后端分离项目的初体验</strong></p>
<p>经过之前学习的Vue的知识：</p>
<ul>
<li><a href="http://tycoding.cn/2018/07/21/vue-1/#more" target="_blank" rel="noopener">vue基本指令</a></li>
<li><a href="http://tycoding.cn/2018/07/23/vue-3/#more" target="_blank" rel="noopener">vue组件</a></li>
<li><a href="http://tycoding.cn/2018/07/22/vue-2/#more" target="_blank" rel="noopener">vue-resource</a></li>
<li><a href="http://tycoding.cn/2018/07/23/vue-3/#more" target="_blank" rel="noopener">vue路由</a></li>
</ul>
<p>其实我们已经可以开始实战运用到实际的Web项目中了，由于本人是Java后端开发的，所以后端是基于SpringMVC的。</p>
<p>以下我们将演示如何使用Vue组件实现一个用户登录系统。</p>
<a id="more"></a>

<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><blockquote>
<p>后端基于spring、springMVC、mybatis框架</p>
</blockquote>
<p>对后端SSM框架搭建不熟悉的可以参考我的博文： <a href="http://tycoding.cn/2018/06/05/ssm-2/#more" target="_blank" rel="noopener">SSM项目整合</a></p>
<h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p>前端使用了wepack打包工具，利用了<code>vue.cli</code>脚手架快速搭建的项目。由于本人对一些技术也不是很熟悉，所以给大家提供些官方文档，<br>想要深入学习还是要仔细分析官方文档。传送门如下（也是本项目要用到的）：</p>
<ul>
<li><a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">node.js</a></li>
<li><a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="noopener">vue.js</a></li>
<li><a href="https://github.com/vuejs/vue-cli" target="_blank" rel="noopener">vue-cli</a></li>
<li><a href="https://www.npmjs.com/package/vue-resource" target="_blank" rel="noopener">vue-resource</a></li>
<li><a href="https://router.vuejs.org/" target="_blank" rel="noopener">vue-router</a></li>
<li><a href="http://webpack.github.io/" target="_blank" rel="noopener">webpack</a></li>
<li><a href="http://element.eleme.io/#/zh-CN" target="_blank" rel="noopener">element-ui</a></li>
</ul>
<p>以上技术都是比较常用的，<code>webpack</code>类似一个打包工具，它会将你项目中的Vue组件打包为一个庞大的<code>js</code>文件（当然我们是看不懂的），而我们的前端项目是部署在<code>node.js</code>提供的web容器中的。</p>
<p>即前后端分离的实际效果是这样的：<br><img src="/2018/07/27/vue/vue-5/1.png" alt="index.html"></p>
<p><img src="/2018/07/27/vue/vue-5/2.png" alt="index"></p>
<p>有没有感觉很神奇，哈哈，反正我第一次见到的时候就是觉得很神奇，因为<code>html</code>中完全看不到任何js、css代码，但是却能渲染出来这么好看的页面。下面我们就讲一下，怎么实现这个过程吧！！</p>
<br>

<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>上面我们提到的技术，在本案例中都会遇到，后端的SSM框架请参考我的博客文档，介绍一下前端环境的搭建：</p>
<p><strong>1、安装<code>node.js</code></strong></p>
<p>具体安装流程还是要去看<code>node.js</code>官网。如果安装完成，请在终端输入<code>npm -v</code>查看是否安装成功。一般会出现类似如下版本号：</p>
<blockquote>
<p>v8.11.3</p>
</blockquote>
<p><strong>2、安装<code>VueCLI</code>脚手架</strong></p>
<p><code>VueCLI</code>能够帮助我们快速搭建一个webpack的项目。</p>
<p>在已经安装好<code>node.js</code>的前提上，在终端输入：<code>npm install vue-cli -g</code>开始安装VueCLI。如果安装完成，请在终端输入：<code>vue -V</code>，会出现如下版本信息：</p>
<blockquote>
<p>2.9.6</p>
</blockquote>
<p>具体安装流程可以参看：<a href="https://blog.csdn.net/qq_36711388/article/details/79405402" target="_blank" rel="noopener">博文</a></p>
<p>由于<strong>VueCLI脚手架</strong>已经帮我们安装好了<code>webpack</code>、以及相关的node依赖包，所以我们不需要再手动安装了。</p>
<h2 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h2><p>如果安装完成，我们可以看到出现如下目录结构：</p>
<p><img src="/2018/07/27/vue/vue-5/3.png" alt></p>
<h3 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h3><p>在终端项目路径下输入<code>npm run dev</code>命令；正常情况下，会出现如下信息：</p>
<p><img src="/2018/07/27/vue/vue-5/4.png" alt></p>
<p>在浏览器中输入指定的URL，会出现如下页面：</p>
<p><img src="/2018/07/27/vue/vue-5/5.png" alt></p>
<p>我们继续观察，打开项目中的<code>index.html</code></p>
<p><img src="/2018/07/27/vue/vue-5/6.png" alt></p>
<p>我们看到，这个HTML中没有任何代码，甚至没有引入js、css，但是页面中的视图是怎样渲染出来的呢？</p>
<p>仔细看项目结构，我们能看到在<code>src/components/</code>下有一个<code>HelloWorld.vue</code>程序，我们页面中的程序就是通过这些<code>.vue</code>组件来渲染出来的。</p>
<h3 id="打包项目"><a href="#打包项目" class="headerlink" title="打包项目"></a>打包项目</h3><p>如果我们想将项目部署到服务器上，你放一堆<code>.vue</code>程序，浏览器是无法解析出来的，所以我们需要了解一下<code>webpack</code>的打包命令：</p>
<blockquote>
<p>npm run build</p>
</blockquote>
<p><img src="/2018/07/27/vue/vue-5/7.png" alt></p>
<p>正常情况下，会显示上图中的信息，表示打包成功了，会在项目根目录中生成一个叫<code>dist</code>的文件夹，里面是生成的静态项目：</p>
<p><img src="/2018/07/27/vue/vue-5/8.png" alt></p>
<p>我们双击<code>dist/index.html</code>，会看到和之前一样的页面，但是其中引入了一个<code>XX.js</code>文件</p>
<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>经过上面的步骤我们应该了解到了所谓前端分离的简易概念，其实在之前的博文： <a href="http://tycoding.cn/2018/07/23/vue-3/#more" target="_blank" rel="noopener">Vue组件</a> 我们已经了解到了Vue的模块化开发流程。配合<code>.vue</code>组件，其实思路还是相同的。</p>
<h2 id="搭建前端"><a href="#搭建前端" class="headerlink" title="搭建前端"></a>搭建前端</h2><p>开始之前，我们首先要安装<code>vue-resource</code>（<code>element-ui</code>），执行：</p>
<blockquote>
<p>npm install vue-resource<br>npm install element-ui</p>
</blockquote>
<h3 id="第一步：修改main-js"><a href="#第一步：修改main-js" class="headerlink" title="第一步：修改main.js"></a>第一步：修改main.js</h3><p><code>main.js</code>文件是<code>webpack</code>的核心入口，我们需要在其中引入<code>Vue-resource</code>以及<code>router</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import VueResource from &apos;vue-resource&apos;</span><br><span class="line"></span><br><span class="line">import router from &apos;./router/index.js&apos;</span><br></pre></td></tr></table></figure>

<p><strong>在Vue实例中注册router</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">	router,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>完整代码：</p>
<p><img src="/2018/07/27/vue/vue-5/9.png" alt></p>
<h3 id="第二步：修改router-index-js"><a href="#第二步：修改router-index-js" class="headerlink" title="第二步：修改router/index.js"></a>第二步：修改router/index.js</h3><p>这是有关Vue路由的配置，前面我们也已经讲过了vue的路由，这里不再多说，代码如下：</p>
<p><img src="/2018/07/27/vue/vue-5/10.png" alt></p>
<p>如上就配置了，如果你访问<code>localhost:8081/</code>，那么就会自动路由跳转到<code>login.vue</code>组件中，提示我们登录;其中的<code>/home</code>表示，如果登录成功，就跳转到<code>home.vue</code>组件中，相当于登录成功后跳转到后台页面。</p>
<h3 id="第三步：创建login-vue"><a href="#第三步：创建login-vue" class="headerlink" title="第三步：创建login.vue"></a>第三步：创建login.vue</h3><p>在<code>src/components/</code>下创建<code>login.vue</code>组件。</p>
<p>login组件中表单样式就不再讲了，我们主要看一下怎样利用<code>v-model</code>绑定表单数据，并请求后端</p>
<p><strong>表单原型</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 登录表单 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-form</span> <span class="attr">:model</span>=<span class="string">"login"</span> <span class="attr">status-icon</span> <span class="attr">:rules</span>=<span class="string">"rule"</span> <span class="attr">ref</span>=<span class="string">"login"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">prop</span>=<span class="string">"username"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">prefix-icon</span>=<span class="string">"el-icon-ump-yonghu"</span> <span class="attr">v-model</span>=<span class="string">"login.username"</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">auto-complete</span>=<span class="string">"off"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">prop</span>=<span class="string">"password"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">prefix-icon</span>=<span class="string">"el-icon-ump-mima"</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">v-model</span>=<span class="string">"login.password"</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">auto-complete</span>=<span class="string">"off"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-form-item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-checkbox</span> <span class="attr">class</span>=<span class="string">"check"</span> <span class="attr">v-model</span>=<span class="string">"checked"</span>&gt;</span>记住我<span class="tag">&lt;/<span class="name">el-checkbox</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-form-item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">class</span>=<span class="string">"btn"</span> <span class="attr">type</span>=<span class="string">"primary"</span> @<span class="attr">click</span>=<span class="string">"submitForm('login')"</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">class</span>=<span class="string">"tips"</span>&gt;</span>还没有账号？点我去注册<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在上面的表单中，我们只需要关注三个点：</p>
<ul>
<li>v-model=”login.username”</li>
<li>v-model=”login.password”</li>
<li>@click=”submitForm(‘login’)”</li>
</ul>
<p>为什么不关注其他的？<br>注意，这个案例由于我使用了<code>element-ui</code>，从标签中就能看出来，其中涉及到了一些element-ui提供的js校验，我们只需要关注Vue的逻辑即可。</p>
<p><strong>提交表单</strong></p>
<p>关于上面提到的element-ui的校验部分<br><img src="/2018/07/27/vue/vue-5/11.png" alt></p>
<p>表单提交方法部分</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    submitForm(login) &#123;</span><br><span class="line">        <span class="keyword">this</span>.$refs[login].validate(<span class="function">(<span class="params">valid</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (valid) &#123;</span><br><span class="line">                <span class="comment">//提交表单</span></span><br><span class="line">                <span class="keyword">this</span>.$http.post(<span class="string">'http://127.0.0.1:8080/login.do'</span>, &#123;</span><br><span class="line">                    username: <span class="keyword">this</span>.login.username,</span><br><span class="line">                    password: <span class="keyword">this</span>.login.password</span><br><span class="line">                &#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(result);</span><br><span class="line">                    <span class="keyword">if</span> (result.bodyText === <span class="string">'index'</span>) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.$router.push(&#123; <span class="attr">path</span>: <span class="string">'home'</span> &#125;); <span class="comment">//跳转到home组件中</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">console</span>.log(<span class="string">"登录失败"</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'error submit!!'</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面就是我们要讲到的核心部分：请求后端的接口</p>
<p><strong>解释：</strong></p>
<ul>
<li><p>首先需要注意的<code>this.$refs[login].validate((valid)){}</code>是element-ui提供的表单验证的逻辑，但是是结合vue.js的。因为我们若在不验证表单直接提交的时候，会在表单提交按钮中直接传<code>@click=&quot;submitForm(login)&quot;</code>，因为此时的<code>login</code>是一个<code>data</code>中已经声明的对象，其中包含两个参数：<code>username</code>,<code>password</code>。而element-ui提供的方式则会根据<code>.validate()</code>获取到<code>login</code>所包含的参数从而实现校验。</p>
</li>
<li><p>经过上面的校验，如果校验成功，那么将调用<code>this.$http.post()</code>进行提交post表单，这是<code>vue-resource</code>提供的方式，<a href="http://tycoding.cn/2018/07/22/vue-2/#more" target="_blank" rel="noopener">博文</a> 中我们也讲过。其中包含了两个参数，username,password。</p>
</li>
<li><p>请求成功，调用<code>.then()</code>回获取到成功的请求结果。判断请求的结果：我这里是从后端返回的参数（<code>return &quot;index&quot;</code>）中判断是否登录成功，如果能录成功，就应该跳转到<code>home</code>组件中。</p>
</li>
<li><p>调用<code>vue-router</code>中提供的<code>$router.push</code>方法，我们可以理解为向<code>Router</code>对象中添加了一条路由地址，其URL是：<code>path: &#39;home&#39;</code>，那么就表明了会跳转带名字叫<code>/home</code>的路径下，整好对应的是我们配置好的<code>home.vue</code>组件。</p>
</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li><p>最重要的就是跨域请求问题，本例中<code>node.js</code>提供的web服务器地址是：<code>127.0.0.1:8081</code>，但是我们后端Tomcat服务器的地址是：<code>127.0.0.1:8080</code>，而默认是不能在一个域中访问另一个域中的资源的，所以也就出现了跨域请求的概念。</p>
</li>
<li><p>其次重要的就是<code>$http.post()</code>的第一个参数：URL地址，不要写<code>locahost:</code>，不要写….  具体原因不是很清楚，不然请求还会报错为跨域请求。</p>
</li>
<li><p>解决跨域请求的方式也有很多，这里我提供一个比较简单的方式，只需要在后端的<code>web.xml</code>中提供一个允许跨域访问的过滤器就行了，后面会介绍。</p>
</li>
<li><p>还有就是之前我们就说过Vue中默认提交的post请求时不包含表单格式的，所以需要配置，我已经在<code>main.js</code>中写了<code>Vue.http.options.emulateJSON = true;</code>设置全局表单提交格式，所以在<code>post()</code>方法中就没有设置。</p>
</li>
</ul>
<h3 id="第四部：创建home-vue"><a href="#第四部：创建home-vue" class="headerlink" title="第四部：创建home.vue"></a>第四部：创建home.vue</h3><p>在<code>src/components/</code>下创建<code>home.vue</code>组件</p>
<p><img src="/2018/07/27/vue/vue-5/15.png" alt></p>
<br>
<br>

<h2 id="搭建后端"><a href="#搭建后端" class="headerlink" title="搭建后端"></a>搭建后端</h2><p>经过上面介绍了前端搭建步骤后，搭建后端我们就相对熟悉了，我们的目标就是在controller中提供一个接口<code>login.do</code>让前端访问。</p>
<h3 id="解决跨域请求"><a href="#解决跨域请求" class="headerlink" title="解决跨域请求"></a>解决跨域请求</h3><p>之前已经说了跨域请求很重要，不然我们写的所有请求都无法顺利访问后端接口。解决的方式如下：</p>
<p><strong>配置</strong></p>
<p>我们只需要在项目中的<code>web.xml</code>中配置如下代码即可。因为这个过滤器是tomcat提供的，所以我们并不需要导入任何jar包。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--配置允许跨域访问--&gt;</span><br><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;CorsFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;filter-class&gt;org.apache.catalina.filters.CorsFilter&lt;/filter-class&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;CorsFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><p>讲了那么多，终于到了Controller层，这里就比较简单了，就是根据获取到的参数判断数据库中有没有对应的用户，有就登录成功，否者亏登录失败。</p>
<p><img src="/2018/07/27/vue/vue-5/12.png" alt></p>
<p>由于我这里使用了shiro，需要将密码加密处理，所以没有直接传入到service层，当然思路是相同的。</p>
<p><strong>注意：</strong></p>
<ul>
<li>我这个<code>login.do</code>接口返回的是JSON字符串，前面使用了<code>@RestController</code>注解，不要误认为是返回的页面，那么就会404的。</li>
<li>接受的参数要用<code>@RequestParam</code>注解标记，不然会接受不到前端传递的数据</li>
</ul>
<p><strong>请求成功</strong></p>
<p><img src="/2018/07/27/vue/vue-5/13.png" alt></p>
<p>跳转到home组件中：</p>
<p><img src="/2018/07/27/vue/vue-5/14.png" alt></p>
<br>

<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue路由</title>
    <url>/2018/07/25/vue/vue-4/</url>
    <content><![CDATA[<h1 id="Vue路由"><a href="#Vue路由" class="headerlink" title="Vue路由"></a>Vue路由</h1><p><strong>什么是Vue路由？</strong></p>
<ul>
<li><p><strong>后端路由：</strong>即请求的URL地址都对应后端的接口，请求URL响应对应的服务器的资源。</p>
</li>
<li><p><strong>前段路由：</strong>对于单页面程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以单页面程序中的页面跳转主要通过hash实现。</p>
</li>
</ul>
<a id="more"></a>

<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h3 id="导入类库"><a href="#导入类库" class="headerlink" title="导入类库"></a>导入类库</h3><p>首先需要导入vue-router组件类库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;../lib/vue-router.js&quot;&gt;&lt;/script&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>当导入类库后，window全局对象中就存在了一个路由的构造函数： <code>VueRouter</code>；就像导入Vue类库后存在一个<code>Vue</code>的构造函数一样，我们能够通过<code>new VueRouter</code>的方式实例化路由对象。</p>
<p>如果你使用了<code>new VueRouter({});</code>构造函数来实例化了一个路由对象，你会发现浏览器路径中会出现<code>#/</code>路径，这个路径就是前面讲到的URL中的hash，他并不会向后端发送任何请求，而仅仅是作页面跳转，如果你<code>#/</code>后拼接了一个不存在的路径，自然也不会进行跳转，页面也不会发送任何请求。</p>
<p><strong>实例：</strong></p>
<p><img src="/2018/07/25/vue/vue-4/1.png" alt><br><img src="/2018/07/25/vue/vue-4/2.png" alt></p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>上面我们讲到了使用<code>new VueRouter({})</code>的方式实例化一个路由对象，其中包含几个参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- HTML --&gt;</span><br><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;!-- 给路由对象创建一个容器，包裹在父组件<span class="string">`app`</span>内</span><br><span class="line">		相当于一个占位符，路由规则匹配到的组件内容就会展示到<span class="string">`&lt;router-view&gt;&lt;/router-view&gt;`</span>中</span><br><span class="line">	--&gt;</span><br><span class="line">	&lt;router-view&gt;<span class="xml"><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;!-- =================分割线===================== --&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;!-- JavaScript --&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/创建login组件</span></span><br><span class="line"><span class="regexp">var login = &#123;</span></span><br><span class="line"><span class="regexp">	template: 'login组件'</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/创建register组件</span></span><br><span class="line"><span class="regexp">var register = &#123;</span></span><br><span class="line"><span class="regexp">	template: 'register组件'</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ Router实例</span></span><br><span class="line"><span class="regexp">var 路由对象名称 = new VueRouter(&#123;</span></span><br><span class="line"><span class="regexp">	routes: [</span></span><br><span class="line"><span class="regexp">		&#123; path: '/监听URL路径', component: login(组件名称) &#125;,</span></span><br><span class="line"><span class="regexp">		&#123; path: '/监听URL路径', component: register(组件名称) &#125;</span></span><br><span class="line"><span class="regexp">	]</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ Vue实例</span></span><br><span class="line"><span class="regexp">var vm = new Vue(&#123;</span></span><br><span class="line"><span class="regexp">	el: 'app',</span></span><br><span class="line"><span class="regexp">	data: &#123;&#125;,</span></span><br><span class="line"><span class="regexp">	methods: &#123;&#125;,</span></span><br><span class="line"><span class="regexp">	router: 路由对象名称   </span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><p>1、<code>routes</code> 表示这个路由对象中的 <strong>路由匹配规则</strong>，可以存在多个规则（<strong>注意：</strong>这里是<code>routes</code>而不是<code>routers</code>）</p>
</li>
<li><p>2、属性一：<code>path</code> 表示监听哪个路由连接地址，即你想跳转都哪个路径上，应在这里注册实现跳转到对应的组件上</p>
</li>
<li><p>3、属性二：<code>component</code> 表示如果路由匹配了前面的<code>path</code>，则展示component属性对应的那个组件</p>
</li>
<li><p>4、<code>component</code>的属性值必须是一个组件的模板对象，不能是组件的引用名称</p>
</li>
<li><p>5、经过<code>1-4</code>的步骤基本完成了路由对象的创建，下面要将这个路由对象注入到Vue实例中，使用<code>router: 组件对象名称</code>实现</p>
</li>
<li><p>6、创建对应需要监听的组件，如上我们创建了<code>login</code>和<code>register</code>组件，与之前讲的不同是这里是一个<code>var 组件名称</code>其值是一个组件对象，和之前的<code>Vue.component</code>方式相似，但是这里仅仅是一个组件对象，并没有注册到Vue实例中，因为没有组件名称，所以不能在HTML中使用<code>&lt;login&gt;&lt;/login&gt;</code> ，注意这里的<code>login</code>是组件对象的名称。</p>
</li>
</ul>
<p><strong>步骤：</strong></p>
<ul>
<li><p>1、创建router实例<code>new VueRouter</code>，完成相关属性的定义；</p>
</li>
<li><p>2、将这个路由对象注册到Vue实例中，使用<code>router: 路由对象名称</code>的方式；</p>
</li>
<li><p>3、创建第一步中定义的组件名称对应的组件，直接在<code>&lt;script&gt;</code>中定义var组件对象名称即可，在<code>template</code>中定义具体的HTML视图，或是通过<code>template: &#39;#id&#39;</code>引用外部视图也行。</p>
</li>
<li><p>4、在Vue实例控制域<code>app</code>中，创建<code>&lt;router-view&gt;&lt;/router-view&gt;</code>，相当于router容器，你想在页面上展示几个组件就应该在页面中创建几个容器。</p>
</li>
</ul>
<p>如上，我们可以写具体的跳转链接了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&gt;</span><br><span class="line">	&lt;a href=&quot;#/login&quot;&gt;登录&lt;/a&gt;</span><br><span class="line">	&lt;a href=&quot;#/register&quot;&gt;注册&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>如上，当我们点击登录或注册，Vue-router就会监听都对应的URL地址，然后在<code>path</code>规则中刚好匹配到规则<code>login</code>，那么就会跳转到对应的组件<code>component: login</code>的login组件中。<br>可能你会疑惑了，为什么这里的<code>href</code>需要写为<code>#/login</code>而不是<code>/login</code>或<code>login</code>，你尝试一下就知道了，因为vue-router监听URL地址是基于<code>hash</code>的，不加<code>#/</code>就会找不到路径。</p>
<p>如果你觉得每次都加<code>#/</code>麻烦的话，Vue-router页提供了一个Tag:<code>&lt;router-link to=&quot;URL地址&quot;&gt;&lt;/router-link&gt;</code>，其在浏览器中会被解析为<code>&lt;a&gt;</code>标签。</p>
<p><strong>实例</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">h1</span>&gt;</span>父组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#/login"</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"register"</span>&gt;</span>注册<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"../lib/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"../lib/vue-router.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    	<span class="keyword">var</span> login = &#123;</span></span><br><span class="line"><span class="xml">    		template: '<span class="tag">&lt;<span class="name">h2</span>&gt;</span>登录组件<span class="tag">&lt;/<span class="name">h2</span>&gt;</span>'</span></span><br><span class="line">    	&#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    	<span class="keyword">var</span> register = &#123;</span></span><br><span class="line"><span class="xml">    		template: '<span class="tag">&lt;<span class="name">h2</span>&gt;</span>注册组件<span class="tag">&lt;/<span class="name">h2</span>&gt;</span>'</span></span><br><span class="line">    	&#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">		<span class="keyword">var</span> routerObj = <span class="keyword">new</span> VueRouter(&#123;</span></span><br><span class="line">			routes: [</span><br><span class="line"><span class="javascript">				&#123; <span class="attr">path</span>: <span class="string">'/login'</span>, <span class="attr">component</span>: login &#125;,</span></span><br><span class="line"><span class="javascript">				&#123; <span class="attr">path</span>: <span class="string">'/register'</span>, <span class="attr">component</span>: register &#125;</span></span><br><span class="line">			]</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">		<span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">			el: <span class="string">'#app'</span>,</span></span><br><span class="line">			data: &#123;&#125;,</span><br><span class="line">			methods: &#123;&#125;,</span><br><span class="line">			router: routerObj</span><br><span class="line">		&#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>但是上面的实例中，我们发现默认进入的根路径中仅有一个父组件名称，一般我们的登录页面应该直接显示登录框，所以vue-router提供了重定向的动能<code>{path: &#39;&#39;, redirect: &#39;&#39;}</code>，即在<code>router: []</code>中监听根路径，如果监听都访问的是根路径就重定向到登录URL就好了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var routerObj = new VueRouter(&#123;</span><br><span class="line">	routes: [</span><br><span class="line">		&#123; path: &apos;/&apos;, redirect: &apos;/login&apos; &#125;,</span><br><span class="line">		&#123; path: &apos;/login&apos;, component: login &#125;,</span><br><span class="line">		&#123; path: &apos;/register&apos;, component: register &#125;</span><br><span class="line">	]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="路由参数传递"><a href="#路由参数传递" class="headerlink" title="路由参数传递"></a>路由参数传递</h2><p>在进行页面跳转，即路由的时候，我们可能需要在发送URL时传递一些参数，常见的就如<code>http://tycoding.cn/api?id=1&amp;name=&#39;涂陌&#39;</code>这种格式。</p>
<p>那么在URL中传递的参数，vue-router提供了一种获取方式：<code>this.$route</code>。</p>
<p>那么什么时候能获取到传递的参数呢？ 回顾前面讲到的Vue声明周期函数，那么在自定义组件中自然也存在生命周期函数，所以最早操作组件<code>data</code>和<code>methods</code>中数据的阶段就是<code>created</code>这个声明周期函数的阶段。</p>
<p>实例：</p>
<p><img src="/2018/07/25/vue/vue-4/3.png" alt></p>
<p><img src="/2018/07/25/vue/vue-4/4.png" alt></p>
<p>上面打印的值中，我们能看到，我们再<code>VueRouter</code>中创建的<code>path</code>匹配规则，实际在HTML中会被渲染为相关的<strong>正则表达式</strong>，来实现路径的匹配。<br>其次，我们还能发现，在URL中拼接的参数<code>id</code>在<code>this.$route</code>对象的<code>query</code>属性中，我们通过<code>this.$route.query.id</code>即可获得传递的id值：<code>2</code>。</p>
<h2 id="路由嵌套"><a href="#路由嵌套" class="headerlink" title="路由嵌套"></a>路由嵌套</h2><p>路由嵌套，顾名思义即在父级路由内部存在子路由。例如：</p>
<blockquote>
<p>根路径：<code>http://tycoding.cn/</code><br>父级路由地址：<code>http://tycoding.cn/api</code><br>子级路由地址：<code>http://tycoding.cn/api/login</code></p>
</blockquote>
<p><strong>实例：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/account"</span>&gt;</span>Account<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"tmp"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是Account组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">			<span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/account/login"</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/account/register"</span>&gt;</span>注册<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"></span><br><span class="line">			<span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"../lib/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"../lib/vue-router.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    	<span class="keyword">var</span> account = &#123;</span></span><br><span class="line"><span class="javascript">    		template: <span class="string">'#tmp'</span></span></span><br><span class="line">    	&#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    	<span class="keyword">var</span> login = &#123;</span></span><br><span class="line"><span class="xml">    		template: '<span class="tag">&lt;<span class="name">h2</span>&gt;</span>登录组件<span class="tag">&lt;/<span class="name">h2</span>&gt;</span>',</span></span><br><span class="line">    	&#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    	<span class="keyword">var</span> register = &#123;</span></span><br><span class="line"><span class="xml">    		template: '<span class="tag">&lt;<span class="name">h2</span>&gt;</span>注册组件<span class="tag">&lt;/<span class="name">h2</span>&gt;</span>'</span></span><br><span class="line">    	&#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">		<span class="keyword">var</span> routerObj = <span class="keyword">new</span> VueRouter(&#123;</span></span><br><span class="line">			routes: [</span><br><span class="line">				&#123; </span><br><span class="line"><span class="javascript">					path: <span class="string">'/account'</span>, </span></span><br><span class="line">					component: account,</span><br><span class="line">					children: [</span><br><span class="line"><span class="javascript">						&#123; <span class="attr">path</span>: <span class="string">'login'</span>, <span class="attr">component</span>: login &#125;,</span></span><br><span class="line"><span class="javascript">						&#123; <span class="attr">path</span>: <span class="string">'register'</span>, <span class="attr">component</span>: register &#125;</span></span><br><span class="line">					]</span><br><span class="line">			    &#125;,</span><br><span class="line">			]</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">		<span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">			el: <span class="string">'#app'</span>,</span></span><br><span class="line">			data: &#123;&#125;,</span><br><span class="line">			methods: &#123;&#125;,</span><br><span class="line">			router: routerObj</span><br><span class="line">		&#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如上，我们使用了<code>routes: []</code>中的另外一个属性：<code>children</code>，顾名思义就是表示这个父规则<code>/account</code>下存在一些子规则，且在URL中应该体现出来：</p>
<p><img src="/2018/07/25/vue/vue-4/5.png" alt></p>
<p><strong>注意：</strong></p>
<p>在<code>children</code>中定义的子组件的<code>path</code>规则不能加<code>/</code>，即如上的，直接写<code>path: login</code>即可，这样请求<code>account/login</code>地址时，vue-router会找<code>/account</code>规则下的<code>login</code>规则，且不加<code>/</code>vue-router才会自动将<code>login</code>视为<code>account</code>下的子路径，并自动拼接<code>account/</code>，否则不会自动拼接，那么也无法完成路由的嵌套。</p>
<h2 id="命名视图"><a href="#命名视图" class="headerlink" title="命名视图"></a>命名视图</h2><p>我们常见的后台开发页面，经常遇到上、左、中的布局方式；那么以前我们可能使用iframe实现页面间的跳转，但是现在我们学习的路由要比其更加的方便好用。</p>
<p><strong>命名视图</strong>的思想就是为每一个页面展示的视图都起一个名字，目的是为了为每个<code>&lt;router-view&gt;&lt;/router-view&gt;</code>容器刚好匹配一个指定的视图。使用方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;router-view name=&quot;left&quot;&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;router-view name=&quot;main&quot;&gt;&lt;/router-view&gt;</span><br><span class="line"></span><br><span class="line">routes: [</span><br><span class="line">	&#123; </span><br><span class="line">		path: &apos;/&apos;, components: &#123;</span><br><span class="line">			&apos;default&apos;: header</span><br><span class="line">			&apos;left&apos;: left</span><br><span class="line">			&apos;main&apos;: main</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<p>其中的<code>path</code>是根路径<code>/</code>，而使用<code>components</code>代替之前的<code>component</code>，目的就是可匹配其下的多个规则；<code>default</code>表示默认的视图组件是<code>header</code>这个组件，即会匹配到第一个<code>&lt;router-view&gt;</code>视图容器中；下面的两个组件会根据name名称需要对应的组件。</p>
<p>实现上、左、中的布局：</p>
<p><strong>思路：</strong></p>
<p>1、我们需要创建三个组件，名称分别为：<code>header</code>、<code>left</code>、<code>main</code>；并且在<code>app</code>中创建三个<code>&lt;router-view&gt;&lt;/router-view&gt;</code>路由容器。</p>
<p>2、采用<strong>命名视图</strong>的方式为每个视图都起一个名字：<code>&lt;router-view name=&quot;left&quot;&gt;&lt;/router-view&gt;</code> …</p>
<p>3、注册路由实例。</p>
<p><strong>实例：</strong></p>
<p><img src="/2018/07/25/vue/vue-4/6.png" alt></p>
<p><img src="/2018/07/25/vue/vue-4/7.png" alt></p>
<br>

<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue组件</title>
    <url>/2018/07/23/vue/vue-3/</url>
    <content><![CDATA[<h1 id="Vue创建组件"><a href="#Vue创建组件" class="headerlink" title="Vue创建组件"></a>Vue创建组件</h1><h2 id="什么是组件"><a href="#什么是组件" class="headerlink" title="什么是组件"></a>什么是组件</h2><p>什么是组件？组件的出现，就是为了拆分Vue实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样地方功能，就可以去调用对应的组件即可。</p>
<p>组件化和模块化的区别：</p>
<ul>
<li>模块化：是从代码逻辑的角度进行划分的，方便代码分层开发，保证每个功能模块的只能单一；</li>
<li>组件化：是从UI界面的角度进行划分的；前端的组件化，方便了UI组件的重用；</li>
</ul>
<a id="more"></a>



<h2 id="定义Vue组件"><a href="#定义Vue组件" class="headerlink" title="定义Vue组件"></a>定义Vue组件</h2><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><p>1、使用<code>Vue.extend</code>来创建全局的Vue组件<br>2、通过<code>template</code>属性来指定组件要展示的HTML结构<br>3、通过<code>Vue.component()</code>定义全局组件<br>4、在HTML指定位置通过Tag标签的形式应用你的组件，组件的名称即是tag标签的名称</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">	&lt;!-- 组件的名称即为对应tag标签的名称 --&gt;</span><br><span class="line">	&lt;mycom1&gt;<span class="xml"><span class="tag">&lt;/<span class="name">mycom1</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">	/</span><span class="regexp">/ 创建组件</span></span><br><span class="line"><span class="regexp">	var com1 = Vue.extend(&#123;</span></span><br><span class="line"><span class="regexp">		template: '&lt;h3&gt;这是使用Vue.extend 创建的组件&lt;/</span>h3&gt;<span class="string">'</span></span><br><span class="line"><span class="string">	&#125;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	// 使用Vue.component('</span>组件的名称<span class="string">', 创建出来的组件模板对象)，定义全局组件</span></span><br><span class="line"><span class="string">	Vue.component('</span>mycom1<span class="string">', com1);</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<ul>
<li>用<code>Vue.component()</code>定义组件名称的时候有两种命名方式：1、驼峰命名：<code>Xxx</code>；2、<code>xxx</code>。注意，使用驼峰命名时，tag标签不能使用驼峰名称，应将相应的大写字母替换为<code>-</code>加小写字母，例如：<code>Vue.component(&#39;myCom&#39;, com1)</code>，那么tag标签应为：<code>&lt;my-com&gt;&lt;/my-com&gt;</code></li>
</ul>
<h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 组件的名称即为对应tag标签的名称 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mycom1</span>&gt;</span><span class="tag">&lt;/<span class="name">mycom1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">	<span class="comment">// 使用Vue.component('组件的名称', 创建出来的组件模板对象)，定义全局组件</span></span></span><br><span class="line"><span class="javascript">	Vue.component(<span class="string">'mycom1'</span>, Vue.extend(&#123;</span></span><br><span class="line"><span class="xml">		template: '<span class="tag">&lt;<span class="name">h3</span>&gt;</span>这是使用Vue.extend 创建的组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span>'</span></span><br><span class="line">	&#125;));</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>方式二就像是方式一的简化版，但是注意：<br>在<code>template</code>中定义的内容只能存在一个根节点元素，即上面例子中<code>template</code>中不能出现和<code>&lt;h3&gt;</code>平级的标签。<br>比如下面这种写法就是<strong>错误的</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.component(&apos;mycom1&apos;, Vue.extend(&#123;</span><br><span class="line">	template: &apos;&lt;h3&gt;这是使用Vue.extend 创建的组件&lt;/h3&gt;&lt;span&gt;&lt;/span&gt;&apos;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<p>解决办法就是，外层嵌套一个根标签就行了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.component(&apos;mycom1&apos;, Vue.extend(&#123;</span><br><span class="line">	template: &apos;&lt;div&gt;&lt;h3&gt;这是使用Vue.extend 创建的组件&lt;/h3&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;&apos;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<h3 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h3><p>1、JavaScript中仍使用<code>Vue.component</code>来定义全局组件，和<strong>方式二</strong>相似，但是里面不再是<code>template: &#39;HTML结构&#39;</code>了，而是引用一个外部标签的<code>id</code>值，即<code>template:&#39;id&#39;</code>。</p>
<p>2、在被Vue实例控制的<code>app</code><strong>外面</strong>，定义<code>&lt;template id=&quot;id&quot;&gt;你的HTML结构&lt;/template&gt;&gt;</code> </p>
<p>这种方式的好处就是是就组件代码都是定义在HTML结构中的，有智能代码提示；而JavaScript中定义组件仅是写一个引用。</p>
<p>实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">	&lt;!-- 页面引用 --&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;template id=&quot;tmp&quot;&gt;</span><br><span class="line">	&lt;!-- 比如仅存在一个根节点元素 --&gt;</span><br><span class="line">	&lt;div&gt;</span><br><span class="line">		&lt;h1&gt;&lt;/h1&gt;&gt;</span><br><span class="line">		&lt;h2&gt;&lt;/h2&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">//JavaScript部分</span><br><span class="line">Vue.component(&apos;mycom&apos;, &#123;</span><br><span class="line">	template: &apos;#tmp&apos;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="定义私有组件"><a href="#定义私有组件" class="headerlink" title="定义私有组件"></a>定义私有组件</h3><p>除了上面讲到的定义全局组件，我们也可以定义私有组件，使用<code>components: {}</code>函数。</p>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;tem&gt;&lt;/tem&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;template id=&quot;tmp&quot;&gt;</span><br><span class="line">    &lt;h3&gt;这是私有组件&lt;/h3&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;../lib/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;,</span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">    methods: &#123;&#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        tem: &#123;</span><br><span class="line">            template: &apos;#tmp&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="组件元素"><a href="#组件元素" class="headerlink" title="组件元素"></a>组件元素</h2><h3 id="组件的data"><a href="#组件的data" class="headerlink" title="组件的data"></a>组件的data</h3><p>在组件中，同样可以有自己的data数据，但是用法和Vue实例中的data用法有所不同：</p>
<ol>
<li><p>组件中的data必须是一个方法，即</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data: function()&#123; &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>组件中的data方法必须返回一个Object对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data: function()&#123;</span><br><span class="line">	return object</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;mycom1&gt;&lt;/mycom1&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;../lib/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">Vue.component(&apos;mycom1&apos;, Vue.extend(&#123;</span><br><span class="line">	data: function()&#123;</span><br><span class="line">		return &#123;</span><br><span class="line">			msg: &apos;这是组件的data&apos;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	template: &apos;&lt;h3&gt;这是使用Vue.extend 创建的组件-- &#123;&#123;msg&#125;&#125;&lt;/h3&gt;&apos;</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;,</span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">    methods: &#123;&#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="组件的切换"><a href="#组件的切换" class="headerlink" title="组件的切换"></a>组件的切换</h3><p>在遇到登录注册表单时，通常我们需要对两个按钮进行切换实现显示不同的表单，那么Vue中的组件切换正符合了这个功能要求。</p>
<h4 id="方式一-1"><a href="#方式一-1" class="headerlink" title="方式一"></a>方式一</h4><p>可以使用Vue提供的<code>v-if</code>和<code>v-else</code>来实现<strong>两个</strong>组件间的切换，但是，仅支持切换两个组件</p>
<p>实例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> @<span class="attr">click.prevent</span>=<span class="string">"flag=true"</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> @<span class="attr">click.prevent</span>=<span class="string">"flag=false"</span>&gt;</span>注册<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">login</span> <span class="attr">v-if</span>=<span class="string">"flag"</span>&gt;</span><span class="tag">&lt;/<span class="name">login</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">register</span> <span class="attr">v-else</span>=<span class="string">"flag"</span>&gt;</span><span class="tag">&lt;/<span class="name">register</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"login"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>这是登录表单<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"register"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">h3</span>&gt;</span>这是注册表单<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"../lib/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="comment">// 创建登录组件</span></span></span><br><span class="line"><span class="javascript">Vue.component(<span class="string">'login'</span>, &#123;</span></span><br><span class="line"><span class="javascript">	template: <span class="string">'#login'</span></span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="comment">// 创建注册组件</span></span></span><br><span class="line"><span class="javascript">Vue.component(<span class="string">'register'</span>, &#123;</span></span><br><span class="line"><span class="javascript">	template: <span class="string">'#register'</span></span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">'#app'</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">    	flag: <span class="literal">true</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>定义<code>flag</code>参数，当flag=true就显示组件，当flar=false就隐藏组件</p>
<h4 id="方式二-1"><a href="#方式二-1" class="headerlink" title="方式二"></a>方式二</h4><p>Vue提供了<code>component</code>来展示对应名称的组件。其中<code>component</code>是一个占位符，<code>:is</code>属性，可以用来指定要展示的组件名称</p>
<p>实例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> @<span class="attr">click.prevent</span>=<span class="string">"comName='login'"</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> @<span class="attr">click.prevent</span>=<span class="string">"comName='register'"</span>&gt;</span>注册<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"comName"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"login"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>这是登录表单<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"register"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">h3</span>&gt;</span>这是注册表单<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"../lib/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="comment">// 创建登录组件</span></span></span><br><span class="line"><span class="javascript">Vue.component(<span class="string">'login'</span>, &#123;</span></span><br><span class="line"><span class="javascript">	template: <span class="string">'#login'</span></span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="comment">// 创建注册组件</span></span></span><br><span class="line"><span class="javascript">Vue.component(<span class="string">'register'</span>, &#123;</span></span><br><span class="line"><span class="javascript">	template: <span class="string">'#register'</span></span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">'#app'</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">    	comName: <span class="string">'login'</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>即使用Vue提供的<code>component</code>，它能够实现自动对组件进行展示和隐藏，通过<code>:is=&#39;组件名称&#39;</code>。</p>
<h2 id="父子组件间传值"><a href="#父子组件间传值" class="headerlink" title="父子组件间传值"></a>父子组件间传值</h2><h3 id="父组件给子组件传值"><a href="#父组件给子组件传值" class="headerlink" title="父组件给子组件传值"></a>父组件给子组件传值</h3><p>父组件给子组件传值，即实现在子组件中调用父组件中的<code>methods</code>或是获取父组件中的<code>data</code>.</p>
<h4 id="传参数"><a href="#传参数" class="headerlink" title="传参数"></a>传参数</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 父组件实例 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment">&lt;!-- 子组件实例 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">com1</span>&gt;</span><span class="tag">&lt;/<span class="name">com1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"../lib/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="javascript">        	msg: <span class="string">'这是父组件data值'</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">        	show()&#123;</span><br><span class="line"><span class="javascript">        		<span class="built_in">console</span>.log(<span class="string">"这是父组件的show方法"</span>);</span></span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 子组件</span></span></span><br><span class="line">        components: &#123;</span><br><span class="line">        	com1: &#123;</span><br><span class="line"><span class="xml">        		template: '<span class="tag">&lt;<span class="name">h2</span>&gt;</span>这是子组件<span class="tag">&lt;/<span class="name">h2</span>&gt;</span>'</span></span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如上，当我们直接在子组件中引用父组件<code>data</code>中定义的<code>msg</code>数据，将上面的修改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com1: &#123;</span><br><span class="line">	template: &apos;&lt;h2&gt;这是子组件--&#123;&#123;msg&#125;&#125;&lt;/h2&gt;&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么就会报错。所以就证实了默认在子组件中不能访问父组件中的<code>data</code>或<code>methods</code>。</p>
<p>为了解决子组件获取父组件数据，Vue提供了以下方式获取：</p>
<ul>
<li><p>1、父组件在引用子组件的时候，通过属性绑定的方式<code>v-bind:</code>，把需要传递给子组件的数据以属性绑定的形式传递到子组件内部，供子组件使用。</p>
</li>
<li><p>2、在子组件中，通过<code>props: []</code>获取到父组件传递过来的数据；这样就完成了父组件向子组件传值</p>
</li>
</ul>
<p><strong>实例</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 父组件实例 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment">&lt;!-- 子组件实例 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">com1</span> <span class="attr">:fatoson</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">com1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"../lib/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="javascript">        	msg: <span class="string">'这是父组件data值'</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;&#125;,</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 子组件</span></span></span><br><span class="line">        components: &#123;</span><br><span class="line">        	com1: &#123;</span><br><span class="line"><span class="xml">        		template: '<span class="tag">&lt;<span class="name">h2</span>&gt;</span>这是子组件--&#123;&#123;fatoson&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span>',</span></span><br><span class="line"><span class="javascript">        		props: [<span class="string">'fatoson'</span>]</span></span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如上，我们在子组件实例中使用了<code>v-bind</code>绑定了一个参数<code>fatoson</code>，其值是：<code>msg</code>即在父组件data中定义的值；那么就相当于父组件的一个data数据被Vue绑定到了子组件实例中，且父组件data值的别名是<code>fatoson</code>，那么在子组件中通过<code>props: []</code>属性就能获取到这个别名，然后就实现了父组件向子组件传值。需要注意以下：</p>
<ul>
<li>1、我们可以将为子组件绑定的参数名称是父组件值的别名。即此时<code>msg</code>相当于<code>fatoson</code>。</li>
<li>2、注意命名中若是驼峰命名，在HTML中必须用<code>-</code>替换。</li>
<li>3、注意<code>props</code>是Vue为父组将向子组件传值提供的一个参数，且他是唯一的数组类型的。</li>
<li>4、注意子组件通过<code>props</code>获取到的父组件的值是<strong>只读</strong>的，即不能修改。</li>
</ul>
<h4 id="传方法"><a href="#传方法" class="headerlink" title="传方法"></a>传方法</h4><p>上面讲了父组件给子组件传递普通的参数，下面我们将了解到父组件怎样给子组件传递方法。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 父组件实例 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment">&lt;!-- 子组件实例 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">com1</span> @<span class="attr">open</span>=<span class="string">"show"</span>&gt;</span><span class="tag">&lt;/<span class="name">com1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"tmp"</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    		<span class="tag">&lt;<span class="name">h2</span>&gt;</span>这是子组件<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    		<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> @<span class="attr">click</span>=<span class="string">"myclick"</span> <span class="attr">value</span>=<span class="string">"子组件按钮，点击触发父组件方法"</span>/&gt;</span></span><br><span class="line">    	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"../lib/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="javascript">        	msg: <span class="string">'这是父组件data值'</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">        	show()&#123;</span><br><span class="line"><span class="javascript">        		<span class="built_in">console</span>.log(<span class="string">"这是父组件的show方法"</span>);</span></span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 子组件</span></span></span><br><span class="line">        components: &#123;</span><br><span class="line">        	com1: &#123;</span><br><span class="line"><span class="javascript">        		template: <span class="string">'#tmp'</span>,</span></span><br><span class="line"><span class="javascript">        		props: [<span class="string">'fatoson'</span>],</span></span><br><span class="line">        		methods: &#123;</span><br><span class="line">        			myclick()&#123;</span><br><span class="line"><span class="javascript">       		 			<span class="keyword">this</span>.$emit(<span class="string">'open'</span>);</span></span><br><span class="line">        			&#125;</span><br><span class="line">        		&#125;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>1、这里子组件的<code>template</code>数据引用外部的<code>&lt;template&gt;&lt;/template&gt;</code>中的HTML代码。</li>
<li>2、与传值思路相同，传递方法也需要在子组件实例中使用<code>v-on</code>即<code>@</code>来绑定方法，方法别名<code>@open</code>，方法的值是<code>show</code>是在父组件中定义的方法名。</li>
<li>3、与传值思路相同，传值使用了<code>props</code>来接受传递的参数，那么传方法提供了<code>$emit()</code>元素</li>
</ul>
<h4 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h4><p>上面讲的父组件向子组件传递方法，那么既然是方法就肯定能传递方法参数。我们只需要在父组件方法中指定值名称即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@子组件接收的方法别名=&quot;父组件中的方法(父组件中的参数值或data)&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 父组件实例 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment">&lt;!-- 子组件实例 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">com1</span> @<span class="attr">open</span>=<span class="string">"show(fatosonval)"</span>&gt;</span><span class="tag">&lt;/<span class="name">com1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"tmp"</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    		<span class="tag">&lt;<span class="name">h2</span>&gt;</span>这是子组件<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    		<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> @<span class="attr">click</span>=<span class="string">"myclick"</span> <span class="attr">value</span>=<span class="string">"子组件按钮，点击触发父组件方法"</span>/&gt;</span></span><br><span class="line">    	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"../lib/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line">        	fatosonval: &#123;</span><br><span class="line"><span class="javascript">        		id: <span class="string">'1'</span>,</span></span><br><span class="line"><span class="javascript">        		name: <span class="string">'涂陌'</span></span></span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">        	show(data)&#123;</span><br><span class="line"><span class="javascript">        		<span class="built_in">console</span>.log(data);</span></span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 子组件</span></span></span><br><span class="line">        components: &#123;</span><br><span class="line">        	com1: &#123;</span><br><span class="line"><span class="javascript">        		template: <span class="string">'#tmp'</span>,</span></span><br><span class="line">        		methods: &#123;</span><br><span class="line">        			myclick()&#123;</span><br><span class="line"><span class="javascript">       		 			<span class="keyword">this</span>.$emit(<span class="string">'open'</span>);</span></span><br><span class="line">        			&#125;</span><br><span class="line">        		&#125;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2018/07/23/vue/vue-3/1.png" alt></p>
<h3 id="子组件给父组件传值"><a href="#子组件给父组件传值" class="headerlink" title="子组件给父组件传值"></a>子组件给父组件传值</h3><p>即实现在父组件中调用子组件中的方法</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 父组件实例 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment">&lt;!-- 子组件实例 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">com1</span> @<span class="attr">open</span>=<span class="string">"show"</span>&gt;</span><span class="tag">&lt;/<span class="name">com1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"tmp"</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    		<span class="tag">&lt;<span class="name">h2</span>&gt;</span>这是子组件<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    		<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> @<span class="attr">click</span>=<span class="string">"myclick"</span> <span class="attr">value</span>=<span class="string">"子组件按钮，点击触发父组件方法"</span>/&gt;</span></span><br><span class="line">    	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"../lib/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="javascript">        	fatosonval: <span class="literal">null</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">        	show(data)&#123;</span><br><span class="line"><span class="javascript">        		<span class="built_in">console</span>.log(data);</span></span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 子组件</span></span></span><br><span class="line">        components: &#123;</span><br><span class="line">        	com1: &#123;</span><br><span class="line"><span class="javascript">        		template: <span class="string">'#tmp'</span>,</span></span><br><span class="line">        		data()&#123;</span><br><span class="line"><span class="javascript">        			<span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        				sonval: &#123; <span class="attr">name</span>: <span class="string">'TyCoding'</span>, <span class="attr">age</span>: <span class="number">19</span> &#125;</span></span><br><span class="line">        			&#125;</span><br><span class="line">        		&#125;,</span><br><span class="line">        		methods: &#123;</span><br><span class="line">        			myclick()&#123;</span><br><span class="line"><span class="javascript">       		 			<span class="keyword">this</span>.$emit(<span class="string">'open'</span>, <span class="keyword">this</span>.sonval);</span></span><br><span class="line">        			&#125;</span><br><span class="line">        		&#125;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>之前我们实现父组件向子组件传值的时候，需要在<code>@open()</code>中指定父组件中的<code>data</code>，而子组件给父组件传值的时候就不需要再指定了，而是直接在调用子组件中的<code>open</code>（这是父组件方法的别名），将子组件的值写进<code>$emit(&#39;方法别名&#39;, data参数)</code>中即可。</p>
<p><img src="/2018/07/23/vue/vue-3/2.png" alt></p>
<h2 id="Vue获取DOM元素和组件"><a href="#Vue获取DOM元素和组件" class="headerlink" title="Vue获取DOM元素和组件"></a>Vue获取DOM元素和组件</h2><p>首先我们需要明白的就是Vue并不提倡我们操作DOM元素，Vue的宗旨就是让我们只关心业务逻辑。</p>
<p>那么通常我们需要获取一个如<code>&lt;h2&gt;&lt;/h2&gt;</code>中的值，采用原生JS通常需要先为tag标签定义一个id属性，然后通过JS代码<code>document.getElementById(&#39;id&#39;).innterText</code>来获取到<code>&lt;h2&gt;</code>中的文本数据，而Vue也实现了操作原生DOM的功能：</p>
<pre><code>* 在需要获取的HTML标签中指定`ref`属性，其值可自定义。
* 在Vue实例中，使用`this.$refs.指定的值`来获取DOM对象，进行操作。</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;h2 ref=&quot;h2&quot;&gt;这是h2的文本数据&lt;/h2&gt;&gt;</span><br><span class="line"></span><br><span class="line">console.log(this.$refs.h2.innerText);</span><br></pre></td></tr></table></figure>

<p><strong>通过$refs还能轻易获取子组件中的data和methods数据</strong></p>
<p>首先需要为子组件引用实例定义<code>ref=&quot;com1&quot;</code>属性，然后在Vue实例中通过<code>this.$refs.com1</code>即可获取子组件中的所有对象，即还能获取到子组件中的<code>data</code>和<code>methods</code></p>
<p>实例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 父组件实例 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 子组件实例 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">com1</span> <span class="attr">ref</span>=<span class="string">"com1"</span>&gt;</span><span class="tag">&lt;/<span class="name">com1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> @<span class="attr">click</span>=<span class="string">"show"</span> <span class="attr">value</span>=<span class="string">"获取元素"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span> <span class="attr">ref</span>=<span class="string">"h2"</span>&gt;</span>这是父组件<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"tmp"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h2</span>&gt;</span>这是子组件<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"../lib/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line">        methods: &#123;</span><br><span class="line">            show()&#123;</span><br><span class="line"><span class="javascript">                <span class="comment">// console.log(this.$refs.h2.innerText);</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">// console.log(this.$refs.com1); //获取子组件中的所有实例对象</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">// console.log(this.$refs.com1.sonval); //获取子组件中定义的data值</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="keyword">this</span>.$refs.com1.sonshow()); <span class="comment">//调用子组件中定义的方法</span></span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 子组件</span></span></span><br><span class="line">        components: &#123;</span><br><span class="line">            com1: &#123;</span><br><span class="line"><span class="javascript">                template: <span class="string">'#tmp'</span>,</span></span><br><span class="line">                data() &#123;</span><br><span class="line"><span class="javascript">                    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">                        sonval: &#123; <span class="attr">name</span>: <span class="string">'TyCoding'</span>, <span class="attr">age</span>: <span class="number">19</span> &#125;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                methods: &#123;</span><br><span class="line">                    sonshow() &#123;</span><br><span class="line"><span class="javascript">                        <span class="built_in">console</span>.log(<span class="string">'子组件的方法'</span>);</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<br>

<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue过滤器和vue-resource</title>
    <url>/2018/07/22/vue/vue-2/</url>
    <content><![CDATA[<h1 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h1><p>之前我们学习了Vue的 <a href="http://tycoding.cn/2018/07/21/vue-1/#more" target="_blank" rel="noopener">vue基本指令</a> 进阶学习，我们需要了解Vue的过滤器：Vue.js允许你自定义过滤器，可被用作一些常见元素的格式化。过滤器可以用在两个地方：mustache插值<code></code>和<code>v-bind</code>表达式。</p>
<p>用法： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123; 过滤器名称 | function &#125;&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p><strong>定义：</strong></p>
<p>Vue提供了两种方式创建过滤器：</p>
<ul>
<li><p>1、全局过滤器</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Vue.filter('过滤器名称', function()&#123;&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>2、私有过滤器</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">new Vue()(&#123;</span><br><span class="line">	el: '',</span><br><span class="line">	data: &#123;&#125;,</span><br><span class="line">	methods: &#123;&#125;,</span><br><span class="line">	filters: &#123;</span><br><span class="line">		过滤器名称: function()&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="全局过滤器"><a href="#全局过滤器" class="headerlink" title="全局过滤器"></a>全局过滤器</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123; msg | myFilters('时光') &#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"></span><br><span class="line">Vue.filter('myFilters', function(data, pattern)&#123;</span><br><span class="line">	if(pattern == '时光')&#123;</span><br><span class="line">		var old = data.substring(0,4);</span><br><span class="line">		return old + ',时光路口。';</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong><br>如上：Vue提供的全局过滤器，直接使用<code>Vue</code>调用，而不是定义在<code>Vue实例</code>中</p>
<ul>
<li><code>Vue.filter()</code>中第一个参数是过滤器名称，第二个参数是<code>function(){}</code></li>
<li><code>function(){}</code>中还有两个参数，第一个参数是原始的值，第二个参数是你想给过滤器方法传递的值。</li>
</ul>
<h2 id="私有过滤器"><a href="#私有过滤器" class="headerlink" title="私有过滤器"></a>私有过滤器</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123; msg | myFilters('时光') &#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"></span><br><span class="line">var vm2 = new Vue(&#123;</span><br><span class="line">	el: '#app2',</span><br><span class="line">	data: &#123;</span><br><span class="line">		msg: '银河街角！'</span><br><span class="line">	&#125;,</span><br><span class="line">	methods: &#123;&#125;,</span><br><span class="line">	filters: &#123;</span><br><span class="line"></span><br><span class="line">		myFilters: function(data, pattern) &#123;</span><br><span class="line">			if(pattern == '时光')&#123;</span><br><span class="line">				var old = data.substring(0,4);</span><br><span class="line">				return old + ',时光路口。';</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>私有过滤器和全局过滤器用法基本相同，仅仅是作用于不同而已。</p>
<h1 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h1><h2 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h2><p>在我们搜索商品时，在一些网站中我们直接回车后立即进行搜索，而不是点击搜索按钮才会搜索，那么这个功能怎么实现呢？</p>
<p>那么我们就需要了解Vue中提供的<strong>按键修饰符</strong><br>用法： <code>@keyup.按键别名 = &quot;要调用的方法名&quot;</code></p>
<p><strong>按键别名</strong></p>
<blockquote>
<p>.enter<br>.tab<br>.esc<br>.delete<br>…</p>
</blockquote>
<p><strong>实例</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> @<span class="attr">keyup.enter</span>=<span class="string">"open"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">	open()&#123;</span><br><span class="line">		alert("弹出");</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>自定义按键修饰符</strong><br>如果Vue提供的按键修饰符不能满足你的需求，你也可以使用Vue提供的自定义按键修饰符来实现，因为每个键盘的按键都对应了一个键盘码值，比如F2对应的键盘码值是：113：</p>
<p>用法： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; @keyup.f2=&quot;open&quot;&gt;</span><br><span class="line"></span><br><span class="line">Vue.config.keyCodes.f2 = 113;	</span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">	open()&#123;</span><br><span class="line">		alert(&quot;弹出&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取文本焦点"><a href="#获取文本焦点" class="headerlink" title="获取文本焦点"></a>获取文本焦点</h2><p>获取文本焦点使用了focus属性，那么我们需要定义一个<code>v-focus</code>指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.directive(&apos;focus&apos;, &#123;</span><br><span class="line">	bind: function(el) &#123;&#125;,</span><br><span class="line">	inserted: function(el) &#123;&#125;,</span><br><span class="line">	updated: function(el) &#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如上，使用<code>Vue.directive()</code>实现定义全局指令，需要注意以下几点：</p>
<ul>
<li>1、在directive()方法中包含两个参数：<pre><code>- 参数1：指令的名称，注意，在定义的时候指令名称不需要加v-前缀，但是在使用的时候需要加v-前缀。</code></pre><ul>
<li>参数2：是一个对象，这个对象包含一些指令相关的函数，这些函数可以在特定的阶段，执行相关的操作。</li>
</ul>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.directive(<span class="string">'focus'</span>, &#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用的时候使用： v-focus</span></span><br></pre></td></tr></table></figure>

<ul>
<li>2、在directive()函数的第二个参数中（对象）中又包含了三个实例方法：<ul>
<li>bind: 当指令绑定到元素上的时候，会立即执行这个bind函数，只执行一次；但是需要知道元素绑定了这个指令，若涉及对DOM操作的，并不会立即执行，因为元素不会立即插入到DOM中。所以涉及对元素进行DOM相关操作的，不要定义到这个方法中。</li>
<li>inserted: 当元素插入到DOM的时候，会立即执行，并只触发一次。</li>
<li>updated: 当VNode更新的时候，会指定updated，可能触发多次。</li>
</ul>
</li>
</ul>
<p><strong>实例：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.directive(<span class="string">'focus'</span>, &#123;</span><br><span class="line">	bind: <span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">		el.focus()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">&lt;input type=<span class="string">"text"</span> v-focus /&gt;</span><br></pre></td></tr></table></figure>

<p>如上，其中<code>bind</code>函数的第一个参数永远是<code>el</code>，它表示绑定的那个元素，是一个原生的JS对象；这里我们调用了JS的focus方法</p>
<h3 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h3><p>指令定义函数提供了几个钩子函数（可选）：</p>
<blockquote>
<p>bind<br>inserted<br>update<br>componentUpdated: 所在组件的VNode及其孩子的VNode全部更新的时候调用<br>unbind: 只调用一次，指令与元素解除绑定时调用</p>
</blockquote>
<p><strong>钩子函数参数</strong><br>在上面使用<code>directive()</code>函数的时候我们已经介绍了一些常用的钩子函数，那么既然是函数，就可能需要进行传参，那么为了实现钩子函数传参，Vue提供了几个参数属性来实现对钩子函数参数的一些操作：</p>
<ul>
<li><p><code>el:</code> 指令所绑定的元素，可以用来直接操作DOM。</p>
</li>
<li><p><code>binding:</code> 一个对象，包含以下属性：</p>
<ul>
<li>name: 指令名，不包含<code>v-</code>前缀</li>
<li>value: 指令的绑定值，如<code>v-focus=&quot;1 + 1&quot;</code>，那么value=2。</li>
<li>expression: 绑定值的字符串形式，如<code>v-focus=&quot;1+1&quot;</code>，那么experssion的值是<code>1+1</code>。</li>
<li>…</li>
</ul>
</li>
<li><p>…</p>
</li>
</ul>
<p><strong>实例：</strong></p>
<p>实现在文本框中输入的数据颜色要为蓝色</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">"text"</span> v-color=<span class="string">"'blue'"</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义设置颜色的指令</span></span><br><span class="line">Vue.directive(<span class="string">'color'</span>, &#123;</span><br><span class="line">	bind: <span class="function"><span class="keyword">function</span>(<span class="params">el, binding</span>)</span>&#123;</span><br><span class="line">		el.style.color = binding.value</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>其中因为设计要获取值的操作，所以使用<code>binding</code>这个对象钩子函数参数来使用接收，那么：</p>
<ol>
<li>这个<code>el</code>就表示当前这个<code>&lt;input&gt;</code>文本框对象</li>
<li>这个<code>bniding</code>就表示<code>v-color=&quot;&#39;blue&#39;&quot;</code>指令传递的参数<code>blue</code>（因为使用<code>&#39;&#39;</code>单引号即不是字符串）</li>
<li><code>biding-value</code>就是获取到<code>v-color</code>指令绑定的参数值是：<code>blue</code>，通过<code>el.style.color</code>表示设置这个文本框样式中的颜色属性</li>
</ol>
<h3 id="定义私有指令"><a href="#定义私有指令" class="headerlink" title="定义私有指令"></a>定义私有指令</h3><p>使用<strong>私有指令</strong>和<strong>全局指令</strong>的用法基本相同，我们参考上面讲过的<strong>私有过滤器</strong>和<strong>全局过滤器</strong>就能猜想到<strong>私有指令</strong>的用法：</p>
<p><strong>实例</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;p v-fontsize=<span class="string">"'50px'"</span>&gt;私有指令&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">var vm = new Vue(&#123;</span></span><br><span class="line"><span class="regexp">	el: '',</span></span><br><span class="line"><span class="regexp">	data: &#123;&#125;,</span></span><br><span class="line"><span class="regexp">	methods: &#123;&#125;,</span></span><br><span class="line"><span class="regexp">	filters: &#123;&#125;,</span></span><br><span class="line"><span class="regexp">	directives: &#123;</span></span><br><span class="line"><span class="regexp">		'fontsize': &#123;</span></span><br><span class="line"><span class="regexp">			bind: function(el, binding)&#123;</span></span><br><span class="line"><span class="regexp">				el.style.fontSize = binding.value</span></span><br><span class="line"><span class="regexp">			&#125;</span></span><br><span class="line"><span class="regexp">		&#125;</span></span><br><span class="line"><span class="regexp">	&#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br></pre></td></tr></table></figure>

<p><strong>自定义指令的简写形式</strong><br>对于仅仅使用<code>bind</code>和<code>update</code>钩子函数的操作，可以进行下列的简写形式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;p v-fontsize=<span class="string">"'50px'"</span>&gt;私有指令&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">var vm = new Vue(&#123;</span></span><br><span class="line"><span class="regexp">	el: '',</span></span><br><span class="line"><span class="regexp">	data: &#123;&#125;,</span></span><br><span class="line"><span class="regexp">	methods: &#123;&#125;,</span></span><br><span class="line"><span class="regexp">	filters: &#123;&#125;,</span></span><br><span class="line"><span class="regexp">	directives: &#123;</span></span><br><span class="line"><span class="regexp">		'fontsize': function(el, binding)&#123;</span></span><br><span class="line"><span class="regexp">			el.style.fontSize = binding.value</span></span><br><span class="line"><span class="regexp">		&#125;</span></span><br><span class="line"><span class="regexp">	&#125;</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br></pre></td></tr></table></figure>

<h1 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h1><p>实现将列表数据渲染到表格中，并实现添加功能案例（包含上面讲到的所有技术的<strong>实例</strong>）：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line">    table &#123;</span><br><span class="line">        min-height: 25px;</span><br><span class="line">        line-height: 25px;</span><br><span class="line">        text-align: center;</span><br><span class="line">        border-collapse: collapse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    table,</span><br><span class="line">    table tr th,</span><br><span class="line">    table tr td &#123;</span><br><span class="line">        border: 1px solid #0094ff;</span><br><span class="line">        padding: 11px;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        id:</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"id"</span> <span class="attr">v-focus</span> <span class="attr">v-color</span>=<span class="string">"'blue'"</span>&gt;</span> username:</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"username"</span> @<span class="attr">keyup.enter</span>=<span class="string">"add"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"添加"</span> @<span class="attr">click</span>=<span class="string">"add"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">th</span>&gt;</span>id<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">th</span>&gt;</span>name<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">th</span>&gt;</span>date<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">th</span>&gt;</span>fun<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span> <span class="attr">v-for</span>=<span class="string">"user in list"</span> <span class="attr">:key</span>=<span class="string">"user.id"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;user.id&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;user.username&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;user.time | dataFormat('') &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> @<span class="attr">click</span>=<span class="string">"del(user.id)"</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>未使用过滤器：&#123;&#123; new Date() &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>使用全局过滤器：&#123;&#123; new Date() | dataFormat('') &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app2"</span>&gt;</span></span><br><span class="line">        使用私有过滤器：&#123;&#123; dt | dataFormat('')&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-fontsize</span>=<span class="string">"'50px'"</span>&gt;</span>私有指令<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"../lib/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 自定义文本框获取焦点指令</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// Vue.directive()定义全局指令，包含两个参数：</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 参数1：指令的名称，注意，在定义的时候指令的名称不需要加v-前缀，但是在使用的时候需要加v-focus</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 参数2：是一个对象，这个对象中包含一些指令相关的函数，这些函数可以在特定的阶段，执行相关的操作</span></span></span><br><span class="line"><span class="javascript">    Vue.directive(<span class="string">'focus'</span>, &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 注意，在下面的函数中，第一个参数永远是el，表示被绑定了指令的那个元素，这个el参数是一个原生JS对象</span></span></span><br><span class="line"><span class="javascript">        bind: <span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123; <span class="comment">//每当指令绑定到元素上的时候，会立即执行这个bind函数，只执行一次</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 注意：在元素绑定了指令时，还没有插入到DOM中去，这时候调用focus方法是没有作用的，因为一个元素，只有插入到DOM之后，才能获取焦点</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// el.focus()</span></span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        inserted: <span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123; <span class="comment">// inserted表示元素插入到DOM中的时候，会执行,触发一次</span></span></span><br><span class="line">            el.focus()</span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        updated: <span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123; <span class="comment">// 当VNode更新的是否，会执行updated，可触发多次</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// 自定义设置颜色的指令</span></span></span><br><span class="line"><span class="javascript">    Vue.directive(<span class="string">'color'</span>, &#123;</span></span><br><span class="line"><span class="javascript">        bind: <span class="function"><span class="keyword">function</span>(<span class="params">el, binding</span>) </span>&#123;</span></span><br><span class="line">            el.style.color = binding.value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// 自定义按键</span></span></span><br><span class="line">    Vue.config.keyCodes.f2 = 113;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// 演示私有过滤器</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vm2 = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">'#app2'</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="javascript">            dt: <span class="keyword">new</span> <span class="built_in">Date</span>(),</span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            open() &#123;</span><br><span class="line"><span class="javascript">                alert(<span class="string">"弹出"</span>);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        filters: &#123;</span><br><span class="line"><span class="javascript">            dataFormat: <span class="function"><span class="keyword">function</span>(<span class="params">data, pattern</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 获取当前日期</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> dt = <span class="keyword">new</span> <span class="built_in">Date</span>(data);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">                <span class="comment">// 获取年月日</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> y = dt.getFullYear();</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> m = dt.getMonth() + <span class="number">1</span>;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> d = dt.getDate();</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span> (pattern.toLowerCase() == <span class="string">'yyyy-mm-dd'</span>) &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;y&#125;</span>-<span class="subst">$&#123;m&#125;</span>-<span class="subst">$&#123;d&#125;</span>`</span>;</span></span><br><span class="line"><span class="javascript">                &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> hh = dt.getHours();</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> mm = dt.getMinutes();</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> ss = dt.getSeconds();</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">                    <span class="comment">// es6中提供的 yyyy-mm-dd hh:mm:ss 的简写形式</span></span></span><br><span class="line"><span class="javascript">                    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;y&#125;</span>-<span class="subst">$&#123;m&#125;</span>-<span class="subst">$&#123;d&#125;</span> <span class="subst">$&#123;hh&#125;</span>:<span class="subst">$&#123;mm&#125;</span>:<span class="subst">$&#123;ss&#125;</span>`</span> + <span class="string">'--&gt;私有'</span>;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        <span class="comment">// 自定义私有指令（简写形式）</span></span></span><br><span class="line">        directives: &#123;</span><br><span class="line"><span class="javascript">            <span class="string">'fontsize'</span>: <span class="function"><span class="keyword">function</span>(<span class="params">el, binding</span>) </span>&#123;</span></span><br><span class="line">                el.style.fontSize = binding.value</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// 全局过滤器</span></span></span><br><span class="line"><span class="javascript">    Vue.filter(<span class="string">'dataFormat'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data, pattern</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 获取当前日期</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> dt = <span class="keyword">new</span> <span class="built_in">Date</span>(data);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 获取年月日</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> y = dt.getFullYear();</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> m = dt.getMonth() + <span class="number">1</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> d = dt.getDate();</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (pattern.toLowerCase() == <span class="string">'yyyy-mm-dd'</span>) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;y&#125;</span>-<span class="subst">$&#123;m&#125;</span>-<span class="subst">$&#123;d&#125;</span>`</span>;</span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> hh = dt.getHours();</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> mm = dt.getMinutes();</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> ss = dt.getSeconds();</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;y&#125;</span>-<span class="subst">$&#123;m&#125;</span>-<span class="subst">$&#123;d&#125;</span> <span class="subst">$&#123;hh&#125;</span>:<span class="subst">$&#123;mm&#125;</span>:<span class="subst">$&#123;ss&#125;</span>`</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// 创建Vue实例</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="javascript">            id: <span class="string">''</span>,</span></span><br><span class="line"><span class="javascript">            username: <span class="string">''</span>,</span></span><br><span class="line">            list: [</span><br><span class="line"><span class="javascript">                &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">username</span>: <span class="string">'涂陌'</span>, <span class="attr">time</span>: <span class="keyword">new</span> <span class="built_in">Date</span>() &#125;,</span></span><br><span class="line"><span class="javascript">                &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">username</span>: <span class="string">'TyCoding'</span>, <span class="attr">time</span>: <span class="keyword">new</span> <span class="built_in">Date</span>() &#125;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            add() &#123;</span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> user = &#123; <span class="attr">id</span>: <span class="keyword">this</span>.id, <span class="attr">username</span>: <span class="keyword">this</span>.username, <span class="attr">time</span>: <span class="keyword">new</span> <span class="built_in">Date</span>() &#125;;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.list.push(user);</span></span><br><span class="line">            &#125;,</span><br><span class="line">            del(id) &#123;</span><br><span class="line"><span class="javascript">                <span class="comment">// some()是操作数组的方法，作用是循环数组，并当return true是就终止循环</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">// 其中的user理解为循环list元素的别名，i表示索引</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.list.some(<span class="function">(<span class="params">user, i</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">if</span> (user.id == id) &#123;</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">this</span>.list.splice(i, <span class="number">1</span>);</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2018/07/22/vue/vue-2/1.png" alt></p>
<h1 id="Vue实例的生命周期"><a href="#Vue实例的生命周期" class="headerlink" title="Vue实例的生命周期"></a>Vue实例的生命周期</h1><ul>
<li>什么是声明周期：从Vue实例创建、运行、到销毁期间，伴随着发生的事件的过程成为生命周期。</li>
<li>生命周期钩子：就是声明周期事件的别名。</li>
<li>主要的声明周期函数分类</li>
</ul>
<blockquote>
<p>创建期间的声明周期函数：<br>    * beforeCreate: 实例刚在内存中被创建，此时，还没有初始化好data和methods属性。<br>    * created: 实例已经在内存中创建好，此时data和methods已经创建好，但还没有编译模板。<br>    * beforeMount: 此时已经完成了模板的编译，但是还没有挂载到页面上。<br>    * mounted: 此时，已经将编译好的模板，挂载到了页面指定的容器中。</p>
<p>运行期间的声明周期函数:<br>    * beforeUpdate: 状态更新之前执行此函数，此时的data数据是最新的，但是此时还没有开始渲染DOM节点<br>    * updated: 实例更新完毕之后调用此函数，此时data中的状态值和界面上显示的数据都是最新的，界面已经被重新渲染好了。</p>
<p>销毁期间的生命周期函数<br>    * beforeDestory: 实例销毁之前调用，在这一步，实例仍然可以使用。<br>    * destroyed: Vue实例销毁后调用，调用后，Vue实例指示的所有东西都会解除绑定，所有的事件监听器都会被移除，所所有的子实例也会被销毁。</p>
</blockquote>
<h2 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate"></a>beforeCreate</h2><p>此函数执行的时候，<code>data</code>和<code>methods</code>中的数据还没有初始化。</p>
<p><img src="/2018/07/22/vue/vue-2/2.png" alt><br><img src="/2018/07/22/vue/vue-2/3.png" alt></p>
<h2 id="created"><a href="#created" class="headerlink" title="created"></a>created</h2><p>此函数中，data和methods都已经初始化好了，如果需要调用<code>methods</code>中的方法或操作<code>data</code>中的值最早就在<code>created</code>函数中操作。</p>
<p><img src="/2018/07/22/vue/vue-2/4.png" alt><br><img src="/2018/07/22/vue/vue-2/5.png" alt></p>
<h2 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount"></a>beforeMount</h2><p>此函数执行的时候，模板已经在内存中编译好了，但是尚未挂载到页面中去。</p>
<p><img src="/2018/07/22/vue/vue-2/6.png" alt><br><img src="/2018/07/22/vue/vue-2/7.png" alt></p>
<h2 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h2><p>只要执行完了<code>mounted</code>，表示整个Vue实例已经初始化完毕了，此时组件已经进入了运行阶段。</p>
<p><img src="/2018/07/22/vue/vue-2/8.png" alt></p>
<h2 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h2><p><img src="/2018/07/22/vue/vue-2/lifecycle.png" alt></p>
<h1 id="vue-resource实现请求提交"><a href="#vue-resource实现请求提交" class="headerlink" title="vue-resource实现请求提交"></a>vue-resource实现请求提交</h1><p>作为一个后端开发者，我们需要的数据都应该是从数据库中取出来的，目前JSP页面越来越不常用，而更常用HTML页面，那么就体现出来类似Vue这种框架的好处了。</p>
<p>下面我们就了解一下怎样使用Vue实现发送AJAX的请求：</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>首先使用Vue实现发送AJAX请求，我们需要导入一个包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vue-resource.js</span><br></pre></td></tr></table></figure>

<p><strong>Methods</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.$http.get(&apos;url&apos;, [options]).then(successCallback, errorCallback);</span><br><span class="line"></span><br><span class="line">this.$http.post(&apos;url&apos;, [body], [options]).then(successCallback, errorCallback);</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<ul>
<li><code>this</code>表示的是当前Vue实例对象，而<code>vue-resource.js</code>提供了<code>$http</code>属性用来调用其内置的请求方法，并且<code>vue-resource.js</code>是基于<code>vue.js</code>的。</li>
<li><code>options</code>是指可选的请求参数，就是你发送请求想要传递的参数。</li>
<li><code>then</code>可以实现发送完请求后，通过其获取请求<strong>成功</strong>响应的数据</li>
<li><code>then</code>中包含两个参数<code>successCallback</code>和<code>errorCallback</code>，这两个都是对象，我们可以通过其进行对相应数据的操作。</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"getInfo"</span>&gt;</span>点击我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">	el: '#app',</span><br><span class="line">	data: &#123;&#125;,</span><br><span class="line">	methods: &#123;</span><br><span class="line">		getInfo()&#123;</span><br><span class="line">			this.$http.get('url').then(result =&gt; &#123;</span><br><span class="line">				console.log(result.body);</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong><br>当我们请求成功后，可以通过<code>then</code>来获取请求成功响应的数据，而可以通过<code>.data</code>或<code>.body</code>来获取响应data，而我们通常使用<code>result.body</code>来获取具体响应的参数。注意其中的<code>result =&gt; {}</code>是ES6中的写法。</p>
<h2 id="post请求"><a href="#post请求" class="headerlink" title="post请求"></a>post请求</h2><p><strong>注意：</strong> post请求常用于类似提交表单的功能，而对于提交表单，存在一个表单提交格式，默认是：<code>application/x-wwww-form-urlencoded</code> ；而通过Vue发起的post请求，默认没有表单格式，所以，有的服务器就处理不了。</p>
<p>那么我们可以通过post方法的第三个参数：<code>{ emulateJSON: true }</code>来设置提交内容类型为普通表单数据格式。</p>
<p><strong>实例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.$http.post(&apos;url&apos;, &#123;&#125;, &#123; emulateJSON: true &#125;).then(result =&gt; &#123;</span><br><span class="line">    console.log(result.body)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>其他请求方法与上面的雷同，具体方法请参考官方文档。</p>
<h1 id="请求接口根域名配置"><a href="#请求接口根域名配置" class="headerlink" title="请求接口根域名配置"></a>请求接口根域名配置</h1><p>由于我们个人的项目可能是部署到本地的Tomcat服务器上的，可能不会涉及请求接口的域名配置，那么我们先看一个案例：</p>
<p>发送post请求到服务器接口</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">	add()&#123;</span><br><span class="line">		this.$http.post('http://tycoding.cn/api/add', &#123;&#125;, &#123;emulateJSON: true&#125;).then(result =&gt; &#123;</span><br><span class="line">			</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，当我们发送请求的时候，URL路径需要写上域名地址<code>http://tycoding.cn</code>，然后才是请求路径<code>/api/add</code>，那么我们每次发送ajax请求都会需要写这个域名地址，就会显得比较麻烦，所以<code>Vue-resource</code>给我们提供了一种设置默认请求<strong>根域名</strong>的配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.http.options.root = &apos;http://tycoding.cn/&apos;;</span><br></pre></td></tr></table></figure>

<p>如上，就是一个全局的请求根域名配置。</p>
<p><strong>注意</strong><br>仅了解了上面的配置可能请求还会404，那么我们需要知道：</p>
<blockquote>
<p>如果我们通过了全局配置请求接口的根域名，那么每次发送HTTP请求时，请求的URL路径应该以相对域名开头，即前面不能带<code>/</code>：
    * 如果<code>this.$http.post(&#39;/xxx&#39;)</code>请求URL带了<code>/</code>，那么Vue就不会启用上面的全局请求根域名配置，就会404.<br>    * 如果前面不带<code>/</code>即：<code>this.$http.post(&#39;xxx&#39;)</code>，那么就会启用上面的全局请求根域名配置进行URL的拼接</p>
</blockquote>
<h2 id="全局配置表单提交格式选项"><a href="#全局配置表单提交格式选项" class="headerlink" title="全局配置表单提交格式选项"></a>全局配置表单提交格式选项</h2><p>上面讲到了如果使用<code>post</code>请求提交<strong>表单</strong>，那么你应该指定<code>{emulateJSON: true}</code>参数，那么每次进行post请求都指定又会显得很麻烦，那么<code>vue-resource</code>也给我们提供了一个全局配置的方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.http.options.emulateJSON = true;</span><br></pre></td></tr></table></figure>

<p>这样我们就不需要再post请求中再配置第三个参数了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">	add()&#123;</span><br><span class="line">		this.$http.post(&apos;http://tycoding.cn/api/add&apos;, &#123;&#125;).then(result =&gt; &#123;</span><br><span class="line">			</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><p>请求后台并即时渲染表格数据的案例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- html段 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"username"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"添加"</span> @<span class="attr">click</span>=<span class="string">"add"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">th</span>&gt;</span>编号<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">th</span>&gt;</span>用户名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">th</span>&gt;</span>操作<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">tr</span> <span class="attr">v-for</span>=<span class="string">"user in list"</span> <span class="attr">:key</span>=<span class="string">"user.id"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;user.id&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;user.username&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> @<span class="attr">click.pervent</span>=<span class="string">"del(user.id)"</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- javascript段 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="comment">// 设置全局根域名</span></span></span><br><span class="line"><span class="javascript">Vue.http.options.root = <span class="string">'http://tycoding.cn/'</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="comment">//设置全局表单提交格式</span></span></span><br><span class="line"><span class="javascript">Vue.http.options.emulateJSON = <span class="literal">true</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="comment">// 实例化Vue</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">	el: <span class="string">''</span>,</span></span><br><span class="line">	data: &#123;</span><br><span class="line"><span class="javascript">		username: <span class="string">''</span>,</span></span><br><span class="line">		list: []</span><br><span class="line">	&#125;,</span><br><span class="line">	created: &#123;</span><br><span class="line"><span class="javascript">		<span class="comment">// 因为进入列表页面就需要在列表中显示出数据，那么就需要实现加载页面时自动加载findAll方法</span></span></span><br><span class="line"><span class="javascript">		<span class="comment">// 而之前我们已经知道了，Vue的声明周期中，最早可以操作methods和data中的数据的阶段是：created生命周期函数阶段。</span></span></span><br><span class="line"><span class="javascript">		<span class="comment">// 那么在这里调用findAll方法即可</span></span></span><br><span class="line"><span class="javascript">		<span class="keyword">this</span>.findAll();</span></span><br><span class="line">	&#125;,</span><br><span class="line">	methods: &#123;</span><br><span class="line"><span class="javascript">		<span class="comment">// 查询所有列表数据</span></span></span><br><span class="line">		findAll()&#123;</span><br><span class="line"><span class="javascript">			<span class="keyword">this</span>.$http.get(<span class="string">'api/findAll'</span>).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">				<span class="keyword">this</span>.list = result.body;</span></span><br><span class="line">			&#125;),</span><br><span class="line">		&#125;,</span><br><span class="line"></span><br><span class="line"><span class="javascript">		<span class="comment">// 添加功能</span></span></span><br><span class="line">		add()&#123;</span><br><span class="line"><span class="javascript">			<span class="keyword">this</span>.$http.post(<span class="string">'api/add'</span>, &#123;<span class="attr">username</span>: <span class="keyword">this</span>.username&#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">				<span class="keyword">if</span>(result.body.status == <span class="number">0</span>)&#123;</span></span><br><span class="line"><span class="javascript">					<span class="comment">// 如果状态码为0就表示请求成功，这个状态码的值根据实际定</span></span></span><br><span class="line"><span class="javascript">					<span class="comment">// 请求成功，即添加了一条新的数据，那么需要重新刷新列表（不然新数据不能及时的更新到页面上）</span></span></span><br><span class="line"><span class="javascript">					<span class="keyword">this</span>.findAll()</span></span><br><span class="line"><span class="javascript">				&#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">					alert(<span class="string">'添加失败'</span>);</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;,</span><br><span class="line"></span><br><span class="line"><span class="javascript">		<span class="comment">//删除功能</span></span></span><br><span class="line">		del(id)&#123;</span><br><span class="line"><span class="javascript">			<span class="keyword">this</span>.$http.get(<span class="string">'api/del'</span> + id).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">				<span class="keyword">if</span>(result.body.status == <span class="number">0</span>)&#123;</span></span><br><span class="line"><span class="javascript">					<span class="comment">//请求成功</span></span></span><br><span class="line"><span class="javascript">					<span class="comment">//刷新列表</span></span></span><br><span class="line"><span class="javascript">					<span class="keyword">this</span>.findAll();</span></span><br><span class="line"><span class="javascript">				&#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">					alert(<span class="string">'删除失败'</span>);</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如上我们已经完成了常见的几个功能，后面我们将会介绍基于<code>SpringMVC</code>框架，实现与Vue整合并重写增删改查功能。</p>
<p><strong>注意：</strong></p>
<ul>
<li><p>1、首先我们需要配置根域名，且具体的AJAX请求URL不能添加’/‘；如果是基于本地的Tomcat服务器的项目，可能不需要配置根域名，具体视情况而定</p>
</li>
<li><p>2、实现查询所有列表数据功能，<strong>思路</strong>是：1、发送AJAX请求数据；2、将响应的数据赋值给data中的list集合<code>this.list = result.body</code>。注意响应数据是存放到body中的，具体请F12查看浏览器请求头信息和响应头信息。</p>
</li>
<li><p>3、上面获取了数据库中的列表数据，我们需要渲染到页面上，那么点击进入列表页面，列表页面中应该立即显示数据库中的所有数据，即<code>findAll</code>方法应该在初始化页面的同时自动去调用，并将数据赋值给list列表。而我们之前讲过操作methods和data中参数的最早时机是<code>created</code>声明周期函数阶段，那么我们直接在<code>created</code>函数中调用<code>findAll</code>方法即可实现自动加载。</p>
</li>
<li><p>4、添加功能的<strong>思路</strong>：1、在<code>data</code>中先声明需要添加的参数；2、在表单中用<code>v-model</code>绑定需要添加的参数；3、点击添加功能按钮，绑定<code>@click</code>事件，在<code>methods</code>中写对应的方法；4、发送AJAX请求，并在URL中拼接需要添加的数据（通过this.username）获取绑定的参数；5、如果是post请求，还需要设置表单提交格式<code>{emulateJSON: true}</code>，而我们使用了全局配置就不需要再在post参数中指定了；6、如果添加成功，就调用<code>findAll</code>方法重新刷新列表</p>
</li>
<li><p>6、删除功能需要在绑定<code>@click</code>事件的时候将<code>id</code>传入。并且我们需要使用<code>@click.pervent</code>来阻止<code>&lt;a&gt;</code>标签的默认跳转。</p>
</li>
<li><p>7、上面仅是提供演示，具体操作由实际情况而定.</p>
</li>
</ul>
<br>

<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>初识Vue</title>
    <url>/2018/07/21/vue/vue-1/</url>
    <content><![CDATA[<p><strong>什么是Vue.js</strong></p>
<ul>
<li>Vue.js是目前很火的前端框架；与Angular.js、React.js并称为前端三大主流框架。</li>
<li>Vue.js是一套构建用户界面的框架，只关注视图层（MVC中的V层）；它易于上手，便于和第三方库或既有项目整合，</li>
<li>在Vue中，一个核心的概念就是减少对DOM元素的操作，让程序员更多的去关注业务逻辑。</li>
</ul>
<a id="more"></a>

<h1 id="后端的MVC和前端的MVVM之间的区别"><a href="#后端的MVC和前端的MVVM之间的区别" class="headerlink" title="后端的MVC和前端的MVVM之间的区别"></a>后端的MVC和前端的MVVM之间的区别</h1><ul>
<li>MVC是后端的分层开发概念</li>
<li>MVVM是前端视图层的概念，主要关注于：视图层分离；也就是说：MVV将前端分为三个部分Model、View、VM（ViewModel）<ol>
<li>Model： 页面需要展示的数据</li>
<li>View: 视图、HTML</li>
<li>VM: 数据（Model）和视图（View）之间的调度者</li>
</ol>
</li>
</ul>
<p><strong>图解</strong><br><img src="/2018/07/21/vue/vue-1/1.png" alt></p>
<h1 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Vue实例的控制区域 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 插值表达式 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- js部分 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../lib/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">	<span class="comment">// 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span></span></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">		el: <span class="string">'#app'</span>, <span class="comment">// element的简写，表示我们当前new的这个Vue实例的区域</span></span></span><br><span class="line"><span class="javascript">		data: &#123;		<span class="comment">// data中存放的是el中需要的数据</span></span></span><br><span class="line"><span class="javascript">			msg: <span class="string">'Hello Vue!'</span></span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li>1、首先需要引入Vue.js</li>
<li>2、声明Vue实例的控制区域，我们可以放在指定div中，或者body体；控制区域下使用的Vue语法就会被Vue识别到</li>
<li>3、创建Vue实例，这个实例其实就是MVVM中的vm调度者</li>
<li>4、<code>el:</code> 表示当时Vue实例的控制区域；<code>data:</code> 存放当前Vue实例中所需的Model（数据）。其中的msg就是一个Vue的元素。</li>
<li>5、在指定Vue实例区域下，展示我们已经声明的元素<code>msg</code>，使用：<code></code>即可展示出来（其中msg是在Vue中声明的元素，如果未声明会报错）</li>
</ul>
<h1 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h1><h2 id="v-cloak"><a href="#v-cloak" class="headerlink" title="v-cloak"></a>v-cloak</h2><p>在入门案例中我们初步了解到，在View层我们可以通过插值表达式的方式展示Vue绑定的数据；但是存在一个问题，当网络很慢的情况下，即在<code>vue.js</code>还没有加载完毕时，视图层不会将<code></code>识别为Vue中的插值表达式，而是作为字符串显示到页面上。</p>
<p>为了解决这个问题，Vue.js提供了<code>v-cloak</code>指令，可以解决插值表达式闪烁的问题。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-cloak</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>扩展</strong><br>解决插值表达式闪烁问题，除了<code>v-cloak</code>指令，Vue还提供了<code>v-text</code>指令。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-text</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>v-cloak与v-text的区别</strong><br><code>v-text</code>默认会覆盖掉元素中原有的内容<br><code>v-cloak</code>不会覆盖掉原有的内容</p>
<p><img src="/2018/07/21/vue/vue-1/2.png" alt></p>
<h2 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h2><p>在上面，我们了解了<code>v-text</code>输出Vue元素，但是如果我们需要显示的数据是一段<code>HTML</code>代码，<code>v-text</code>和<code></code>都将无能为力，<br>为此，Vue提供了专门渲染HTML数据的指令：<code>v-html</code></p>
<p><img src="/2018/07/21/vue/vue-1/3.png" alt></p>
<p>上面我们学习的指令都是Vue内置的指令，那么在Vue内置的指令中显示Vue绑定的变量，这当然没毛病；但是如果直接在HTML属性中使用Vue绑定的指令（不是用<code></code>）这样可以吗？</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"msg"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>回答当然是不行的，因为在HTML属性中直接使用Vue绑定的变量，HTML并不能将其识别为其引用的是Vue中的元素，而是作为一个字符串输出。</p>
<p>为了解决上述问题，Vue提供了<code>v-bind:</code>指令来绑定一些HTML属性：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">v-bind:value</span>=<span class="string">"msg"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如上，被<code>v-bind:</code>绑定的属性，其元素不再是字符串，而是被识别为Vue的绑定的变量（同样这个变量必须声明了）。另外<code>v-bind:</code>还有一个简易写法：<code>:</code>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Vue实例的控制区域 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"msg"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">v-bind:value</span>=<span class="string">"msg"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">:value</span>=<span class="string">"msg"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- js部分 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../lib/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">'#app'</span>, <span class="comment">// element的简写，表示我们当前new的这个Vue实例的区域</span></span></span><br><span class="line"><span class="javascript">        data: &#123; <span class="comment">// data中存放的是el中需要的数据</span></span></span><br><span class="line"><span class="javascript">            msg: <span class="string">'戳我'</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2018/07/21/vue/vue-1/4.png" alt></p>
<h2 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h2><p>Vue提供了事件绑定机制的指令：<code>v-on:</code>；用其我们可以用来绑定一些常见的触发事件：click、mouseover …</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Vue实例的控制区域 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">:value</span>=<span class="string">"msg"</span> <span class="attr">v-on:click</span>=<span class="string">"show"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">:value</span>=<span class="string">"msg"</span> <span class="attr">v-on:mouseover</span>=<span class="string">"show"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- js部分 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../lib/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">'#app'</span>, <span class="comment">// element的简写，表示我们当前new的这个Vue实例的区域</span></span></span><br><span class="line"><span class="javascript">        data: &#123; <span class="comment">// data中存放的是el中需要的数据</span></span></span><br><span class="line"><span class="javascript">            msg: <span class="string">'戳我'</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line"><span class="javascript">        	show: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        		alert(<span class="string">"hello"</span>);</span></span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中<code>methods</code>是Vue内置的<strong>对象</strong>，用于存放一些自定义的方法函数</p>
<p><strong>拓展</strong><br>使用js内置的函数<code>setInterval</code>(定时器)，实现跑马灯效果：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Vue实例的控制区域 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"开始"</span> @<span class="attr">click</span>=<span class="string">"action"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"停止"</span> @<span class="attr">click</span>=<span class="string">"stop"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- js部分 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../lib/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">'#app'</span>, <span class="comment">// element的简写，表示我们当前new的这个Vue实例的区域</span></span></span><br><span class="line"><span class="javascript">        data: &#123; <span class="comment">// data中存放的是el中需要的数据</span></span></span><br><span class="line"><span class="javascript">            msg: <span class="string">'嘻嘻，哈哈'</span>,</span></span><br><span class="line"><span class="javascript">            intervalId: <span class="literal">null</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">        	action()&#123;</span><br><span class="line"><span class="javascript">        		<span class="keyword">if</span>(<span class="keyword">this</span>.intervalId != <span class="literal">null</span>) <span class="keyword">return</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        		<span class="comment">// 定时器</span></span></span><br><span class="line"><span class="javascript">        		<span class="keyword">this</span>.intervalId = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        			<span class="comment">// 截取首字符</span></span></span><br><span class="line"><span class="javascript">        			<span class="keyword">var</span> start = <span class="keyword">this</span>.msg.substring(<span class="number">0</span>, <span class="number">1</span>);</span></span><br><span class="line"><span class="javascript">        			<span class="comment">// 截取第一个字符后的所有字符</span></span></span><br><span class="line"><span class="javascript">        			<span class="keyword">var</span> end = <span class="keyword">this</span>.msg.substring(<span class="number">1</span>);</span></span><br><span class="line"><span class="javascript">        			<span class="comment">// 将后面的字符拼接到前面，实现循环的效果</span></span></span><br><span class="line"><span class="javascript">        			<span class="keyword">this</span>.msg = end + start;</span></span><br><span class="line">        		&#125;,400)</span><br><span class="line">        	&#125;,</span><br><span class="line">        	stop()&#123;</span><br><span class="line"><span class="javascript">	        	<span class="comment">// 停止定时器</span></span></span><br><span class="line"><span class="javascript">        		clearInterval(<span class="keyword">this</span>.intervalId)</span></span><br><span class="line"><span class="javascript">        		<span class="comment">// 每次清除定时器后需要将intervalId重新设置为null</span></span></span><br><span class="line"><span class="javascript">        		<span class="keyword">this</span>.intervalId = <span class="literal">null</span>;</span></span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong><br>1、<code>v-on:</code>也有简写形式：<code>@</code>，用法如上。<br>2、在视图层取VM中的数据我们可以使用<code></code>或一些内置指令；而在VM实例内部获取定义的其他变量或方法等，使用：<code>this.数据属性名</code>（其中的this表示当前VM实例对象）。<br>3、<code>methodName:function(){}</code>在ES6中有一个简便的写法：<code>methodName(){}</code>。
4、<code>setInterval()</code>和<code>clearInterval()</code>是js中内置的函数，用法如上。<br>5、正常我们调用函数会写：<code>name(function(){})</code>，而ES6也提供了一个方式：<code>methodName(() =&gt; {})</code>，这种用法的好处就解决了<code>this</code>指向问题，因为如果元素定义在了函数内部，那么其中的<code>this</code>就表示当前函数的对象，如果我们需要使用外部的对象，除了在外部全局定义一个对象，一个简单的方式就是使用ES6提供的<code>=&gt;</code>。</p>
<p><img src="/2018/07/21/vue/vue-1/5.png" alt></p>
<h2 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h2><blockquote>
<p>.stop 阻止冒泡<br>.prevent 阻止默认事件<br>.capture 添加时间侦听器时使用时间捕获模式<br>.self 只当事件在该元素本身（比如不是子元素）触发时触发回调<br>.once 事件只触发一次</p>
</blockquote>
<p>用法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Vue实例的控制区域 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">"divClick"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"戳我"</span> @<span class="attr">click.stop</span>=<span class="string">"btnClick"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"戳我"</span> @<span class="attr">click.prevent</span>=<span class="string">"btnClick"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- js部分 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../lib/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">	<span class="comment">// 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span></span></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">	    el: <span class="string">'#app'</span>, <span class="comment">// element的简写，表示我们当前new的这个Vue实例的区域</span></span></span><br><span class="line"><span class="javascript">	    data: &#123; <span class="comment">// data中存放的是el中需要的数据</span></span></span><br><span class="line"><span class="javascript">	        msg: <span class="string">'嘻嘻，哈哈'</span>,</span></span><br><span class="line">	    &#125;,</span><br><span class="line">	    methods: &#123;</span><br><span class="line">	        divClick() &#123;</span><br><span class="line"><span class="javascript">	        	<span class="built_in">console</span>.log(<span class="string">"这是div的点击事件"</span>);</span></span><br><span class="line">	        &#125;,</span><br><span class="line">	        btnClick() &#123;</span><br><span class="line"><span class="javascript">	        	<span class="built_in">console</span>.log(<span class="string">"这是btn的点击事件"</span>);</span></span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><ul>
<li>唯一的双向绑定指令：<code>v-model</code></li>
<li>单向绑定指令：<code>v-bing</code></li>
</ul>
<p><strong>实例</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Vue实例的控制区域 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"msg"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- js部分 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../lib/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">	<span class="comment">// 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span></span></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">	    el: <span class="string">'#app'</span>, <span class="comment">// element的简写，表示我们当前new的这个Vue实例的区域</span></span></span><br><span class="line"><span class="javascript">	    data: &#123; <span class="comment">// data中存放的是el中需要的数据</span></span></span><br><span class="line"><span class="javascript">	        msg: <span class="string">'hello!'</span>,</span></span><br><span class="line">	    &#125;,</span><br><span class="line">	    methods: &#123;</span><br><span class="line"></span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2018/07/21/vue/vue-1/6.png" alt></p>
<h2 id="vue中的样式"><a href="#vue中的样式" class="headerlink" title="vue中的样式"></a>vue中的样式</h2><h3 id="外联样式"><a href="#外联样式" class="headerlink" title="外联样式"></a>外联样式</h3><ul>
<li><p>数组<br><code>&lt;h2 :class=&quot;[&#39;italic&#39;,&#39;color&#39;]&quot;&gt;涂陌&lt;/h2&gt;</code><br>其中的italic、color是自定义的类名，需在外部定义CSS样式</p>
</li>
<li><p>数组中嵌套对象<br><code>&lt;h2 :class=&quot;[&#39;italic&#39;,{&#39;color&#39;: flag}]&quot;&gt;涂陌&lt;/h2&gt;</code><br>其中的flag是Vue绑定的变量，在<code>data</code>进行声明</p>
</li>
<li><p>直接使用对象<br><code>&lt;h2 :class=&quot;{italic:true, color:flag}&quot;&gt;涂陌&lt;/h2&gt;</code></p>
</li>
</ul>
<p><strong>实例</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">	.italic &#123;</span><br><span class="line">	    font-style: italic;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	.color &#123;</span><br><span class="line">	    color: skyblue;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Vue实例的控制区域 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">h2</span> <span class="attr">:class</span>=<span class="string">"['italic','color']"</span>&gt;</span>涂陌<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">:class</span>=<span class="string">"['italic', &#123;'color':flag&#125;]"</span>&gt;</span>涂陌<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">:class</span>=<span class="string">"&#123;italic:false, color:flag&#125;"</span>&gt;</span>涂陌<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- js部分 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../lib/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">	<span class="comment">// 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span></span></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">	    el: <span class="string">'#app'</span>, <span class="comment">// element的简写，表示我们当前new的这个Vue实例的区域</span></span></span><br><span class="line"><span class="javascript">	    data: &#123; <span class="comment">// data中存放的是el中需要的数据</span></span></span><br><span class="line"><span class="javascript">	        flag: <span class="literal">true</span></span></span><br><span class="line">	    &#125;,</span><br><span class="line">	    methods: &#123;</span><br><span class="line"></span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2018/07/21/vue/vue-1/7.png" alt></p>
<h3 id="内联样式"><a href="#内联样式" class="headerlink" title="内联样式"></a>内联样式</h3><ul>
<li><p>将样式对象定义到<code>data</code>中，并在<code>:style</code>中引用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">:style</span>=<span class="string">"styleObj"</span>&gt;</span>涂陌<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">	styleObj: &#123; 'color': 'red', 'font-weight': '200px'&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>:style</code>中通过数组，引用多个<code>data</code>上的样式对象</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">:style</span>=<span class="string">"[styleObj, styleObj2]"</span>&gt;</span>涂陌<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">	styleObj: &#123; 'color': 'red', 'font-weight': '200px'&#125;,</span><br><span class="line">	styleObj2: &#123; 'font-style': 'italic' &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>实例</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Vue实例的控制区域 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">:style</span>=<span class="string">"styleObj"</span>&gt;</span>涂陌<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">:style</span>=<span class="string">"[styleObj, styleObj2]"</span>&gt;</span>涂陌<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- js部分 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../lib/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">	<span class="comment">// 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span></span></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">	    el: <span class="string">'#app'</span>, <span class="comment">// element的简写，表示我们当前new的这个Vue实例的区域</span></span></span><br><span class="line"><span class="javascript">	    data: &#123; <span class="comment">// data中存放的是el中需要的数据</span></span></span><br><span class="line"><span class="javascript">	        styleObj: &#123; <span class="string">'color'</span>: <span class="string">'red'</span>, <span class="string">'font-weight'</span>: <span class="string">'200px'</span> &#125;,</span></span><br><span class="line"><span class="javascript">	        styleObj2: &#123; <span class="string">'font-style'</span>: <span class="string">'italic'</span> &#125;</span></span><br><span class="line">	    &#125;,</span><br><span class="line">	    methods: &#123;</span><br><span class="line"></span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2018/07/21/vue/vue-1/8.png" alt></p>
<h2 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h2><p>Vue提供了遍历集合、数组的指令：<code>v-for</code>；用法: <code>v-for=&quot;别名 in 集合名&quot;</code></p>
<h3 id="迭代数组"><a href="#迭代数组" class="headerlink" title="迭代数组"></a>迭代数组</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-for</span>=<span class="string">"item, i in list"</span>&gt;</span>索引：&#123;&#123;i&#125;&#125; --- 值：&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">	list: [1,2,3,4]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的<code>i</code>是迭代得到的别名，可写可不写，但是必须是在迭代元素别名的后面定义</p>
<h3 id="迭代对象数组"><a href="#迭代对象数组" class="headerlink" title="迭代对象数组"></a>迭代对象数组</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-for</span>=<span class="string">"item in list2"</span>&gt;</span>id: &#123;&#123;item.id&#125;&#125; --- name: &#123;&#123;item.name&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">	list2: [</span><br><span class="line">        	&#123; id:1, name: '嘻嘻' &#125;,</span><br><span class="line">        	&#123; id:2, name: '哈哈' &#125;</span><br><span class="line">        ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代对象数组，通过    <code></code>的方式，这个属性名就是对象数组中定义的元素属性名</p>
<h3 id="迭代对象"><a href="#迭代对象" class="headerlink" title="迭代对象"></a>迭代对象</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-for</span>=<span class="string">"(val, key) in user"</span>&gt;</span>键: &#123;&#123;key&#125;&#125; --- 值: &#123;&#123;val&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">	user: &#123;</span><br><span class="line">        	id: 1,</span><br><span class="line">        	name: '涂陌'</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代对象，迭代得到的是对象的<code>value</code>值和<code>key</code>值，注意得到的第一个是value值，第二个是key值，与我们定义的对象属性顺序是刚好相反的。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Vue实例的控制区域 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-for</span>=<span class="string">"item, i in list"</span>&gt;</span>索引：&#123;&#123;i&#125;&#125; --- 值：&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-for</span>=<span class="string">"item in list2"</span>&gt;</span>id: &#123;&#123;item.id&#125;&#125; --- name: &#123;&#123;item.name&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-for</span>=<span class="string">"(val, key) in user"</span>&gt;</span>键: &#123;&#123;key&#125;&#125; --- 值: &#123;&#123;val&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- js部分 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../lib/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">	<span class="comment">// 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span></span></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">	    el: <span class="string">'#app'</span>, <span class="comment">// element的简写，表示我们当前new的这个Vue实例的区域</span></span></span><br><span class="line"><span class="javascript">	    data: &#123; <span class="comment">// data中存放的是el中需要的数据</span></span></span><br><span class="line">	        list: [1,2,3,4], </span><br><span class="line">	        list2: [</span><br><span class="line"><span class="javascript">	        	&#123; <span class="attr">id</span>:<span class="number">1</span>, <span class="attr">name</span>: <span class="string">'嘻嘻'</span> &#125;,</span></span><br><span class="line"><span class="javascript">	        	&#123; <span class="attr">id</span>:<span class="number">2</span>, <span class="attr">name</span>: <span class="string">'哈哈'</span> &#125;</span></span><br><span class="line">	        ],</span><br><span class="line">	        user: &#123;</span><br><span class="line">	        	id: 1,</span><br><span class="line"><span class="javascript">	        	name: <span class="string">'涂陌'</span></span></span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;,</span><br><span class="line">	    methods: &#123;</span><br><span class="line"></span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2018/07/21/vue/vue-1/9.png" alt></p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>在vue2.0+版本里，当使用<code>v-for</code>渲染数据，必须制定对应的<code>key</code>值（这里的key是一个属性，不是前面迭代的key值）。</p>
<p><strong>用法:</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-for</span>=<span class="string">"item in user"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中<code>:key</code>就说明了key属性必须是通过<code>v-bind</code>绑定的元素，而<code>:key=&quot;&quot;</code>中指定的值必须是<code>string/number</code>类型的值，比如此处使用的是<code>item.id</code>中ID是number值，并且是唯一的。</p>
<p><strong>目的：</strong><br>避免迭代元素时，为循环元素绑定的是列表中的第几个元素（指定位置），而不是指定的某个元素（指定身份）。</p>
<h2 id="v-show和v-if"><a href="#v-show和v-if" class="headerlink" title="v-show和v-if"></a>v-show和v-if</h2><p>Vue提供了两个指令来实现元素显示状态的切换：<code>v-if</code> <code>v-show</code></p>
<p><strong>区别</strong></p>
<ul>
<li><p><code>v-if</code>的特点：每次都会重新删除和创建元素，具有较高的切换性能消耗（因为每次执行都要进行删除和创建元素）。</p>
</li>
<li><p><code>v-show</code>的特点：每次不会重建进行DOM的删除和创建操作，只是切换了元素的<code>display:none</code>样式，具有较高的初识渲染消耗（即每次都只是将元素隐藏了，并没有真正的删除掉）。</p>
</li>
</ul>
<p><strong>实例</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Vue实例的控制区域 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> @<span class="attr">click</span>=<span class="string">"flag=!flag"</span> <span class="attr">value</span>=<span class="string">"toggle"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span> <span class="attr">v-if</span>=<span class="string">"flag"</span>&gt;</span>这是v-if控制的元素<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span> <span class="attr">v-show</span>=<span class="string">"flag"</span>&gt;</span>这是v-show控制的元素<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- js部分 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../lib/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 创建Vue实例，这个new出来的对象就是MVVM中的vm调度者</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">'#app'</span>, <span class="comment">// element的简写，表示我们当前new的这个Vue实例的区域</span></span></span><br><span class="line"><span class="javascript">        data: &#123; <span class="comment">// data中存放的是el中需要的数据</span></span></span><br><span class="line"><span class="javascript">            flag: <span class="literal">false</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2018/07/21/vue/vue-1/10.png" alt></p>
<p><img src="/2018/07/21/vue/vue-1/11.png" alt></p>
<br>

<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>一个案例带你入门SSM框架开发</title>
    <url>/2018/06/05/ssm/ssm-2/</url>
    <content><![CDATA[<p><strong>SSM框架快速入门</strong></p>
<p>关于SSM框架环境搭建，请点击这里前往我的博客：<a href="http://tycoding.cn/2018/06/04/ssm/ssm/" target="_blank" rel="noopener">SSM框架整合之环境搭建</a><br>由于本项目采用了maven，关于IDEA搭建maven项目过程请点击这里前往我的博客：<a href="http://tycoding.cn/2018/06/01/ssm/maven/" target="_blank" rel="noopener">maven起步</a></p>
<p>项目源码请 <a href="https://github.com/TyCoding/ssm" target="_blank" rel="noopener">点击进入</a> </p>
<p>我的GitHub。如果觉得不错，欢迎右上角star鼓励一下作者哦！</p>
<a id="more"></a>

<h1 id="关于项目"><a href="#关于项目" class="headerlink" title="关于项目"></a>关于项目</h1><h2 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">后端：spring+mybatis+springmvc </span><br><span class="line">前端：bootstrap+Font Awesome图标集</span><br><span class="line">测试环境：IDEA + tomcat8 + mysql5.7 + jdk8 + maven</span><br></pre></td></tr></table></figure>

<h2 id="项目功能"><a href="#项目功能" class="headerlink" title="项目功能"></a>项目功能</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 实现用户登录功能</span><br><span class="line">2. 实现客户信息的增删改查功能</span><br><span class="line">3. 实现分页查询功能（使用PageHelper分页插件实现）</span><br></pre></td></tr></table></figure>

<h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── README.md </span><br><span class="line">├── img  -- 放了一些README.md文档所需要的图片，没有实际意义</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        ├── java</span><br><span class="line">        │   └── cn</span><br><span class="line">        │       └── tycoding</span><br><span class="line">        │           ├── controller  -- SpringMVC-WEB层控制器</span><br><span class="line">        │           ├── mapper  -- Mybatis接口和映射文件。本项目采用了mybatis的接口开发，所以接口和映射文件放在同一目录下，并且名称相同。</span><br><span class="line">        │           ├── pojo  -- JavaBean实体类</span><br><span class="line">        │           └── service  -- service业务层</span><br><span class="line">        ├── resources  -- maven项目存放配置文件的根目录(classpath:)</span><br><span class="line">        │   ├── sys_schema.sql  -- 项目数据库创建和表创建的SQL语句</span><br><span class="line">        │   ├── resource  -- 日志打印和数据源配置文件</span><br><span class="line">        │   └── spring  -- spring和springmvc的配置文件</span><br><span class="line">        └── webapp  -- 项目的根目录</span><br><span class="line">            ├── WEB-INF</span><br><span class="line">            ├── fonts  -- 字体的配置文件</span><br><span class="line">            └── lib  -- 前端静态资源</span><br></pre></td></tr></table></figure>

<h2 id="整合思路"><a href="#整合思路" class="headerlink" title="整合思路"></a>整合思路</h2><p>继上一篇博文：<a href="http://tycoding.cn/2018/05/29/ssm/Spring-5/" target="_blank" rel="noopener">Spring MVC起步</a>其实我们已经了解了如何整合Spring和Spring MVC框架。那么，接下来我们就需要了解如何在此基础上整合Mybatis框架。<br>首先须知Mybatis框架是一个持久层框架，而Spring MVC是WEB层框架，Spring框架则充当着业务层的角色。那么将三者联系起来正好组成了<code>web--service--dao</code>的三层架构体系。那么整合思路就如下所示了：</p>
<ol>
<li>整合dao(即mapper)，实现Mybatis和Spring的整合</li>
<li>整合service，由Spring管理service接口，在service中可以调用dao（mapper）</li>
<li>整合web（controller），实现Spring MVC和Spring的整合，在controller中调用service</li>
</ol>
<h1 id="需求实现"><a href="#需求实现" class="headerlink" title="需求实现"></a>需求实现</h1><h2 id="1-实现用户登录功能"><a href="#1-实现用户登录功能" class="headerlink" title="1. 实现用户登录功能"></a>1. 实现用户登录功能</h2><h3 id="1-1-创建表结构"><a href="#1-1-创建表结构" class="headerlink" title="1.1 创建表结构"></a>1.1 创建表结构</h3><p>SQL语句请查看GitHub中resources目录下的.sql文件<br>除了创建表，我们同样要创建<code>pojo</code>对象，并提供属性setter和getter方法。（注意尽量保持<code>pojo</code>属性参数和表字段名称对应相等）</p>
<h3 id="1-2-编写Controller层"><a href="#1-2-编写Controller层" class="headerlink" title="1.2 编写Controller层"></a>1.2 编写Controller层</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/login"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(@RequestParam String username,@RequestParam String password, Model model)</span> </span>&#123;</span><br><span class="line">    User user = userService.login(username);</span><br><span class="line">    <span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (user.getPassword().equals(password)) &#123;</span><br><span class="line">            <span class="comment">//登录成功</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">"page/page"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            model.addAttribute(<span class="string">"message"</span>, <span class="string">"登录失败"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"page/loginInfo"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        model.addAttribute(<span class="string">"message"</span>, <span class="string">"你输入的用户名或密码有误"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"page/loginInfo"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@RequestMapping</code>标注<code>login()</code>方法有两个作用（前提是必须在XML中开启注解扫描<code>&lt;context:component-scan/&gt;</code>）：1.表示该方法是请求处理方法；2.指明了该方法的请求路径。<code>@RequestMapping</code>可以标记类或方法，分别表示了不同层级的请求路径。例如当前的<code>login()</code>方法的请求路径应为：<code>localhost:8080/xxx/login.do</code><br>对于请求体中包含多个参数的情况，我们尽量用<code>@RequestParam</code>标记参数，以免出现未知错误（但这不是必须的）。<br>用户登录，我们首先获取到用户登录的用户名<code>username</code>和密码<code>password</code>，然后根据用户名查询并返回，根据此用户名查询到的密码与登录的密码进行<code>equals</code>，如果相等就登录成功。（当然我们要判断根据<code>username</code>查询后的返回值是否为null，不做判断会产生空指针问题，如果一个空值和另一个值相比显然会报错）。<br>如果登录成功，将返回到<code>page/page.jsp</code>页面（这是根据我们在<code>springmvc.xml</code>下配置的视图解析器<code>InternalResourceViewResolver</code>决定的）;如果登录失败将返回到<code>page/loginInfo.jsp</code>页面。</p>
<h3 id="1-3-编写Mapper-xml"><a href="#1-3-编写Mapper-xml" class="headerlink" title="1.3 编写Mapper.xml"></a>1.3 编写Mapper.xml</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"login"</span> <span class="attr">parameterType</span>=<span class="string">"String"</span> <span class="attr">resultType</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">    select * from user where username = #&#123;username&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们使用了Mybatis的接口代理开发模式（保证接口和配置文件在同一目录下且名称相同），直接在<code>Mapper.xml</code>中编写原生sql语句，即可进行与数据库间的交互。其中：</p>
<ul>
<li><p><code>id</code>指明是哪个方法调用这个sql；</p>
</li>
<li><p><code>parameterType</code>指定了接口传递的参数类型(我们根据用户名查询所以是String类型)；</p>
</li>
<li><p><code>resultType</code>指定该查询语句返回值的数据类型（因为我们已经在配置文件启用了别名配置<code>typeAliases</code>，所以这里直接指定pojo对象类名即可；若没有启动别名配置，就必须写类的全限定名）。使用<code>#{}</code>会将传递的参数值会自动添加<code>&quot;&quot;</code>；注意<code>#{}</code>和<code>${}</code>区分，后者则是直接拼接传递进来的字符串，而不会添加任何符号，且前者能避免sql注入。</p>
</li>
</ul>
<h2 id="2-实现客户信息的添加"><a href="#2-实现客户信息的添加" class="headerlink" title="2. 实现客户信息的添加"></a>2. 实现客户信息的添加</h2><p>所谓添加客户信息，就是将JSP中提交的表单数据持久化到数据库中。</p>
<h3 id="2-1-创建表结构"><a href="#2-1-创建表结构" class="headerlink" title="2.1 创建表结构"></a>2.1 创建表结构</h3><p>建表SQL请看github项目中的resources目录下的.sql文件<br>同样我们还要创建对应的<code>pojo</code>，并提供getter和setter方法。（尽量保持<code>pojo</code>中的元素属性名称和表中字段名称相同）。</p>
<h3 id="2-2-编写Controller层"><a href="#2-2-编写Controller层" class="headerlink" title="2.2 编写Controller层"></a>2.2 编写Controller层</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/save"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">save</span><span class="params">(Customer customer, Model model)</span> </span>&#123;</span><br><span class="line">    customerService.save(customer);</span><br><span class="line">    model.addAttribute(<span class="string">"message"</span>, <span class="string">"保存客户信息系成功"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"page/info"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2018/06/05/ssm/ssm-2/1.png" alt></p>
<p>当点击了提交按钮，表单中的所有数据都应该被持久化到数据库中，而要知道表单中的参数有很多，我们直接在请求映射方法的参数列表中写参数显然是不可取的，那么我们如果写一个pojo对象，Spring就会根据这个pojo对象中的属性和JSP表单中的参数进行对应，如果完全对应那么请求方法会正常执行，一但有某个参数不对应，那么就会报错。（注意我们表单中并不需要指定<code>id</code>主键值，因为设计表时已经指定了该<code>id</code>主键为自增长，即使不指定值，<code>id</code>依然会自增，你指定了却可能会产生错误，因为到保证每次的<code>id</code>值都是递增的）。当数据持久化成功，就使用Spring的<code>Model</code>对象在域对象中设置一个名为<code>message</code>的值。最后再返回到视图层。</p>
<h3 id="2-3-编写Mapper-xml"><a href="#2-3-编写Mapper-xml" class="headerlink" title="2.3 编写Mapper.xml"></a>2.3 编写Mapper.xml</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"save"</span> <span class="attr">parameterType</span>=<span class="string">"Customer"</span>&gt;</span></span><br><span class="line">        insert into</span><br><span class="line">        customer(</span><br><span class="line">          name,</span><br><span class="line">          telephone,</span><br><span class="line">          address,</span><br><span class="line">          remark)</span><br><span class="line">        values(</span><br><span class="line">          #&#123;name&#125;,</span><br><span class="line">          #&#123;telephone&#125;,</span><br><span class="line">          #&#123;address&#125;,</span><br><span class="line">          #&#123;remark&#125;</span><br><span class="line">        );</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如上这仍然是普通的SQL语句，注意<code>parameterType</code>如上我们设置为<code>Customer</code>其实代表的是<code>cn.tycoding.pojo.Customer</code>这个对象，因为我们已经在<code>beans.xml</code>中启用了mybatis的别名配置。SQL插入语句中不需要指定<code>id</code>这个字段，原因是我们已经配置了<code>id</code>为自增主键</p>
<h2 id="3-实现客户信息的删除功能"><a href="#3-实现客户信息的删除功能" class="headerlink" title="3. 实现客户信息的删除功能"></a>3. 实现客户信息的删除功能</h2><h3 id="3-1-编写Controller层"><a href="#3-1-编写Controller层" class="headerlink" title="3.1 编写Controller层"></a>3.1 编写Controller层</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/delete"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">delete</span><span class="params">(@RequestParam <span class="keyword">int</span> id,Model model)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(customerService.delete(id) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        model.addAttribute(<span class="string">"message"</span>,<span class="string">"删除客户信息成功"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"page/info"</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">"message"</span>,<span class="string">"删除客户信息失败"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"page/info"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除功能只需要根据点击删除按钮时获取到的<code>id</code>值，在SQL的<code>delete</code>语句中<code>where</code>这个id值，即可以实现根据id删除客户信息。</p>
<h3 id="3-2-编写Mapper-xml"><a href="#3-2-编写Mapper-xml" class="headerlink" title="3.2 编写Mapper.xml"></a>3.2 编写Mapper.xml</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"delete"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span>&gt;</span></span><br><span class="line">    delete from customer where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如此，还是一个再普通不过的SQL语句，既可以实现根据id删除的功能。</p>
<h2 id="4-更新客户信息"><a href="#4-更新客户信息" class="headerlink" title="4. 更新客户信息"></a>4. 更新客户信息</h2><p>更新客户信息需要我们实现两个功能：1.再点击<em>编辑</em>按钮时(我们在按钮设置了<code>onclick=&quot;return edit(${xx.id};&quot;</code>)，如此我们用js监听这个事件，点击了按钮，js获取到id，请求后台根据这个id值查询数据库中的数据。那么我们先看一下js部分吧：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">edit</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">  $.ajax(&#123;</span><br><span class="line">    url: <span class="string">'xxx/findById.do'</span>,</span><br><span class="line">    type: <span class="string">'POST'</span>,</span><br><span class="line">    dataType: <span class="string">'json'</span>,</span><br><span class="line">    contentType: <span class="string">'application/json;charset=UTF-8'</span>,</span><br><span class="line">    data: <span class="built_in">JSON</span>.stringify(&#123;<span class="attr">id</span>: id&#125;),</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">      $(<span class="string">"#username"</span>).val(result.username);</span><br><span class="line">      $(<span class="string">"#password"</span>).val(result.password);</span><br><span class="line">      <span class="comment">//继续讲查询到的字段依次进行赋值...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实际是一个ajax请求json格式数据：</p>
<ol>
<li><p><code>type</code>指定请求类型；</p>
</li>
<li><p><code>dataType</code>指定了服务器返回数据格式类型；</p>
</li>
<li><p><code>contentType</code>指定发送给服务器的数据格式，默认是<code>application/x-www-form-urlencoded</code>会使此时的<code>data</code>参数为JSON对象，而设置为<code>application/json</code>后此时的<code>data</code>参数就是json字符串了，同样使用<code>stringify()</code>也是将<code>data</code>参数转换成json字符串。</p>
</li>
</ol>
<h3 id="4-1-编写Controller层"><a href="#4-1-编写Controller层" class="headerlink" title="4.1 编写Controller层"></a>4.1 编写Controller层</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/findById"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Customer <span class="title">findById</span><span class="params">(@RequestBody Customer customer)</span></span>&#123;</span><br><span class="line">    Customer customer_info = customerService.findById(customer.getId());</span><br><span class="line">    <span class="keyword">if</span>(customer_info != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> customer_info;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>@RequestBody</code>读取http请求内容，并将数据绑定在映射方法的参数上；</li>
<li><code>@ResponseBody</code>将映射需要返回的参数转换成指定的数据格式，而由于我们在ajax请求中指定<code>dataType</code>为<code>json</code>，那么<code>@ReqponseBody</code>将会返回json格式数据。</li>
</ul>
<p>当ajax请求了这个映射方法，Controller获取到指定的id去调用Service层根据这个id查询数据库<code>select * from customer where id = #{id}</code>。然后将数据拼装成JSON格式，并返回给页面。最后ajax会走success方法，我们从返回的数据<code>success:function(result)</code>中通过<code>result.xx</code>的方式取出来并通过jquery的<code>val()</code>方式赋值到指定的位置，那么就实现了数据回显。<br>实现修改功能，首先要知道原本的数据（数据回显），然后将修改后的数据在此存入到数据库中（<code>update customer set xx=#{xx} where id = #{id}</code>。那么我们看一下，更新数据库的Controller：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/update"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">update</span><span class="params">(Customer customer,Model model)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rows = customerService.update(customer);</span><br><span class="line">    <span class="keyword">if</span>(rows &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        model.addAttribute(<span class="string">"message"</span>,<span class="string">"更新客户信息成功"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"page/info"</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">"message"</span>,<span class="string">"更新客户信息失败"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"page/info"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为更新数据其实就是简单的提交表单，表单提交后访问这个映射方法，指定对应的<code>update</code>语句，如果没有异常抛出就更新成功，通过SpringMVC的Model方法向request域对象中存入成功信息，在返回的页面中，通过<code>${message}</code>EL表达式的方式取出提示信息。</p>
<p>最后我们看一下更新的SQL如何写：</p>
<h3 id="4-2-编写Mapper-xml"><a href="#4-2-编写Mapper-xml" class="headerlink" title="4.2 编写Mapper.xml"></a>4.2 编写Mapper.xml</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 更新客户信息的方法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"update"</span> <span class="attr">parameterType</span>=<span class="string">"Customer"</span>&gt;</span></span><br><span class="line">    update customer set</span><br><span class="line">        id = #&#123;id&#125;,</span><br><span class="line">        name = #&#123;name&#125;,</span><br><span class="line">        telephone = #&#123;telephone&#125;,</span><br><span class="line">        address = #&#123;address&#125;,</span><br><span class="line">        remark = #&#123;remark&#125;</span><br><span class="line">    where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="5-分页查询"><a href="#5-分页查询" class="headerlink" title="5. 分页查询"></a>5. 分页查询</h2><p>我们先看一下前端Bootstrap的分页效果</p>
<p><img src="/2018/06/05/ssm/ssm-2/2.png" alt></p>
<h3 id="5-1-封装PageBean"><a href="#5-1-封装PageBean" class="headerlink" title="5.1 封装PageBean"></a>5.1 封装PageBean</h3><p>这里我们使用Mybatis的分页查询插件：PageHelper。</p>
<blockquote>
<p>1.首先引入maven依赖：</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>2.定义一个PageBean，非必要，但是提取通用的PageBean实体类对象用来储存分页数据，能提高代码的重用率。</p>
</blockquote>
<p><strong>虽然</strong>我们这里使用了PageHelper分页插件，但是请弄清楚：pageHelper只是帮我们进行后端的数据分页，也就是说使用了PageHelper插件我们无需再写类似 <code>limit</code>这样的sql了。</p>
<p>而，我们的数据最终要显示到前端页面上，此时我们使用的bootstrap和javascript技术并不能实现前端分页自动计算，所以前端我们还是需要手动计算分页数据。</p>
<p>那么PageBean的定义不变：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当前页</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> pageCode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//总页数=总记录数/每页显示的记录数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> totalPage;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//总记录数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> totalCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每页显示的记录数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> pageSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每页显示的数据</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; beanList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为我们要实现分页查询，所以无法避免一些参数，这里直接将其封装为一个JavaBean就是为了方便调用，而配置自定义泛型<code>&lt;T&gt;</code>就是为了供多个对象的调用，如果你在对Customer类进行分页查询，那么在调用时只需要<code>new pageBean&lt;Customer&gt;()</code>即可将查询的数据绑定为<code>Customer</code>类的数据；对其他类进行分页亦是这样。</p>
<ul>
<li><p><strong>pageCode:</strong> 表示当前（你点击）的是第几页。</p>
</li>
<li><p><strong>totalPage:</strong> 表示总页数（总页数=总记录数/每页显示的记录数）。通过<code>select count(*) from 表</code>查询到总记录数，每页显示的记录是用户指定的；那么<em>总记录数/每页显示几条记录</em>就得到了一共有几页（前端页面展示）。</p>
</li>
<li><p><strong>totalCount:</strong> 表示总记录数，由SQL：<code>select count(*) from 表</code>查询到该表咋数据库中一共多少条记录数。</p>
</li>
<li><p><strong>pageSize:</strong> 表示每页显示的记录数，这个是用户决定的，比如我们想让每页显示5条数据，那么这个<code>pageSize</code>就应该是5，即每页会显示5条记录。</p>
</li>
<li><p><strong>beanList:</strong> 表示当前显示的数据。经上面的一系列查询和封装，我们最终需要将数据返回给页面，而这些需要返回给页面的数据最终会被封装到这个<code>beanList</code>中，在jsp中使用<code>&lt;forEach&gt;</code>标签遍历<code>beanList</code>得到封装的数据并显示到页面上。</p>
</li>
</ul>
<h3 id="5-2-jsp页面"><a href="#5-2-jsp页面" class="headerlink" title="5.2 jsp页面"></a>5.2 jsp页面</h3><p>由于我们前端仅使用了最基本的JavaScript和Bootstrap框架，很多特性都不能使用，所以这里用最基本的方式来实现前端的分页。当然以后我们学习了Vue.js, Angular.js, node.js这些高级JS语言后，就会发现前端数据渲染是如此的简单。</p>
<p><img src="/2018/06/05/ssm/ssm-2/3.png" alt></p>
<h3 id="5-3-编写Controller层"><a href="#5-3-编写Controller层" class="headerlink" title="5.3 编写Controller层"></a>5.3 编写Controller层</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/findByPage"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">findByPage</span><span class="params">(Customer customer,</span></span></span><br><span class="line"><span class="function"><span class="params">                         @RequestParam(value = <span class="string">"pageCode"</span>, required = <span class="keyword">false</span>, defaultValue = <span class="string">"1"</span>)</span> <span class="keyword">int</span> pageCode,</span></span><br><span class="line"><span class="function">                         @<span class="title">RequestParam</span><span class="params">(value = <span class="string">"pageSize"</span>, required = <span class="keyword">false</span>, defaultValue = <span class="string">"2"</span>)</span> <span class="keyword">int</span> pageSize,</span></span><br><span class="line"><span class="function">                         Model model) </span>&#123;</span><br><span class="line">    <span class="comment">// 回显数据</span></span><br><span class="line">    model.addAttribute(<span class="string">"page"</span>, customerService.findByPage(customer, pageCode, pageSize));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"page/list"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对比上面两张图，发现，用户可以指定的就是<code>pageCode</code>当前页和<code>pageSize</code>每页显示的记录数。所以在点击按钮（比如点击页码<code>3</code>），就会提交表单并访问Controller的<code>findByPage()</code>方法。<br>那么Controller就需要接受这两个参数:<code>pageCode</code>and<code>pageSize</code>，并且我们设置:<code>defaultValue</code>默认值；<code>required</code>是否必须指定（如果没有写false，在每次请求这个方法时就必须指定这个参数的具体值，不然就会报错）。<br>方法体中我们还通过<code>request</code>域获取<code>c_name</code>和<code>c_telephone</code>（因为要实现条件查询：输入信息，查询数据）。<br>最后我们将这些查询条件封装到Map集合中，然后调用Service层，将<code>pageCode</code>和<code>pageSize</code>以及封装的查询条件信息<code>conMap</code>一同传入Service层。</p>
<p>那么在Controller层我们使用了一个很简便的方式：<strong>实现分页查询和条件查询</strong>使用同一个方法；仔细想一下也很容易明白，分页查询和条件查询目的都是要将查询到的数据以分页的方式展示出来，只是两者限制的条件不同罢了。所以我们这样定义Controller：</p>
<ol>
<li><p>使用<code>Customer</code>实体类接收条件查询的条件，如果进行的是分页查询<code>Customer</code>中属性值为null也无影响；前端直接将要查询的条件<code>name</code>和<code>telephone</code>传入进来，使用<code>Customer</code>可以封装，因为<code>name</code>和<code>telephone</code>都是<code>Customer</code>的参数，这是Spring的自动装配特性。</p>
</li>
<li><p>使用<code>pageCode</code>和<code>pageSize</code>接收分页查询的条件，并且使用<code>defaultValue</code>设置两者的默认值，这里我们设置当前页默认为1，每页默认显示2条记录。</p>
</li>
<li><p>使用Model对象将查询到的数据封装进去，相当于存进了Request域对象中，JSP页面使用EL表达式即可取出来名字为<code>page</code>的List集合数据。</p>
</li>
</ol>
<h3 id="5-4-编写Service层"><a href="#5-4-编写Service层" class="headerlink" title="5.4 编写Service层"></a>5.4 编写Service层</h3><p>由于我们使用了Mybatis的PageHelper分页插件，所以无需手动计算分页数据，也不用编写<code>limit</code>类似的SQL语句。</p>
<p><strong>之前</strong></p>
<p>未使用PageHelper分页插件前我们这样定义Service层：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PageBean&lt;Customer&gt; <span class="title">findByPage</span><span class="params">(<span class="keyword">int</span> pageCode, <span class="keyword">int</span> pageSize, Map&lt;String, Object&gt; conMap)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line">        PageBean&lt;Customer&gt; pageBean = <span class="keyword">new</span> PageBean&lt;Customer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//封装当前页</span></span><br><span class="line">        pageBean.setPageCode(pageCode);</span><br><span class="line">        pageBean.setPageSize(pageSize);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 封装总记录数（从数据库中查询）</span></span><br><span class="line">        <span class="keyword">int</span> totalCount = customerMapper.selectCount();</span><br><span class="line">        System.out.println(<span class="string">"查询到的总记录数："</span>+totalCount);</span><br><span class="line">        pageBean.setTotalCount(totalCount);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//封装总页数</span></span><br><span class="line">        <span class="keyword">double</span> tc = totalCount;</span><br><span class="line">        Double num = Math.ceil(tc / pageSize);</span><br><span class="line">        pageBean.setTotalPage(num.intValue());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置limit分页查询的起始位置和终止位置</span></span><br><span class="line">        map.put(<span class="string">"start"</span>,(pageCode - <span class="number">1</span>) * pageSize);</span><br><span class="line">        map.put(<span class="string">"size"</span>,pageBean.getPageSize());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//封装每页显示的数据</span></span><br><span class="line">        List&lt;Customer&gt; list = customerMapper.findByPage(map);</span><br><span class="line">        pageBean.setBeanList(list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分页查询功能也要封装显示起始页和终止页</span></span><br><span class="line">        conMap.put(<span class="string">"start"</span>,(pageCode - <span class="number">1</span>) * pageSize);</span><br><span class="line">        conMap.put(<span class="string">"size"</span>,pageBean.getPageSize());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 封装</span></span><br><span class="line">        List&lt;Customer&gt; listCondition = customerMapper.findCondition(conMap);</span><br><span class="line">        pageBean.setBeanList(listCondition);</span><br><span class="line">        <span class="keyword">return</span> pageBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong></p>
<p>作为业务层，当然负责梳理业务信息，首先我们需要将Controller传入进来的<code>pageCode</code>和<code>pageSize</code>封装进<code>PageBean</code>的相关属性中。然后查询总记录数（通过<code>select count(*) from 表</code>查询得到），根据总记录数<code>pageCount</code>和前台传入的<code>pageSize</code>每页显示的记录数计算得到总页数，同样封装到<code>PageBean</code>中，最后我们要设置分页的起始位置<code>start</code>和数量<code>size</code>，调用Mapper查询数据库中的数据，将数据封装到<code>beanList</code>中即可。但是要注意我们其实写了两个分页查询的方法：<code>findByPage()</code>和<code>findCondition()</code>因为两者都需要分页展示到页面上。最后解释两点：</p>
<ol>
<li>计算总页数：总页数 = 总记录数 / 每页显示的记录条数。这里用到的ceil()方法：返回大于或登录参数的最小double值，并等于数学整数。如double a = 5;double b = 3;ceil(a/b) = 2.0。最后用Double类的intValue()方法返回此Double值作为int类型的值。</li>
<li>mysql为分页查询提供了limit方法，limit a,b就是读取第a条到第b条的所有记录。<br>设置<code>start</code>为<em>(当前页-1)此时每页显示的记录数</em>。
设置<code>size</code>为<em>我们在pageBean中封装的每页显示几条记录数</em>。
例如：我们目前页面每页显示2条数据，点击下一页，则显示的数据就是第<code>3 - 5</code>条。 </li>
</ol>
<p>即要手动进行数学运算，得到分页的数据，但是你是不是也觉得这样过于麻烦？PageHelper让我们简化了分页数据的计算，我们仅需要这样定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分页查询-条件查询方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> customer 查询条件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pageCode 当前页</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pageSize 每页的记录数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PageBean <span class="title">findByPage</span><span class="params">(Customer customer, <span class="keyword">int</span> pageCode, <span class="keyword">int</span> pageSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用Mybatis分页插件</span></span><br><span class="line">    PageHelper.startPage(pageCode, pageSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用分页查询方法，其实就是查询所有数据，mybatis自动帮我们进行分页计算</span></span><br><span class="line">    Page&lt;Customer&gt; page = customerMapper.findByPage(customer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PageBean(pageCode, (<span class="keyword">int</span>)(page.getTotal() / pageSize), (<span class="keyword">int</span>)page.getTotal(), pageSize, page.getResult());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为我们将条件查询和分页查询合为一个方法，所以这里出现三个参数。PageHelper有一个构造函数<code>starPage()</code>，将pageCode当前页和pageSize每页的记录数传入即可完成之前的一系列数学运算。</p>
<p>查询需要调用Mapper层的<code>findByPage(customer)</code>方法:</p>
<ol>
<li>首先需要指定Mapper层的<code>findByPage()</code>方法的返回值是Page类型，因为是PageHelper查询进行的数据分页；</li>
<li>需要将<code>customer</code>参数传入，因为我们条件查询也调用这个方法，查询的条件就封装在Customer对象中；</li>
<li>返回值是PageBean类型，需要调用PageBean中带参构造函数，将查询到的数据依次封装到PageBean对象中，最终返给前端JSP页面；</li>
<li><code>page.getTotal()</code>是PageHelper提供的得到分页查询中一共多少条数据的函数；<code>page.getResult()</code>是PageHelper提供的得到具体分页数据的函数；</li>
</ol>
<h3 id="5-5-编写Mapper-xml"><a href="#5-5-编写Mapper-xml" class="headerlink" title="5.5 编写Mapper.xml"></a>5.5 编写Mapper.xml</h3><ul>
<li>注意：这里使用了mybatis的mapper接口实现方式，再强调几个注意事项：<ol>
<li>mapper.xml文件名称必须和接口名称相同</li>
<li>Mapper 接口方法名和 UserMapper.xml 中定义的每个 sql 的 id 同名。</li>
<li>Mapper 接口方法的输入参数类型和 UserMapper.xml 中定义的 sql 的parameterType 类型相同。</li>
<li>Mapper 接口的返回类型和 UserMapper.xml 中定义的 sql 的 resultType 类型相同</li>
</ol>
</li>
</ul>
<p><strong>未使用PageHelper分页插件</strong>前，我们需要这样定义：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 查询总的记录数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectCount"</span> <span class="attr">resultType</span>=<span class="string">"int"</span>&gt;</span></span><br><span class="line">    select count(*) from customer;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 分页查询 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findByPage"</span> <span class="attr">parameterType</span>=<span class="string">"Map"</span> <span class="attr">resultMap</span>=<span class="string">"BaseResultMap"</span>&gt;</span></span><br><span class="line">    select * from customer</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"start != null and size != null"</span>&gt;</span></span><br><span class="line">        limit #&#123;start&#125;,#&#123;size&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 多条件查询 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findCondition"</span> <span class="attr">parameterType</span>=<span class="string">"Map"</span> <span class="attr">resultMap</span>=<span class="string">"BaseResultMap"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- where 1=1 可以保证where后的语句永远是正确的</span></span><br><span class="line"><span class="comment">        因为在where后的动态SQL可能会执行也可能不会不会执行，如果没有执行，那么where后将跟一个空值，那么显然这样是会报错的</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    select * from customer where 1 = 1</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"c_name != null and c_name != ''"</span>&gt;</span></span><br><span class="line">        and c_name like concat('%', #&#123;c_name&#125;, '%')</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"c_telephone != null and c_telephone != ''"</span>&gt;</span></span><br><span class="line">        and c_telephone like concat('%', #&#123;c_telephone&#125;, '%')</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 我们通过在Service中的计算决定了我们每次请求的数据应该从那一页开始，那一页结束 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"start != null and size != null"</span>&gt;</span></span><br><span class="line">        limit #&#123;start&#125;,#&#123;size&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意几点：</p>
<ol>
<li>findByPage方法是用来分页显示数据的，我们传进来的数据是Map集合，定义了parameType=”Map”；resultMap实现了将查询到的复杂的数据映射到一个结果集中</li>
<li>findCondition方法是用来分页显示条件查询到的数据的，注意where 1 = 1主要是用来避免以下动态sql中的条件都不满足的情况时，where后就没数据了，这样显然报错，加上1=1就避免了这种情况</li>
</ol>
<p><strong>使用了PageHelper分页插件</strong>，并且将分页查询的方法和条件查询的方法合为一个，并通过Customer对象进行封装查询条件，我们只需要：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findByPage"</span> <span class="attr">parameterType</span>=<span class="string">"cn.tycoding.pojo.Customer"</span> <span class="attr">resultMap</span>=<span class="string">"BaseResultMap"</span>&gt;</span></span><br><span class="line">    SELECT * FROM tb_customer WHERE 1=1</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"name != null"</span>&gt;</span></span><br><span class="line">        AND name LIKE CONCAT('%', #&#123;name&#125;, '%')</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"telephone != null"</span>&gt;</span></span><br><span class="line">        AND telephone LIKE CONCAT('%', #&#123;telephone&#125;, '%')</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里使用了Mybatis的动态SQL语句：如果包含查询条件就执行查询方法，不包含就不执行。注意<code>WHERE 1=1</code>的巧妙用法。</p>
<h2 id="拓展：Service层的封装"><a href="#拓展：Service层的封装" class="headerlink" title="拓展：Service层的封装"></a>拓展：Service层的封装</h2><p>因为实际项目中肯定不会仅涉及一张表的增删改查功能，那么多次编写Service层基本增删改查的接口，代码重用率就太低了，所以我们将常用的接口方法提取出来，放到一个通用的Service层接口中。</p>
<p>这里需要使用泛型类<code>&lt;T&gt;</code>这个T就代表你的接口实现类所要使用的实体类对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BaseService</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据id查询</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">findById</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么我们原本的CustomerService.java文件就修改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CustomerService</span> <span class="keyword">extends</span> <span class="title">BaseService</span>&lt;<span class="title">Customer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分页查询</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> customer 查询条件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pageCode 当前页</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pageSize 每页的记录数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">PageBean <span class="title">findByPage</span><span class="params">(Customer customer, <span class="keyword">int</span> pageCode, <span class="keyword">int</span> pageSize)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此，即可。BaseService中存放通用的方法，每个私有的Service接口中继承这个公共接口，也可以定义自己私有的接口。</p>
<h2 id="5-6-分页逻辑"><a href="#5-6-分页逻辑" class="headerlink" title="5.6 分页逻辑"></a>5.6 分页逻辑</h2><p>首先我们看一下页码是如何展示出来的：</p>
<p><img src="/2018/06/05/ssm/ssm-2/5.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">百度分页算法（每页显示10个页码）：</span><br><span class="line">  当点击页码7之后的页码，最前端的页码依次减少</span><br><span class="line">    [0] [1] [2] [3] [4] [5] [6] [7] [8] [9] [10]</span><br><span class="line">    点击[7]</span><br><span class="line">    [1] [2] [3] [4] [5] [6] [7] [8] [9] [10] [11]</span><br><span class="line">算法：</span><br><span class="line">  若 总页数 &lt;= 10   则begin=1        end=总页数</span><br><span class="line">  若 总页数 &gt; 10    则begin=当前页-5      end=当前页+4</span><br><span class="line">    头溢出: 若begin &lt; 1    则begin=1    end=10</span><br><span class="line">    尾溢出: 若end &gt; 总记录数   则brgin=end-9  end=总页数  </span><br><span class="line">    </span><br><span class="line">此项目设置每页显示5个页码：</span><br><span class="line">  若 总页数 &lt;= 5    则begin=1       end=总页数</span><br><span class="line">  若 总页数 &gt;  5    则begin=当前页-1      end=当前页+3</span><br><span class="line">    头溢出: 若begin &lt; 1     则begin=1     end=5</span><br><span class="line">    尾溢出: 若end &gt; 总记录数   则brgin=end-4  end=总页数</span><br><span class="line"></span><br><span class="line">* (end表示页面的最后一个页码，begin表示页面的第一个页码)</span><br></pre></td></tr></table></figure>

<p>之前有人会问道这个<em>头溢出</em>和<em>尾溢出</em>是什么意思？其实仔细看看，如果我们安装上面设计的算法逻辑：头溢出就是指当页数很多一直点击上一页，为避免出现第0页而设置的；那么尾溢出就如下图所示情况了：</p>
<p><img src="/2018/06/05/ssm/ssm-2/6.png" alt></p>
<hr>
<h1 id="综上"><a href="#综上" class="headerlink" title="综上"></a>综上</h1><p>到此为止，我们基本讲完了SSM框整合的过程，你是否看明白了呢？其实整合SSM框架并不难，按照这个思路，我们学习完SSM框架整合，就可以着手练习一些小项目了。详细过程，大家可以从我的项目源码中分析。</p>
<h1 id="项目运行截图"><a href="#项目运行截图" class="headerlink" title="项目运行截图"></a>项目运行截图</h1><p><img src="/2018/06/05/ssm/ssm-2/img-1.png" alt></p>
<p><img src="/2018/06/05/ssm/ssm-2/img-2.png" alt></p>
<p><img src="/2018/06/05/ssm/ssm-2/img-3.png" alt></p>
<br>

<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <tags>
        <tag>ssm</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring、SpringMVC、Mybatis整合之工程的搭建</title>
    <url>/2018/06/04/ssm/ssm/</url>
    <content><![CDATA[<p><strong>SSM框架整合之环境配置部分</strong></p>
<p>学习完了Spring、SpringMVC、Mybatis框架，我们就可以尝试系统将三者进行整合。整合并不复杂，我们只需要实现最基础的配置，即可轻松的掌握SSM框架是如何实际项目中使用的。<br>基于上一篇博文：<a href="http://tycoding.cn/2018/06/01/ssm/maven/" target="_blank" rel="noopener">maven起步</a>，我们应该知道了如何搭建maven项目，那么在此基础上，手把手教你搭建Spring、SpringMVC、Mybatis框架的环境。</p>
<p>源码请 <a href="https://github.com/TyCoding/ssm" target="_blank" rel="noopener">点击这里</a> 前往我的GitHub。</p>
<a id="more"></a>

<h1 id="关于项目"><a href="#关于项目" class="headerlink" title="关于项目"></a>关于项目</h1><h2 id="项目环境"><a href="#项目环境" class="headerlink" title="项目环境"></a>项目环境</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">项目框架：后端：spring+mybatis+springmvc; 前端：bootstrap+Font Awesome图标集</span><br><span class="line">测试环境：IDEA+tomcat7+mysql5.7+jdk8+maven</span><br><span class="line">数据库名称：ssm</span><br></pre></td></tr></table></figure>

<h2 id="项目功能"><a href="#项目功能" class="headerlink" title="项目功能"></a>项目功能</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 用户登录</span><br><span class="line">2. 客户信息的增、删、改、查</span><br><span class="line">3. 客户信息的列表展示和分页查询功能</span><br></pre></td></tr></table></figure>

<h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p><img src="/2018/06/04/ssm/ssm/directory.png" alt></p>
<p><strong>备注</strong><br>如上这是一个标准的maven项目（对maven项目的搭建有不懂的可以查看我的博文：<a href="http://tycoding.cn/2018/06/01/ssm/maven/" target="_blank" rel="noopener">maven起步</a></p>
<blockquote>
<p><strong>img:</strong> 放了一些README.md文档所需要得图片，没有实际意义。</p>
<p><strong>controller:</strong> web层，存放springmvc的相关控制器类。</p>
<p><strong>mapper:</strong> 存放接口和映射文件。因为本项目采用了mybatis的接口开发，所以需要将接口和映射文件放在同一目录下，并且名称相同。</p>
<p><strong>pojo:</strong> 存放Java的实体类</p>
<p><strong>service:</strong> 业务层，用于存放一些业务层代码。</p>
</blockquote>
<p>不要奇怪为什么没有出现Dao层，因为本项目相对简单，并没有多复杂的逻辑，所以也就必要再写一个Dao层进行扩展。</p>
<blockquote>
<p><strong>resources:</strong> 是maven项目存放配置文件的根目录，在本例中包含两个子文件夹:<code>resource</code>、<code>spring</code>。前者是存放一些如<code>logback.properties</code>的配置文件；后者是存放spring的配置文件（spring和springmvc）。</p>
<p><strong>my.sql:</strong> 存放了关于项目数据库创建和表创建的SQL语句。</p>
<p><strong>fonts:</strong> 存放一些字体的配置文件。为了页面的美感，我们采用了<em>Awesome</em>图标集。</p>
<p><strong>lib:</strong> 包含了项目中用到的一些前端类库。</p>
<p><strong>page:</strong> 包含所有前端页面。</p>
</blockquote>
<h2 id="整合思路"><a href="#整合思路" class="headerlink" title="整合思路"></a>整合思路</h2><p>继上一篇博文：<a href="http://tycoding.cn/2018/05/29/ssm/Spring-5/" target="_blank" rel="noopener">Spring MVC起步</a>其实我们已经了解了如何整合Spring和Spring MVC框架。那么，接下来我们就需要了解如何在此基础上整合Mybatis框架。<br>首先须知Mybatis框架是一个持久层框架，而Spring MVC是WEB层框架，Spring框架则充当着业务层的角色。那么将三者联系起来正好组成了<code>web--service--dao</code>的三层架构体系。那么整合思路就如下所示了：</p>
<ol>
<li>整合dao(即mapper)，实现Mybatis和Spring的整合</li>
<li>整合service，由Spring管理service接口，在service中可以调用dao（mapper）</li>
<li>整合web（controller），实现Spring MVC和Spring的整合，在controller中调用service</li>
</ol>
<h1 id="jar依赖"><a href="#jar依赖" class="headerlink" title="jar依赖"></a>jar依赖</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencys</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 单元测试 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 1.日志 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 2.数据库 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.37<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- DAO: MyBatis --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 3.Servlet web --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 4.Spring --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 1)Spring核心 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 2)Spring DAO层 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 3)Spring web --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 4)Spring test --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>以上是SSM框架最基本的依赖配置，很多时候项目中的报错是因为jar包冲突，为避免尽量采用同一版本的jar依赖。</p>
<p><strong>注:</strong> 因为本项目使用的是IDEA，我们还需要在pom.xml中写入以下配置，以便IDEA能够检测到maven工程非resources目录下的配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>ssm<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;basedir&#125;/src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;basedir&#125;/src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="XML配置文件"><a href="#XML配置文件" class="headerlink" title="XML配置文件"></a>XML配置文件</h1><h2 id="jdbc-properties"><a href="#jdbc-properties" class="headerlink" title="jdbc.properties"></a>jdbc.properties</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jdbc.driver=com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql://localhost:3306/ssm_paging?useUnicode=true&amp;characterEncoding=UTF-8</span><br><span class="line">jdbc.username=用户名</span><br><span class="line">jdbc.password=密码</span><br></pre></td></tr></table></figure>

<p>把数据库信息单独提取到一个文件中，在XML中先使用<code>&lt;context:property-placeholder&gt;</code>加载配置文件，然后使用<code>${jdbc.xx}</code>的格式调用即可。</p>
<p><strong>注意</strong>：在jdbc.url属性中对应的数据库链接要规定字符编码为UTF-8，因为我遇到的情况就是我在创建数据库和表的时候都指定了字符集，但是前台保存进来的数据还是会乱码，就是项目在链接数据库时没有指定字符编码的原因</p>
<h2 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a>web.xml</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">id</span>=<span class="string">"WebApp_ID"</span> <span class="attr">version</span>=<span class="string">"2.5"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Archetype Created Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>/WEB-INF/index.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置spring的字符编码过滤器，保证request请求的中文字符不会乱码（注意这个过滤器要放到最前面） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncoding<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncoding<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 设置这个字符编码过滤器作用与每一个请求 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置Spring的servlet监听器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 加载spring容器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring/beans.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置springmvc的前端控制器，request请求会先经过这个控制器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 同时加载Spring MVC的配置文件。request经过了前端控制器接下来就根据映射器判断该请求需要走哪个控制器 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring/springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- *.do 表示我们请求映射路径后缀为.do，  我们也可以设置为/ --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.do<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在<code>web.xml</code>中的配置主要是三方面：</p>
<ol>
<li>配置Spring的字符编码过滤器:<code>CharacterEncodingFilter</code>（防止request请求中文乱码）。</li>
<li>配置Spring的servlet监听器:<code>ContextLoaderListener</code>，告诉Spring需要加载那哪些配置文件来完成Spring的上下文。配置文件通过<code>contextConfigLocation</code>指定。</li>
<li>配置Spring MVC的前端控制器（所有的request请求都会先经过这个前端控制器）。</li>
</ol>
<h2 id="beans-xml"><a href="#beans-xml" class="headerlink" title="beans.xml"></a>beans.xml</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置注解扫描 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"cn.tycoding.service"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 加载配置文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:resource/jdbc.properties"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 数据库连接池 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置连接池属性 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driver&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- c3p0连接池的私有属性 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxPoolSize"</span> <span class="attr">value</span>=<span class="string">"30"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minPoolSize"</span> <span class="attr">value</span>=<span class="string">"10"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 关闭连接后不自动commit --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"autoCommitOnClose"</span> <span class="attr">value</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 获取连接超时时间 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"checkoutTimeout"</span> <span class="attr">value</span>=<span class="string">"10000"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 当获取连接失败重试次数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"acquireRetryAttempts"</span> <span class="attr">value</span>=<span class="string">"2"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置SqlSessionFactory对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入数据库连接池 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 扫描pojo包，使用别名配置(在mybatis中可以使用别名，即pojo的名称) --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"typeAliasesPackage"</span> <span class="attr">value</span>=<span class="string">"cn.tycoding.pojo"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 扫描mapper的配置文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperLocations"</span> <span class="attr">value</span>=<span class="string">"classpath:cn/tycoding/mapper/*.xml"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--也可以引入mybatis配置文件 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name="configLocation" value="classpath:mybatis/SqlMapConfig.xml"/&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 使用mybatis的接口代理开发模式(必须保证接口和对应的mybatis的xml名称相同，且在一个文件夹内) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"cn.tycoding.mapper"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"/&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>备注：</strong><br>本例中<code>beans.xml</code>主要配置两块内容：1.连接池；2.Mybatis-Spring的配置<br>（当然可能这并不很标准，例如一些事物管理器，在这里我并没有配置；同样，你还可以将相关的Mybatis的配置提取出来，只要在最后<code>web.xml</code>中加载这个配置文件就可以了。</p>
<h3 id="SqlSessionFactoryBean"><a href="#SqlSessionFactoryBean" class="headerlink" title="SqlSessionFactoryBean"></a>SqlSessionFactoryBean</h3><p>Spring框架简化数据库访问的方式之一就是管理数据库连接的声明周期和ORM框架的Session，以确保他们正常的打开和关闭。而在mybatis-spring中，SqlSessionFactoryBean实现了Spring的FactoryBean接口，用于创建<code>SqlSessionFactory</code>。</p>
<ul>
<li><code>dataSource</code>是必要的配置，上面我们仅仅是写了数据源配置，接下来的数据库访问对象肯定要使用这个数据源来获取链接对象，所以必须指定数据源。</li>
<li><code>typeAliases</code>则是启用别名配置，<code>typeAliasesPackage</code>则会为<code>pojo</code>包下的所有类对象都配置别名，当我们在对应的XML映射中指定<code>ResultType</code>等时，就可以直接写pojo的类名，而不需要写全限定名。</li>
<li><code>mapperLocations</code>: 用于指定Mapper的XML文件位置（对于那种Mapper接口和XML配置同名且在同一个配置文件夹下，Mybatis其实会根据Mapper的Class文件自动找对应的XML配置文件，但是这里我建议写上）。</li>
<li><code>configLocation</code>: 用于指定mybatis的配置文件位置，因为本项目中并没有涉及太多复杂的逻辑，所以这里我就没有特意配置mybatis的config。</li>
</ul>
<h3 id="MapperScannerConfigurer"><a href="#MapperScannerConfigurer" class="headerlink" title="MapperScannerConfigurer"></a>MapperScannerConfigurer</h3><p>在了解<code>MapperScannerConfigurer</code>之前我们需要了解一下<code>MapperFactoryBean</code>，Mybatis-Spring提供了一个动态代理的实现：<code>MapperFactoryBean</code>，他能实现将映射器接口（因为代理创建在运行环境中，那么指定的映射器必须是接口而不是实现类）直接注入到service的Bean中。这样通过代理对象去创建编写数据访问对象，从而代替<code>SqlSessionTepmlate</code>等工具。<br>但是在Mybatis-Spring中还提供了一个转换器<code>MapperScannerConfigurer</code>，它会查找类路径下的映射器（接口）并自动将他们创建成<code>MapperFactoryBean</code>。通过将接口转换成Spring容器中的Bean，在Service层直接注入接口即可，这样大大简化了Dao层实例的编写。<br><code>basePackage</code>正是指定接口的位置。<br>注意我们这里并不需要指定<code>SqlSessionFactory</code>(即我们注释掉的部分)，因为使用<code>MapperScannerConfigurer</code>会创建<code>MapperFactoryBean</code>后自动装配（XML配置）。但是如果存在多个<code>dataSource</code>，该自动装配可能就会失效，这时我们必须使用<code>sqlSessionFacoryBeanName</code>来指定引用哪个<code>bean</code>。</p>
<p>在<code>beans.xml</code>配置阶段算是基本告一段落，我们回想一下：在没有使用Mybatis前我们使用Spring提供的JDBC模板来访问数据库，我们发现这种方式代码量特别大，而且于Java代码的耦合性也比较大，Mybatis则正好弥补了这些缺点，它使用的XML配置更加的小巧方便且支持原生SQL的编写。<br><strong>Mybatis-Spring</strong>提供了移动动态代理的方式来代替手工的<code>SqlSessionTemplate</code>编写数据库访问对象，我们只需要编写一个接口，通过在Mapper对应的XML中直接写SQL就可以进行数据库访问。当然我们必须配置<code>SqlSessionFactoryBean</code>和<code>MapperScannerConfigurer</code>。</p>
<h2 id="springmvc-xml"><a href="#springmvc-xml" class="headerlink" title="springmvc.xml"></a>springmvc.xml</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">         http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">         http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">         http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">         http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">         http://www.springframework.org/schema/context/spring-tx.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">         http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">         http://www.springframework.org/schema/mvc/spring-mvc.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 开启注解扫描 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.TyCoding.controller"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置springmvc的基本控制器，并开启了对json数据格式的支持 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置springmvc的视图解析器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在博文<a href="tycoding.cn/2018/05/29/Spring-5/">初识Spring MVC</a>我们已经对SpringMVC有了一定的了解。那么在这里我们回顾一下SpringMVC的架构设计：<br><img src="/2018/06/04/ssm/ssm/1.png" alt><br>那么SpringMVC的XML无非就是：</p>
<ol>
<li>配置SpringMVC前端控制器。</li>
<li>配置SpringMVC的基本控制器（处理请求的Spring组件）。</li>
<li>配置视图解析器。</li>
</ol>
<p>所以：</p>
<ol>
<li>首先在<code>web.xml</code>中配置SpringMVC的前端控制器:<code>DispatcherServlet</code>。</li>
<li>在<code>springmvc.xml</code>中配置SpringMVC的基本控制器:<code>&lt;mvc:annotation-driven&gt;</code>（注解驱动方式）。</li>
<li>开启注解扫描：<code>&lt;context:component-scan&gt;</code>，主要扫描Controller层的注解（因为SpringMVC是web层框架）。</li>
<li>配置SpringMVC的视图解析器：<code>InternalResourceViewResolver</code>，用于当Controller处理完请求后将处理后的数据结果返回给视图层（JSP等）。</li>
</ol>
<h1 id="配置pojo和sql"><a href="#配置pojo和sql" class="headerlink" title="配置pojo和sql"></a>配置pojo和sql</h1><h2 id="pojo"><a href="#pojo" class="headerlink" title="pojo"></a>pojo</h2><p>在项目<code>pojo</code>文件夹下创建<code>User.java</code>和<code>Customer.java</code>以及<code>PageBean.java</code><br><strong>1.User</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用户id</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="comment">//用户登录名</span></span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"><span class="comment">//用户密码</span></span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line">...</span><br><span class="line">getter/setter方法省略</span><br></pre></td></tr></table></figure>

<p><strong>2.Customer</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//客户的id</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="comment">//客户的姓名</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="comment">//客户的电话</span></span><br><span class="line"><span class="keyword">private</span> String telephone;</span><br><span class="line"><span class="comment">//客户的住址</span></span><br><span class="line"><span class="keyword">private</span> String address;</span><br><span class="line"><span class="comment">//客户备注</span></span><br><span class="line"><span class="keyword">private</span> String remark;</span><br><span class="line">...</span><br><span class="line">getter/setter方法省略</span><br></pre></td></tr></table></figure>

<p><strong>3.PageBean</strong><br><code>PageBean</code>为实现分页疯转给的JavaBean，详细字段属性请查看注释。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当前页</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> pageCode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//总页数=总条数/每页显示的条数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> totalPage;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//总记录数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> totalCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每页显示的记录条数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> pageSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每页显示的数据</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; beanList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里用了自定义泛型类<code>&lt;T&gt;</code>就是实现由后台决定这个分页Bean要去封装那种类型的数据，我们调用时传入类型就会封装什么类型数据。比如我们需要对Customer分页，在调用这个类是就写<code>new PageBean&lt;Customer&gt;()</code>。那么数据就会强制绑定为这个<code>Customer</code>类的数据。</p>
<h2 id="sql"><a href="#sql" class="headerlink" title="sql"></a>sql</h2><p>创建数据库并编写项目所需要的表结构，写入测试数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create database ssm character set utf8;</span><br><span class="line">use ssm;</span><br><span class="line"></span><br><span class="line">create table tb_user(</span><br><span class="line">    id int primary key auto_increment,</span><br><span class="line">    username varchar(100),</span><br><span class="line">    password varchar(100)</span><br><span class="line">) default charset = utf8;</span><br><span class="line"></span><br><span class="line">create table tb_customer(</span><br><span class="line">    id int primary key auto_increment,</span><br><span class="line">    name varchar(100),</span><br><span class="line">    telephone varchar(100),</span><br><span class="line">    address varchar(100),</span><br><span class="line">    remark varchar(100)</span><br><span class="line">) default charset = utf8;</span><br><span class="line"></span><br><span class="line"># 插入数据</span><br><span class="line">insert into tb_user values(1,&apos;admin&apos;,&apos;admin&apos;);</span><br><span class="line"></span><br><span class="line">insert into tb_customer values(1,&apos;涂陌&apos;,&apos;123456789&apos;,&apos;你猜&apos;,&apos;不想写备注&apos;);</span><br><span class="line">insert into tb_customer values(2,&apos;逗瓜&apos;,&apos;123456789&apos;,&apos;你猜&apos;,&apos;不想写备注&apos;);</span><br><span class="line">insert into tb_customer values(3,&apos;愤青&apos;,&apos;123456789&apos;,&apos;你猜&apos;,&apos;不想写备注&apos;);</span><br><span class="line">insert into tb_customer values(4,&apos;咸鱼&apos;,&apos;123456789&apos;,&apos;你猜&apos;,&apos;不想写备注&apos;);</span><br><span class="line">insert into tb_customer values(5,&apos;小白&apos;,&apos;123456789&apos;,&apos;你猜&apos;,&apos;不想写备注&apos;);</span><br><span class="line">insert into tb_customer values(6,&apos;菜鸡&apos;,&apos;123456789&apos;,&apos;你猜&apos;,&apos;不想写备注&apos;);</span><br></pre></td></tr></table></figure>

<h1 id="综上"><a href="#综上" class="headerlink" title="综上"></a>综上</h1><p>到目前为止我们已经完成了Spring、SpringMVC、Mybatis的基本配置，并创建了项目所需的实体类以及数据库表。<br>最后我们需要将该项目部署到Tomcat服务器上。如果配置正确，那么在浏览器上回弹出index页面。</p>
<br>

<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>使用IDEA搭建一个maven项目</title>
    <url>/2018/06/01/ssm/maven/</url>
    <content><![CDATA[<p><strong>maven起步</strong></p>
<p><strong>maven</strong>作为一个项目管理工具被用于管理项目中的jar包，因此能大大的减轻我们项目的体积。要知道项目体积大基本就是项目的jar依赖体积过大造成的，刨去这些依赖文件，实际编写的代码占用的空间很小很小。<br>接下来我们会实战在IDEA上搭建一个maven项目，快来看看吧！</p>
<a id="more"></a>
<h1 id="关联maven"><a href="#关联maven" class="headerlink" title="关联maven"></a>关联maven</h1><h2 id="前期配置"><a href="#前期配置" class="headerlink" title="前期配置"></a>前期配置</h2><p>打开IDEA后在右下角<code>Configure</code>中选择如下<code>setting</code>进入设置界面（选择<code>project Defaults</code>可以让以后新建的项目都使用这个默认的配置，这样就不用每次新建项目都关联maven路径了）：<br><img src="/2018/06/01/ssm/maven/1.png" alt><br>在setting界面中线在搜索框中查询<em>maven</em>，然后选择本机的maven的位置和<code>seetings.xml</code>位置以及本地仓库的位置<br><img src="/2018/06/01/ssm/maven/2.png" alt></p>
<p>设置完毕我们开始新建项目<code>new project</code>。记住选择图中的三点：<br><img src="/2018/06/01/ssm/maven/3.png" alt><br>下面设置本项目坐标值，至于groupid和artifactid具体指什么大家可以自行百度一下，在这里我们理解为：groupid为项目坐标的域；artifactid为本项目的名称。<br><img src="/2018/06/01/ssm/maven/4.png" alt></p>
<p>继续next，下一步可以看到我们新建的项目已经关联到了本机的maven。这里我们还需要新建一个<code>properties</code>参数：<code>archetypeCatalog=internal</code>目的是为了提高maven下载的速度。<br><img src="/2018/06/01/ssm/maven/5.png" alt></p>
<p>下面就是设置项目的存放路径以及项目名称：<br><img src="/2018/06/01/ssm/maven/6.png" alt></p>
<p>最后finish完成maven项目的最基本配置。<br><img src="/2018/06/01/ssm/maven/7.png" alt></p>
<h1 id="规范目录结构"><a href="#规范目录结构" class="headerlink" title="规范目录结构"></a>规范目录结构</h1><p>因为maven项目硬性规定了你必须使用它规定的项目目录结构，不然就不能正常编译项目。我们首先需要点击<code>main</code>文件夹，右键new两个<code>Directory</code>，名字为<code>resources</code>和<code>java</code>:
<img src="/2018/06/01/ssm/maven/8.png" alt><br>新建完毕，我们需要指定这个<code>resources</code>目录为配置文件目录，只需要点击<code>resources</code>文件夹，选择<code>Mark Directory as</code>，点击<code>Resources Root</code>;同时要指定<code>java</code>文件夹为存放源代码的文件夹，在<code>Mark Directory as</code>中点击<code>Sources Root</code><br><img src="/2018/06/01/ssm/maven/9.png" alt><br><img src="/2018/06/01/ssm/maven/10.png" alt><br>当然我们还可以，新建一个文件夹<code>Test</code>作为测试文件的存放目录，但是要注意<code>java</code>和<code>resources</code>目录都是在<code>mian</code>文件夹下的，而<code>Test</code>是和<code>main</code>目录同一级的。同样我们需要设置其为<code>Resources Test Root</code></p>
<p>最终设置完毕我们互发现文件夹的颜色已经改变，这也是我们最终的项目目录结构<br><img src="/2018/06/01/ssm/maven/11.png" alt></p>
<p><strong>介绍：</strong></p>
<ol>
<li><code>java</code>目录使我们存放所有java代码的地方。（当然里面也可以存在xml配置，但是需要配置参数，后面会介绍）。</li>
<li><code>resources</code>目录存放我们项目中所有的配置文件，比如<code>spring.xml</code>了。</li>
<li><code>webapp</code>是存放项目前端代码的地方。</li>
<li><code>Test</code>是存放测试文件的地方。</li>
</ol>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>我们还需要在<code>pom.xml</code>的<code>&lt;build&gt;</code>节点下添加这一段配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;basedir&#125;/src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;basedir&#125;/src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如图所示（我删除了原本<code>pom.xml</code>的<code>&lt;build&gt;</code>节点下默认生成的配置）<br><img src="/2018/06/01/ssm/maven/12.png" alt><br>这段配置是为了让IDEA检测到非<code>resources</code>目录下的配置文件，比如你写在<code>java</code>文件夹下的配置文件。</p>
<p><strong>综上</strong><br>我们已经完成了IDEA下maven项目的搭建。如果需要导入项目依赖jar文件，只需要在maven<a href="http://mvnrepository.com/" target="_blank" rel="noopener">中心仓库</a>中找到该依赖jar的坐标值，copy到项目的<code>pom.xml</code>的<code>dependencies</code>下即可。这一点相对于<em>eclipse</em>方便了太多太多。</p>
<p>好了，到目前为止，我们基本完成了在IDEA搭建一个maven项目的案例，接下来就愉快的码项目吧！！</p>
<br>

<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC之文件上传和下载</title>
    <url>/2018/05/31/ssm/Spring-6/</url>
    <content><![CDATA[<p><strong>SpringMVC实现文件的上传和下载</strong><br>相对于JavaWeb阶段我们使用过servlet实现文件上传和下载操作；而SpringMVC实现了对上传操作的直接支持，提供了<code>multipart</code>解析器。<code>MultipartFile</code>提供了一些对文件操作的方法，使得文件上传变得更简单。无论上传还是下载都是进行二进制流的转换，下面我们以案例的形式了解一下如何使用SpringMVC实现文件的上传操作。</p>
<a id="more"></a>

<h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><h3 id="了解"><a href="#了解" class="headerlink" title="了解"></a>了解</h3><ol>
<li>文件上传我们首先要考虑的就是把文件上传到哪里？是上传到工程目录下，还是上传到本地磁盘中？</li>
<li>因为上传的文件一般都是二进制文件，所以我们需要通过某种方式对表单提交进行编码。通过将<code>enctype</code>设置为<code>multipart/form-data</code>，每个输入域都将作为POST请求的不同部分进行提交（默认提交的表单中数据存储格式是<code>名字-值</code>，显然是不适合类似文件上传那种二进制数据的）。</li>
<li>Spring提供了对<code>multipart</code>数据的解析器<code>CommonsMultipartResolver</code>（<code>MultipartResolver</code>接口的实现类），但是这个解析器是基于<code>Apache Commons FileUpload</code>技术的，所以需要<code>commons-filrUpload.jar</code>支持。</li>
</ol>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>除了我们之前使用的Spring以及SpringMVC的先关jar依赖包，还需要导入以下jar文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">commons-fileupload.jar</span><br><span class="line">commons-io.jar</span><br></pre></td></tr></table></figure>

<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>首先我们看一下项目结构：<br><img src="/2018/05/31/ssm/Spring-6/6-0.png" alt><br>注意：这里我使用的配置是：IDEA + tomcat + Maven，对于maven项目我们要清楚项目编译后的文件都放在<code>target</code>目录下。</p>
<ol>
<li>修改我们的<code>save.jsp</code><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">isELIgnored</span>=<span class="string">"false"</span> %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">contentType</span>=<span class="string">"text/html;charset=UTF-8"</span> <span class="attr">language</span>=<span class="string">"java"</span> %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span></span></span><br><span class="line"><span class="tag">    <span class="attr">String</span> <span class="attr">path</span> = <span class="string">request.getContextPath();</span></span></span><br><span class="line"><span class="tag">    <span class="attr">String</span> <span class="attr">basePath</span> = <span class="string">request.getScheme()</span> + "<span class="attr">:</span>//" + <span class="attr">request.getServerName</span>() + "<span class="attr">:</span>" + <span class="attr">request.getServerPort</span>() + <span class="attr">path</span>;</span></span><br><span class="line"><span class="tag">%&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>表单<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"&lt;%=basePath%&gt;/user/save"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">    username: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    password: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    profile image:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"image"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>解释：</strong><br>注意在上面<code>&lt;%%&gt;</code>中的Java代码是获取本项目的相对路径，相当于<code>&lt;%=pageContext.request.ContextPath%&gt;</code>。接下来我们将表单<code>&lt;form&gt;</code>标签中设置属性<code>enctype=&quot;multipart/form-data&quot;</code>。</p>
<ol start="2">
<li><code>Controller</code>层<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//保存用户</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/save"</span>, method = RequestMethod.POST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">save</span><span class="params">(@RequestParam String username, @RequestParam String password, @RequestParam(value=<span class="string">"image"</span>,required = <span class="keyword">false</span>)</span>MultipartFile image, HttpServletRequest request, Model model) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取文件在服务器上的储存位置</span></span><br><span class="line">    String path = request.getSession().getServletContext().getRealPath(<span class="string">"resources/upload"</span>);</span><br><span class="line">    File filePath = <span class="keyword">new</span> File(path);</span><br><span class="line">    System.out.println(<span class="string">"文件保存路径："</span> + path);</span><br><span class="line">    <span class="keyword">if</span> (!filePath.exists() &amp;&amp; !filePath.isDirectory()) &#123;</span><br><span class="line">        System.out.println(<span class="string">"目录不存在，创建目录："</span> + filePath);</span><br><span class="line">        filePath.mkdir();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取原始文件名称</span></span><br><span class="line">    String originalFileName = image.getOriginalFilename();</span><br><span class="line">    System.out.println(<span class="string">"原始文件名称："</span> + originalFileName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取文件类型，以最后一个`.`作为标识</span></span><br><span class="line">    String type = originalFileName.substring(originalFileName.lastIndexOf(<span class="string">"."</span>) + <span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">"文件类型："</span> + type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置文件新名字</span></span><br><span class="line">    String fileName = System.currentTimeMillis() + <span class="string">"."</span> + type;</span><br><span class="line">    System.out.println(<span class="string">"文件新名称："</span> + fileName);</span><br><span class="line">    <span class="comment">//在指定路径创建一个文件</span></span><br><span class="line">    File targetFile = <span class="keyword">new</span> File(path, fileName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将文件保存到服务器指定位置</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        image.transferTo(targetFile);</span><br><span class="line">        model.addAttribute(<span class="string">"message"</span>, <span class="string">"保存数据成功"</span>);</span><br><span class="line">        userService.save(username,password,<span class="string">"resources/upload/"</span> + fileName);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"view/success"</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">"保存文件错误..."</span>);</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"view/error"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>Controller层就比较复杂了，因为对于本案例而言文件上传操作的主要代码都在Controller层，而Service和Dao层仅是执行保存操作。我们首先了解一下文件操作的API方法：</p>
<blockquote>
<ol>
<li>request.getSession().getServletContext().getRealPath(String s)：获取本项目下指定目录的绝对路径。</li>
<li>MultipartFile.getOriginalFilename()：获取被<code>MultipartFile</code>绑定的上传参数的原始名称 </li>
<li>System.currentTimeMillis()：获取自1970年1月1日0时起到现在时间的毫秒数。</li>
<li>MultipartFile.transferTo()： 在指定的磁盘路径下生成一个新的文件。</li>
</ol>
</blockquote>
<ul>
<li>jsp中的form表单将数据提交到这个映射方法，那么我们就要接受jsp中传递的参数，要注意的就是绑定<code>image</code>参数是<code>MultipartFile</code>数据类型。</li>
<li>下面就要定义一个上传文件的保存目录，本例中使用<code>request.getSession().getServletContext().getRealPath()</code>获取到的是本项目的绝对路径，而<code>getRealPath(&quot;resources/upload&quot;)</code>是针对此项目的相对路径，如此时的文件保存路径其实是：<code>/Users/ty/Documents/Java/Learn/ssm/target/TyCoding/resources/upload</code>。</li>
<li>如果指定路径下的文件夹存在，就将上传的文件写入进这个文件夹中，如果此文件夹不存在，就调用<code>mkdir()</code>方法创建此文件夹。</li>
<li>上述一切都准备就绪，最后会调用Service层的<code>save()</code>方法将表单数据保存到数据库中。（<strong>注意：</strong>在调用的<code>save()</code>方法中我们会看到实际写入进数据库中的上传文件的路径其实仅是相对此项目的相对路径（即相对于<code>webapp</code>）。</li>
</ul>
<ol start="4">
<li>最后我们要在Spring配置文件中注册这个multipart解析器：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置支持文件上传 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"multipartResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span> <span class="attr">p:maxUploadSize</span>=<span class="string">"500000"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><code>maxUploadSize</code>是设置上传文件的大小，可以更改。</p>
<p>下面我们看一下实际效果：<br><img src="/2018/05/31/ssm/Spring-6/6-1.png" alt><br>点击提交按钮，访问后台映射方法：<br><img src="/2018/05/31/ssm/Spring-6/6-2.png" alt><br>可以看到已经获取到表中的数据，并准备调用Service层保存数据，那么我们看一下最后的Dao层将数据存入进数据库的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImp</span> <span class="keyword">extends</span> <span class="title">JdbcDaoSupport</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(String username, String password, String image)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用Spring提供的JDBC模板可以直接执行SQL语句</span></span><br><span class="line">        <span class="keyword">this</span>.getJdbcTemplate().update(<span class="string">"insert into user(id,username,password,image) values(?,?,?,?)"</span>,<span class="keyword">null</span>,username,password,image);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后数据保存成功，跳转到成功页面：<br><img src="/2018/05/31/ssm/Spring-6/6-3.png" alt><br><img src="/2018/05/31/ssm/Spring-6/6-4.png" alt><br><img src="/2018/05/31/ssm/Spring-6/6-5.png" alt><br>看一下此文件在工程中的位置：<br><img src="/2018/05/31/ssm/Spring-6/6-6.png" alt><br>看一下储存到数据库中数据：<br><img src="/2018/05/31/ssm/Spring-6/6-7.png" alt></p>
<ol start="4">
<li>最后我们看一下通过SQL语句：<code>select * from user</code>，将查询到的数据回显到页面上：<br><code>list.jsp</code><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>id<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>username<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>password<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>avatar<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">c:forEach</span> <span class="attr">items</span>=<span class="string">"$&#123;userList&#125;"</span> <span class="attr">var</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;user.id&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;user.username&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;user.password&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"&lt;%=basePath%&gt;/$&#123;user.image&#125;"</span> <span class="attr">width</span>=<span class="string">"100"</span> <span class="attr">height</span>=<span class="string">"80"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">c:forEach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><img src="/2018/05/31/ssm/Spring-6/6-8.png" alt></p>
<p><strong>答疑：</strong></p>
<ol>
<li>我们设置的<code>getRealPath(&quot;resources/upload&quot;)</code>不该是相对于工程的路径吗？（也就是在<code>webapp</code>下）。为什么上传的文件会保存到<code>target</code>目录下？<br>答：我们要明白Tomcat下运行的项目实际是编译后的class文件，即此maven项目中的<code>target</code>文件夹中的数据。那么我们设置的文件上传路径其实是在此编译后的文件夹中的相对路径（<code>TyCoding</code>是我设置的<code>artifact id</code>）</li>
<li>为什么我们保存到数据中的路径是项目的相对路径？<br>答：要知道在Tomcat下运行项目，我们访问的图片路径是需要在<code>localhost:8080</code>下的路径，也就是当前项目的相对路径，所以我们如果保存一个带盘符的绝对路径是肯定不能访问到的。</li>
</ol>
<h1 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h1><h2 id="准备-1"><a href="#准备-1" class="headerlink" title="准备"></a>准备</h2><h3 id="了解-1"><a href="#了解-1" class="headerlink" title="了解"></a>了解</h3><p>文件上传我们这里设计的思路是：在页面设置一个可点击的连接（比如<code>&lt;a&gt;</code>），点击即可下载，而我们需要在其<code>href</code>属性中拼接要下载的文件的名称，然后通过这个请求路径，Controller层的映射方法接收到你要下载的文件名称，然后根据指定的下载文件的路径查询到这个文件的名称，然后将文件转换成二进制流，然后让客户端读取这个二进制流写入到本机中从而实现下载。</p>
<ol>
<li><code>ResponseEntity&lt;byte[]&gt;</code>: SpringMVC提供的用于实现响应头、文件数据（以字节储存）、状态封装都一起返回给浏览器实现文件的下载。</li>
<li><code>header.setContentDispositionFormData()</code>: 告诉浏览器要以指定的数据类型打开这个文件</li>
<li><code>FileUtils.readFileToByteArray()</code>: 使用FileUtils工具类强制将指定文件数据转换成byte字节流的形式。</li>
</ol>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><ol>
<li>首先我们更改上面的<code>save.jsp</code>页面,新增一个下载的连接：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>文件下载<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&lt;%=basePath%&gt;/user/download?fileName=图片.jpg"</span>&gt;</span>点击我下载图片<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>如上所示，我们在请求路径中拼接了<code>fileName</code>参数值是<code>图片.jpg</code>那么后台接收到这个参数值，就会查询指定位置的文件。</p>
<ol start="2">
<li>然后看一下Controller的请求<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//文件下载</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/download"</span>)</span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;<span class="keyword">byte</span>[]&gt; download(HttpServletRequest request, <span class="meta">@RequestParam</span>(value=<span class="string">"fileName"</span>,required = <span class="keyword">false</span>) String fileName) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//下载路径</span></span><br><span class="line">        String path = request.getServletContext().getRealPath(<span class="string">"/resources/upload/"</span>);</span><br><span class="line">        File file = <span class="keyword">new</span> File(path + File.separator + fileName);</span><br><span class="line">        HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">        <span class="comment">//解决文件名中文乱码问题</span></span><br><span class="line">        String downloadFileName = <span class="keyword">new</span> String(fileName.getBytes(<span class="string">"UTF-8"</span>),<span class="string">"iso-8859-1"</span>);</span><br><span class="line">        <span class="comment">//告诉浏览器以"attachment"方式打开文件</span></span><br><span class="line">        headers.setContentDispositionFormData(<span class="string">"attachment"</span>,downloadFileName);</span><br><span class="line">        <span class="comment">//设置请求头的媒体格式类型为 application/octet-stream(二进制流数据)</span></span><br><span class="line">        headers.setContentType(MediaType.APPLICATION_OCTET_STREAM);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;<span class="keyword">byte</span>[]&gt;(FileUtils.readFileToByteArray(file),headers,HttpStatus.CREATED);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.out.println(<span class="string">"文件下载出错..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>首先要指定映射方法的返回数据类型是<code>ResponseEntity&lt;byte[]&gt;</code>，首先要规定一个下载文件的目录路径，需要下载文件时，就会中这个路径中查询需要下载的文件，如果找不到指定文件，那么就进catch里面。<br><code>File.separator</code>用来分隔同一个路径字符串中的目录，相当于<code>/</code>。找到了指定路径下的文件后，需要解决中文乱码问题，然后告诉浏览器要以<code>attachment</code>的方式打开这个文件。<br>最后这只<code>ContentType</code>媒体格式类型，最后使用<code>FileUtils</code>的<code>readFileToByteArray</code>将文件数据转换成二进制字节流，连同设置好的响应数据格式一同返回给浏览器，实现文件的下载。</p>
<p>最后看一下实际的效果：<br><img src="/2018/05/31/ssm/Spring-6/6-9.png" alt><br><img src="/2018/05/31/ssm/Spring-6/6-10.png" alt></p>
<br>

<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><p>QQGroup：671017003   </p>
<p>WeChatGroup:  关注公众号查看</p>
<h1 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h1><ul>
<li><a href="http://www.tycoding.cn">Blog@TyCoding’s blog</a></li>
<li><a href="https://github.com/TyCoding" target="_blank" rel="noopener">GitHub@TyCoding</a></li>
<li><a href="https://www.zhihu.com/people/tomo-83-82/activities" target="_blank" rel="noopener">ZhiHu@TyCoding</a></li>
</ul>
]]></content>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
</search>
